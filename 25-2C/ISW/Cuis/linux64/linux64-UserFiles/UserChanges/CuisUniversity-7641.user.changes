

----STARTUP---- (21 October 2025 13:35:42) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverTest category: #MarsRover stamp: 'BSN 10/21/2025 13:50:25'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ISW-Parcial1-1C25.st----!

----STARTUP---- (21 October 2025 13:53:57) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ISW-Parcial1-1C25-conIfs.st----!

----STARTUP---- (21 October 2025 13:57:20) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #MarsRoverTest category: #MarsRover stamp: 'BSN 10/21/2025 13:58:04'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ISW-Parcial1-1C25.st----!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:10:24'!
test01ComandoVacioRoverNoSeMueve! !

!classDefinition: #Rover category: #MarsRover stamp: 'BSN 10/21/2025 14:13:29'!
Object subclass: #Rover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:13:10' prior: 50596903!
test01ComandoVacioRoverNoSeMueve
	| marsRover | 
	marsRover := Rover new.
	marsRover commando: ''.
	self assert marsRover estaEnPosicion: (0,0).! !

Object subclass: #Rover
	instanceVariableNames: 'posicion'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!classDefinition: #Rover category: #MarsRover stamp: 'BSN 10/21/2025 14:14:16'!
Object subclass: #Rover
	instanceVariableNames: 'posicion'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover'!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/21/2025 14:14:34'!
ERROR!
!Rover methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:15:16'!
estaEnPosicion: posicionAcomparar
	^ posicion = posicionAcomparar.! !
!Rover methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:15:37'!
commando: StringDeCommandos! !

!classRemoval: #EscapeDeFlotaTests stamp: 'BSN 10/21/2025 14:16:06'!
TestCase subclass: #EscapeDeFlotaTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW-Parcial1-1C25'!

!classRemoval: #EscapeDeFlota stamp: 'BSN 10/21/2025 14:16:06'!
Object subclass: #EscapeDeFlota
	instanceVariableNames: 'flota'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW-Parcial1-1C25'!

----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ISW-Parcial1-1C25-conIfs.st----!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:18:33' prior: 50596914!
test01ComandoVacioRoverNoSeMueve
	| marsRover | 
	marsRover := Rover new.
	marsRover commando: ''.
	self assert marsRover estaEnPosicion: (0,0).! !
!Rover methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:19:13'!
initialize 
	posicion := (0 , 0).! !

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/21/2025 14:19:16'!
ERROR!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:19:35' prior: 50597992!
test01ComandoVacioRoverNoSeMueve
	| marsRover | 
	marsRover := Rover new.
	marsRover commando: ''.
	self assert: (marsRover estaEnPosicion: (0,0)).! !

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/21/2025 14:19:38'!
ERROR!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:20:11' prior: 50598004!
test01ComandoVacioRoverNoSeMueve
	| marsRover | 
	marsRover := Rover new.
	marsRover commando: ''.
	self assert: (marsRover estaEnPosicion: 0@0).! !
!Rover methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:20:18' prior: 50597999!
initialize 
	posicion := 0@0.! !

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/21/2025 14:20:22'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/21/2025 14:20:22'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:20:46'!
test02RoverSeMueveParaAdelante
	! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:21:46' prior: 50598024!
test02RoverSeMueveParaAdelante
	| marsRover | 
	marsRover := Rover new.
	marsRover commando: 'f'.
	self assert: (marsRover estaEnPosicion: 1@0).
	! !

a := 0@0!

a x!
!Rover methodsFor: 'as yet unclassified' stamp: 'BSN 10/21/2025 14:23:43' prior: 50596937!
commando: StringDeComandos
	StringDeComandos = 'f' ifTrue: [posicion := (posicion x + 1)@(posicion y)]! !

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/21/2025 14:23:47'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/21/2025 14:23:47'!
PASSED!

----STARTUP---- (23 October 2025 15:01:48) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ejercicio-1-p3-mars-rover-este-grupo-es-un-objeto/MarsRover.st----!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:28:45'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 15:29:00'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 15:29:00'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 15:29:00'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 15:29:00'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:29:00'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:29:00'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 15:29:00'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:29:00'!
ERROR!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:29:00'!
ERROR!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:29:58' prior: 50596302!
test04RoverRota90GradosAIzquierdaSinMoverseDespues
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'I'.
	self assert: (marsRover isAt: 0@0 heading: 'N').! !

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 15:29:59'!
FAILURE!

!methodRemoval: MarsRover #rotarADerechaDesdeEsteYAvanzar stamp: 'BSN 10/23/2025 15:30:09'!
rotarADerechaDesdeEsteYAvanzar
	self rotarHacia: 'S'.
	self avanzar.!

!methodRemoval: MarsRover #rotarADerechaDesdeEsteYRetroceder stamp: 'BSN 10/23/2025 15:30:09'!
rotarADerechaDesdeEsteYRetroceder
	self rotarHacia: 'S'.
	self retroceder.!

!methodRemoval: MarsRover #rotarADerechaDesdeNorteYAvanzar stamp: 'BSN 10/23/2025 15:30:09'!
rotarADerechaDesdeNorteYAvanzar
	self rotarHacia: 'E'.
	self avanzar.!

!methodRemoval: MarsRover #rotarADerechaDesdeNorteYRetroceder stamp: 'BSN 10/23/2025 15:30:09'!
rotarADerechaDesdeNorteYRetroceder
	self rotarHacia: 'E'.
	self retroceder.!

!methodRemoval: MarsRover #rotarADerechaDesdeOesteYAvanzar stamp: 'BSN 10/23/2025 15:30:09'!
rotarADerechaDesdeOesteYAvanzar
	self rotarHacia: 'N'.
	self avanzar !

!methodRemoval: MarsRover #rotarADerechaDesdeOesteYRetroceder stamp: 'BSN 10/23/2025 15:30:09'!
rotarADerechaDesdeOesteYRetroceder
	self rotarHacia: 'N'.
	self retroceder.!

!methodRemoval: MarsRover #rotarADerechaDesdeSurYAvanzar stamp: 'BSN 10/23/2025 15:30:09'!
rotarADerechaDesdeSurYAvanzar
	self rotarHacia: 'O'.
	self avanzar.!

!methodRemoval: MarsRover #rotarADerechaDesdeSurYRetroceder stamp: 'BSN 10/23/2025 15:30:09'!
rotarADerechaDesdeSurYRetroceder
	self rotarHacia: 'O'.
	self retroceder. !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeEsteYAvanzar stamp: 'BSN 10/23/2025 15:30:09'!
rotarAIzquierdaDesdeEsteYAvanzar
	self rotarHacia: 'N'.
	self avanzar. !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeEsteYRetroceder stamp: 'BSN 10/23/2025 15:30:09'!
rotarAIzquierdaDesdeEsteYRetroceder
	self rotarHacia: 'N'.
	self retroceder !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeNorteYAvanzar stamp: 'BSN 10/23/2025 15:30:09'!
rotarAIzquierdaDesdeNorteYAvanzar
	self rotarHacia: 'O'.
	self avanzar.  !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeNorteYRetroceder stamp: 'BSN 10/23/2025 15:30:09'!
rotarAIzquierdaDesdeNorteYRetroceder
	self rotarHacia: 'O'.
	self retroceder .   !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeOesteYAvanzar stamp: 'BSN 10/23/2025 15:30:09'!
rotarAIzquierdaDesdeOesteYAvanzar
	self rotarHacia: 'S'.
	self avanzar.   !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeOesteYRetroceder stamp: 'BSN 10/23/2025 15:30:09'!
rotarAIzquierdaDesdeOesteYRetroceder
	self rotarHacia: 'S'.
	self retroceder .  !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeSurYAvanzar stamp: 'BSN 10/23/2025 15:30:09'!
rotarAIzquierdaDesdeSurYAvanzar
	self rotarHacia: 'E'.
	self avanzar.  !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeSurYRetroceder stamp: 'BSN 10/23/2025 15:30:09'!
rotarAIzquierdaDesdeSurYRetroceder
	self rotarHacia: 'E'.
	self retroceder.  !

!methodRemoval: MarsRover #estaEnPosicion: stamp: 'BSN 10/23/2025 15:31:09'!
estaEnPosicion: posicionAcomparar
	^ posicion = posicionAcomparar.!

!methodRemoval: MarsRover #isAt:heading: stamp: 'BSN 10/23/2025 15:31:09'!
isAt: posicionAcomparar heading: unaDireccion
	^ (posicion = posicionAcomparar) and: [apuntandoHacia = unaDireccion]!

!methodRemoval: MarsRover #modificarPosicionSobreXEn: stamp: 'BSN 10/23/2025 15:31:09'!
modificarPosicionSobreXEn: unaCantidad
	posicion := (posicion x + unaCantidad)@(posicion y)!

!methodRemoval: MarsRover #modificarPosicionSobreYEn: stamp: 'BSN 10/23/2025 15:31:09'!
modificarPosicionSobreYEn: unaCantidad
	posicion := (posicion x)@(posicion y + unaCantidad)!

----STARTUP---- (23 October 2025 15:31:39) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ejercicio-1-p3-mars-rover-este-grupo-es-un-objeto/MarsRover.st----!

!methodRemoval: MarsRover #estaEnPosicion: stamp: 'BSN 10/23/2025 15:32:30'!
estaEnPosicion: posicionAcomparar
	^ posicion = posicionAcomparar.!

!methodRemoval: MarsRover #rotarADerechaDesdeEsteYAvanzar stamp: 'BSN 10/23/2025 15:32:33'!
rotarADerechaDesdeEsteYAvanzar
	self rotarHacia: 'S'.
	self avanzar.!

!methodRemoval: MarsRover #rotarADerechaDesdeEsteYRetroceder stamp: 'BSN 10/23/2025 15:32:33'!
rotarADerechaDesdeEsteYRetroceder
	self rotarHacia: 'S'.
	self retroceder.!

!methodRemoval: MarsRover #rotarADerechaDesdeNorteYAvanzar stamp: 'BSN 10/23/2025 15:32:33'!
rotarADerechaDesdeNorteYAvanzar
	self rotarHacia: 'E'.
	self avanzar.!

!methodRemoval: MarsRover #rotarADerechaDesdeNorteYRetroceder stamp: 'BSN 10/23/2025 15:32:33'!
rotarADerechaDesdeNorteYRetroceder
	self rotarHacia: 'E'.
	self retroceder.!

!methodRemoval: MarsRover #rotarADerechaDesdeOesteYAvanzar stamp: 'BSN 10/23/2025 15:32:33'!
rotarADerechaDesdeOesteYAvanzar
	self rotarHacia: 'N'.
	self avanzar !

!methodRemoval: MarsRover #rotarADerechaDesdeOesteYRetroceder stamp: 'BSN 10/23/2025 15:32:33'!
rotarADerechaDesdeOesteYRetroceder
	self rotarHacia: 'N'.
	self retroceder.!

!methodRemoval: MarsRover #rotarADerechaDesdeSurYAvanzar stamp: 'BSN 10/23/2025 15:32:33'!
rotarADerechaDesdeSurYAvanzar
	self rotarHacia: 'O'.
	self avanzar.!

!methodRemoval: MarsRover #rotarADerechaDesdeSurYRetroceder stamp: 'BSN 10/23/2025 15:32:33'!
rotarADerechaDesdeSurYRetroceder
	self rotarHacia: 'O'.
	self retroceder. !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeEsteYAvanzar stamp: 'BSN 10/23/2025 15:32:33'!
rotarAIzquierdaDesdeEsteYAvanzar
	self rotarHacia: 'N'.
	self avanzar. !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeEsteYRetroceder stamp: 'BSN 10/23/2025 15:32:33'!
rotarAIzquierdaDesdeEsteYRetroceder
	self rotarHacia: 'N'.
	self retroceder !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeNorteYAvanzar stamp: 'BSN 10/23/2025 15:32:33'!
rotarAIzquierdaDesdeNorteYAvanzar
	self rotarHacia: 'O'.
	self avanzar.  !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeNorteYRetroceder stamp: 'BSN 10/23/2025 15:32:33'!
rotarAIzquierdaDesdeNorteYRetroceder
	self rotarHacia: 'O'.
	self retroceder .   !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeOesteYAvanzar stamp: 'BSN 10/23/2025 15:32:33'!
rotarAIzquierdaDesdeOesteYAvanzar
	self rotarHacia: 'S'.
	self avanzar.   !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeOesteYRetroceder stamp: 'BSN 10/23/2025 15:32:33'!
rotarAIzquierdaDesdeOesteYRetroceder
	self rotarHacia: 'S'.
	self retroceder .  !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeSurYAvanzar stamp: 'BSN 10/23/2025 15:32:33'!
rotarAIzquierdaDesdeSurYAvanzar
	self rotarHacia: 'E'.
	self avanzar.  !

!methodRemoval: MarsRover #rotarAIzquierdaDesdeSurYRetroceder stamp: 'BSN 10/23/2025 15:32:33'!
rotarAIzquierdaDesdeSurYRetroceder
	self rotarHacia: 'E'.
	self retroceder.  !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:32:51' prior: 50596302!
test04RoverRota90GradosAIzquierdaSinMoverseDespues
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'I'.
	self assert: (marsRover isAt: 0@0 heading: 'N').! !

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:33:09'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 15:33:09'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 15:33:09'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 15:33:09'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 15:33:09'!
FAILURE!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:33:09'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:33:09'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 15:33:09'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:33:09'!
ERROR!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:33:09'!
ERROR!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:33:22' prior: 50596314!
test05RoverRota90GradosADerechaSinMoverse
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'r'.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:33:32' prior: 50596326!
test06RoverRota90GradosAIzquierdaYAvanza
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'If'.
	self assert: (marsRover isAt: 1@1 heading: 'N').! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:33:45' prior: 50596338!
test07RoverRota90GradosADerechaYAvanza
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'rf'.
	self assert: (marsRover isAt: 1@-1 heading: 'S').! !

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 15:33:54'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 15:33:54'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 15:33:54'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 15:33:54'!
FAILURE!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:33:54'!
FAILURE!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:33:54'!
FAILURE!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 15:33:54'!
FAILURE!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:33:54'!
ERROR!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:33:54'!
ERROR!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 15:33:59'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 15:34:01'!
PASSED!
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 15:35:12' prior: 50596229!
process: StringDeComandos
	
	StringDeComandos = 'f' ifTrue: [self avanzar].
	StringDeComandos = 'b' ifTrue: [self retroceder].
	StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
	
	
	
	! !

!methodRemoval: MarsRover #rotarHacia: stamp: 'BSN 10/23/2025 15:35:20'!
rotarHacia: unSentido
	apuntandoHacia := unSentido.!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 15:35:34'!
girarIzquierda
	! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 15:36:09' prior: 50596511!
girarIzquierda
	apuntandoHacia := 'N'! !

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 15:36:13'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 15:36:15'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 15:36:17'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 15:36:19'!
PASSED!
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 15:37:41' prior: 50596498!
process: StringDeComandos
	
	StringDeComandos = 'f' ifTrue: [self avanzar].
	StringDeComandos = 'b' ifTrue: [self retroceder].
	StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
	StringDeComandos  = 'r' ifTrue: [self girarDerecha].	
	
	
	! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 15:38:08'!
girarDerecha
	apuntandoHacia := 'S'! !

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 15:38:57'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 15:38:59'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:39:00'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:39:02'!
FAILURE!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:46:45'!
PASSED!
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 15:49:25' prior: 50596519!
process: StringDeComandos
	
	StringDeComandos = 'f' ifTrue: [self avanzar].
	StringDeComandos = 'b' ifTrue: [self retroceder].
	StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
	StringDeComandos  = 'r' ifTrue: [self girarDerecha].	
	StringDeComandos  = 'If' ifTrue: [self girarIzquierda. self avanzar].		
	
	! !

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:49:28'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:49:30'!
FAILURE!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 15:49:59' prior: 50596199!
avanzar
	apuntandoHacia = 'N' ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia = 'O' ifTrue:  [self modificarPosicionSobreXEn: -1].
	apuntandoHacia  = 'S' ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia  = 'E' ifTrue: [self modificarPosicionSobreXEn: 1].
! !

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:50:54'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:50:56'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:51:56' prior: 50596477!
test06RoverRota90GradosAIzquierdaYAvanza
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'If'.
	self assert: (marsRover isAt: 0@1 heading: 'N').! !

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:51:58'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 15:51:58'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 15:51:58'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 15:51:58'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 15:51:58'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:51:58'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:51:58'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 15:51:58'!
FAILURE!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:51:58'!
ERROR!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:51:58'!
ERROR!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:52:01'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:53:12' prior: 50596488!
test07RoverRota90GradosADerechaYAvanza
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'rf'.
	self assert: (marsRover isAt: 0@-1 heading: 'S').! !

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 15:53:12'!
FAILURE!
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 15:53:36' prior: 50596534!
process: StringDeComandos
	
	StringDeComandos = 'f' ifTrue: [self avanzar].
	StringDeComandos = 'b' ifTrue: [self retroceder].
	StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
	StringDeComandos  = 'r' ifTrue: [self girarDerecha].	
	StringDeComandos  = 'If' ifTrue: [self girarIzquierda. self avanzar].		
	StringDeComandos  = 'rf' ifTrue: [self girarDerecha. self avanzar].		
		! !

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:53:52'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 15:53:52'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 15:53:52'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 15:53:52'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 15:53:52'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:53:52'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:53:52'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 15:53:52'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:53:52'!
ERROR!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:53:52'!
ERROR!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:53:56'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 15:53:59'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:54:47' prior: 50596350!
test08RoverRota90GradosAIzquierdayRetrocede
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'rf'.
	self assert: (marsRover isAt: 0@-1 heading: 'N').! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:55:03' prior: 50596596!
test08RoverRota90GradosAIzquierdayRetrocede
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ib'.
	self assert: (marsRover isAt: 0@-1 heading: 'N').! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:55:20' prior: 50596355!
test09RoverRota90GradosADerechaYRetrocede
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'rf'.
	self assert: (marsRover isAt: 0@1 heading: 'S').! !
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 15:55:50' prior: 50596580!
process: StringDeComandos
	
	StringDeComandos = 'f' ifTrue: [self avanzar].
	StringDeComandos = 'b' ifTrue: [self retroceder].
	StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
	StringDeComandos  = 'r' ifTrue: [self girarDerecha].	
	StringDeComandos  = 'If' ifTrue: [self girarIzquierda. self avanzar].		
	StringDeComandos  = 'rf' ifTrue: [self girarDerecha. self avanzar].	
	StringDeComandos  = 'Ib' ifTrue: [self girarIzquierda. self retroceder].		
	StringDeComandos  = 'rb' ifTrue: [self girarDerecha. self retroceder].	
		! !

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 15:55:56'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:55:58'!
FAILURE!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:56:02'!
FAILURE!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 15:56:20' prior: 50596212!
retroceder
	apuntandoHacia = 'N' ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia = 'O' ifTrue:  [self modificarPosicionSobreXEn: 1].
	apuntandoHacia  = 'S' ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia  = 'E' ifTrue: [self modificarPosicionSobreXEn: -1].
! !

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:56:31'!
FAILURE!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:56:35'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:56:40'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:56:48' prior: 50596618!
test09RoverRota90GradosADerechaYRetrocede
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'rb'.
	self assert: (marsRover isAt: 0@1 heading: 'S').! !

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:56:49'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:56:51'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 15:56:54'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 15:57:57'!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:00:42' prior: 50596530!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [apuntandoHacia := 'E'].
	apuntandoHacia = 'O' ifTrue: [apuntandoHacia := 'N'].
	apuntandoHacia = 'S' ifTrue: [apuntandoHacia := 'O'].
	apuntandoHacia = 'E' ifTrue: [apuntandoHacia := 'S'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:01:16' prior: 50596515!
girarIzquierda
	apuntandoHacia = 'N' ifTrue: [apuntandoHacia := 'O'].
	apuntandoHacia = 'O' ifTrue: [apuntandoHacia := 'S'].
	apuntandoHacia = 'S' ifTrue: [apuntandoHacia := 'E'].
	apuntandoHacia = 'E' ifTrue: [apuntandoHacia := 'N'].! !
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 16:01:43' prior: 50596629!
process: StringDeComandos
	
	StringDeComandos = 'f' ifTrue: [self avanzar].
	StringDeComandos = 'b' ifTrue: [self retroceder].
	StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
	StringDeComandos  = 'r' ifTrue: [self girarDerecha].	
	StringDeComandos  = 'If' ifTrue: [self girarIzquierda. self avanzar].		
	StringDeComandos  = 'rf' ifTrue: [self girarDerecha. self avanzar].	
	StringDeComandos  = 'Ib' ifTrue: [self girarIzquierda. self retroceder].		
	StringDeComandos  = 'rb' ifTrue: [self girarDerecha. self retroceder].	
	StringDeComandos  = 'Ir' ifTrue: [self girarIzquierda. self girarDerecha ].			! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:01:50'!
FAILURE!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:01:58'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:02:01'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:02:03'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:02:05'!
FAILURE!
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 16:03:06' prior: 50596706!
process: StringDeComandos
	
	StringDeComandos = 'f' ifTrue: [self avanzar].
	StringDeComandos = 'b' ifTrue: [self retroceder].
	StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
	StringDeComandos  = 'r' ifTrue: [self girarDerecha].	
	StringDeComandos  = 'If' ifTrue: [self girarIzquierda. self avanzar].		
	StringDeComandos  = 'rf' ifTrue: [self girarDerecha. self avanzar].	
	StringDeComandos  = 'Ib' ifTrue: [self girarIzquierda. self retroceder].		
	StringDeComandos  = 'rb' ifTrue: [self girarDerecha. self retroceder].	
	StringDeComandos  = 'Ir' ifTrue: [self girarIzquierda. self girarDerecha].			! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:03:11'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:03:14'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:03:32'!
FAILURE!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:04:44'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:04:45'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:04:45'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:05:00' prior: 50596673!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:05:00'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:05:03' prior: 50596751!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:05:08' prior: 50596763!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'N').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:05:10'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:05:19' prior: 50596775!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'O').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:05:19'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:05:24' prior: 50596787!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:06:55' prior: 50596695!
girarIzquierda
	apuntandoHacia = 'N' ifTrue: [apuntandoHacia := 'O'].
	apuntandoHacia = 'O' ifTrue: [apuntandoHacia := 'S'].
	apuntandoHacia = 'S' ifTrue: [apuntandoHacia := 'E'].
	apuntandoHacia = 'E' ifTrue: [apuntandoHacia := 'N'].! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:07:35'!
test11RoverAvanzaDosVeces
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:07:39' prior: 50596821!
test11RoverAvanzaDosVeces
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'ff'.
	self assert: (marsRover isAt: 2@0 heading: 'E').! !
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 16:08:08' prior: 50596728!
process: StringDeComandos
	
	StringDeComandos = 'f' ifTrue: [self avanzar].
	StringDeComandos = 'b' ifTrue: [self retroceder].
	StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
	StringDeComandos  = 'r' ifTrue: [self girarDerecha].	
	StringDeComandos  = 'If' ifTrue: [self girarIzquierda. self avanzar].		
	StringDeComandos  = 'rf' ifTrue: [self girarDerecha. self avanzar].	
	StringDeComandos  = 'Ib' ifTrue: [self girarIzquierda. self retroceder].		
	StringDeComandos  = 'rb' ifTrue: [self girarDerecha. self retroceder].	
	StringDeComandos  = 'Ir' ifTrue: [self girarIzquierda. self girarDerecha].		
	StringDeComandos  = 'ff' ifTrue: [self avanzar. self avanzar].		! !

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 16:08:13'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:08:15'!
FAILURE!
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 16:08:41' prior: 50596842!
process: StringDeComandos
	
	StringDeComandos = 'f' ifTrue: [self avanzar].
	StringDeComandos = 'b' ifTrue: [self retroceder].
	StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
	StringDeComandos  = 'r' ifTrue: [self girarDerecha].	
	StringDeComandos  = 'If' ifTrue: [self girarIzquierda. self avanzar].		
	StringDeComandos  = 'rf' ifTrue: [self girarDerecha. self avanzar].	
	StringDeComandos  = 'Ib' ifTrue: [self girarIzquierda. self retroceder].		
	StringDeComandos  = 'rb' ifTrue: [self girarDerecha. self retroceder].	
	StringDeComandos  = 'Ir' ifTrue: [self girarIzquierda. self girarIzquierda. self girarIzquierda. self girarIzquierda].		
	StringDeComandos  = 'ff' ifTrue: [self avanzar. self avanzar].		! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:08:45'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:08:52' prior: 50596799!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:08:54'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:09:00' prior: 50596892!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'N').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 16:09:02'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 16:09:04'!
PASSED!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:15:20' prior: 50596810!
girarIzquierda
	|nuevaDireccion| 
	apuntandoHacia = 'N' ifTrue: [apuntandoHacia := 'O'].
	apuntandoHacia = 'O' ifTrue: [apuntandoHacia := 'S'].
	apuntandoHacia = 'S' ifTrue: [apuntandoHacia := 'E'].
	apuntandoHacia = 'E' ifTrue: [apuntandoHacia := 'N'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:16:15' prior: 50596915!
girarIzquierda
	|nuevaDireccion| 
	apuntandoHacia = 'N' ifTrue: [nuevaDireccion := 'O'].
	apuntandoHacia = 'O' ifTrue: [nuevaDireccion := 'S'].
	apuntandoHacia = 'S' ifTrue: [nuevaDireccion := 'E'].
	apuntandoHacia = 'E' ifTrue: [nuevaDireccion := 'N'].
	apuntandoHacia := nuevaDireccion ! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:16:22'!
FAILURE!

[1,2,3] do: [:i | i+1]!

#(1,2,3) do: [:i | i+1]!

{1,2,3} do: [:i | i+1]!

{1 . 2 . 3} do: [:i | i+1]!
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 16:19:10' prior: 50596866!
process: StringDeComandos
	StringDeComandos do: [:comando |
			StringDeComandos = 'f' ifTrue: [self avanzar].
			StringDeComandos = 'b' ifTrue: [self retroceder].
			StringDeComandos  = 'I' ifTrue: [self girarIzquierda].
			StringDeComandos  = 'r' ifTrue: [self girarDerecha].
		]	! !

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:19:12'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:19:14'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:19:15'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:19:17'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:19:17'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:19:17'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:19:17'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 16:19:17'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 16:19:17'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:19:17'!
FAILURE!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:19:17'!
FAILURE!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 16:19:17'!
FAILURE!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:19:17'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:19:17'!
FAILURE!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 16:19:17'!
FAILURE!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:19:23'!
FAILURE!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:19:26'!
FAILURE!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:20:17' prior: 50596926!
girarIzquierda
	 
	apuntandoHacia = 'N' ifTrue: [apuntandoHacia := 'O'].
	apuntandoHacia = 'O' ifTrue: [apuntandoHacia := 'S'].
	apuntandoHacia = 'S' ifTrue: [apuntandoHacia := 'E'].
	apuntandoHacia = 'E' ifTrue: [apuntandoHacia := 'N'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:20:23' prior: 50596953!
girarIzquierda

	apuntandoHacia = 'N' ifTrue: [apuntandoHacia := 'O'].
	apuntandoHacia = 'O' ifTrue: [apuntandoHacia := 'S'].
	apuntandoHacia = 'S' ifTrue: [apuntandoHacia := 'E'].
	apuntandoHacia = 'E' ifTrue: [apuntandoHacia := 'N'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:20:24' prior: 50596964!
girarIzquierda
	apuntandoHacia = 'N' ifTrue: [apuntandoHacia := 'O'].
	apuntandoHacia = 'O' ifTrue: [apuntandoHacia := 'S'].
	apuntandoHacia = 'S' ifTrue: [apuntandoHacia := 'E'].
	apuntandoHacia = 'E' ifTrue: [apuntandoHacia := 'N'].! !
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 16:20:49' prior: 50596941!
process: StringDeComandos
	StringDeComandos do: [:comando |
			comando = 'f' ifTrue: [self avanzar].
			comando = 'b' ifTrue: [self retroceder].
			comando  = 'I' ifTrue: [self girarIzquierda].
			comando  = 'r' ifTrue: [self girarDerecha].
		]	! !

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:20:53'!
FAILURE!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:20:57'!
FAILURE!
!MarsRover methodsFor: 'control' stamp: 'BSN 10/23/2025 16:21:42' prior: 50596986!
process: StringDeComandos
	StringDeComandos do: [:comando |
			comando = $f ifTrue: [self avanzar].
			comando = $b ifTrue: [self retroceder].
			comando  = $I ifTrue: [self girarIzquierda].
			comando  = $r ifTrue: [self girarDerecha].
		]	! !

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:21:45'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:21:47'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:21:48'!
FAILURE!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 16:21:48'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:21:57'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:22:03' prior: 50596904!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:22:04'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:22:10'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:22:27' prior: 50597008!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 16:22:28'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:22:34' prior: 50597020!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:38:21'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:38:25'!
FAILURE!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:44:50' prior: 50596684!
girarDerecha
	apuntandoHacia = #N ifTrue: [apuntandoHacia := #E].
	apuntandoHacia = #O ifTrue: [apuntandoHacia := #N].
	apuntandoHacia = #S ifTrue: [apuntandoHacia := #O].
	apuntandoHacia = #E ifTrue: [apuntandoHacia := #S].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:45:30' prior: 50596975!
girarIzquierda
	apuntandoHacia = #N ifTrue: [apuntandoHacia := #O].
	apuntandoHacia = #O ifTrue: [apuntandoHacia := #S].
	apuntandoHacia = #S ifTrue: [apuntandoHacia := #E].
	apuntandoHacia = #E ifTrue: [apuntandoHacia := #N].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:45:44' prior: 50596649!
retroceder
	apuntandoHacia = #N ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia = #O ifTrue:  [self modificarPosicionSobreXEn: 1].
	apuntandoHacia  = #S ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia  = #E ifTrue: [self modificarPosicionSobreXEn: -1].
! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:45:53' prior: 50596547!
avanzar
	apuntandoHacia = #N ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia = #O ifTrue:  [self modificarPosicionSobreXEn: -1].
	apuntandoHacia  = #S ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia  = #E ifTrue: [self modificarPosicionSobreXEn: 1].
! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:46:09' prior: 50597032!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #E.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: #E).! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:46:10'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:46:13'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:46:22'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:46:31' prior: 50597088!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: $E.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: $E).! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:46:59' prior: 50597053!
girarIzquierda
	apuntandoHacia = $N ifTrue: [apuntandoHacia := $O].
	apuntandoHacia = $O ifTrue: [apuntandoHacia := $S].
	apuntandoHacia = $S ifTrue: [apuntandoHacia := $E].
	apuntandoHacia = $E ifTrue: [apuntandoHacia := $N].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:47:09' prior: 50597043!
girarDerecha
	apuntandoHacia = $N ifTrue: [apuntandoHacia := $E].
	apuntandoHacia = $O ifTrue: [apuntandoHacia := $N].
	apuntandoHacia = $S ifTrue: [apuntandoHacia := $O].
	apuntandoHacia = $E ifTrue: [apuntandoHacia := $S].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:47:25' prior: 50597064!
retroceder
	apuntandoHacia = $N ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia = $O ifTrue:  [self modificarPosicionSobreXEn: 1].
	apuntandoHacia  = $S ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia  = $E ifTrue: [self modificarPosicionSobreXEn: -1].
! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:47:34' prior: 50597076!
avanzar
	apuntandoHacia = $N ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia = $O ifTrue:  [self modificarPosicionSobreXEn: -1].
	apuntandoHacia  = $S ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia  = $E ifTrue: [self modificarPosicionSobreXEn: 1].
! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:47:58'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:48:11'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:48:30' prior: 50596570!
test07RoverRota90GradosADerechaYAvanza
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: $E.
	marsRover process: 'rf'.
	self assert: (marsRover isAt: 0@-1 heading: $S).! !

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:48:32'!
PASSED!
!MarsRover methodsFor: 'posicion' stamp: 'BSN 10/23/2025 16:49:22'!
modificarDireccion: unaDireccion
	apuntandoHacia := unaDireccion .! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:51:14' prior: 50597122!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [ 'E'].
	apuntandoHacia = 'O' ifTrue: [apuntandoHacia := 'N'].
	apuntandoHacia = 'S' ifTrue: [apuntandoHacia := 'O'].
	apuntandoHacia = 'E' ifTrue: [apuntandoHacia := 'S'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:51:58' prior: 50597172!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [ self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:51:59' prior: 50597182!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:52:38' prior: 50597111!
girarIzquierda
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion:  'O'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion:  'S'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion:  'E'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion:  'N'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:52:46' prior: 50597132!
retroceder
	apuntandoHacia = 'N' ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia = 'O' ifTrue:  [self modificarPosicionSobreXEn: 1].
	apuntandoHacia  = 'S' ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia  = 'E' ifTrue: [self modificarPosicionSobreXEn: -1].
! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:53:00' prior: 50597144!
avanzar
	apuntandoHacia = 'N' ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia = 'O' ifTrue:  [self modificarPosicionSobreXEn: -1].
	apuntandoHacia  = 'S' ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia  = 'E' ifTrue: [self modificarPosicionSobreXEn: 1].
! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:53:06'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:53:13' prior: 50597100!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:53:15'!
FAILURE!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 16:53:18'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:53:21'!
FAILURE!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:53:21'!
FAILURE!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 16:53:21'!
PASSED!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 16:53:26'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:53:28'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 16:53:29'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:53:31'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:53:49' prior: 50597156!
test07RoverRota90GradosADerechaYAvanza
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'rf'.
	self assert: (marsRover isAt: 0@-1 heading: 'S').! !

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 16:53:57'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:53:59'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 16:54:01'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:54:02'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:54:19'!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'ff'.
	self assert: (marsRover isAt: 2@0 heading: 'E').! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:54:28' prior: 50597264!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrfff'.
	self assert: (marsRover isAt: 3@-3 heading: 'E').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 16:54:30'!
FAILURE!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 16:54:32'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:54:44' prior: 50597274!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fff'.
	self assert: (marsRover isAt: 3@0 heading: 'E').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 16:54:46'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:54:51' prior: 50597285!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffr'.
	self assert: (marsRover isAt: 3@0 heading: 'S').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 16:54:53'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:54:59' prior: 50597295!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrfff'.
	self assert: (marsRover isAt: 3@-3 heading: 'S').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 16:55:00'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:55:04' prior: 50597305!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrfffI'.
	self assert: (marsRover isAt: 3@-3 heading: 'S').! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:55:08' prior: 50597316!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrfffI'.
	self assert: (marsRover isAt: 3@-3 heading: 'E').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 16:55:10'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:55:25' prior: 50597327!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrIf'.
	self assert: (marsRover isAt: 4@0 heading: 'E').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 16:55:26'!
FAILURE!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 16:55:29'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:55:53' prior: 50597338!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrbbb'.
	self assert: (marsRover isAt: 3@3 heading: 's').! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:55:56' prior: 50597348!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrbbb'.
	self assert: (marsRover isAt: 3@3 heading: 'S').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 16:55:57'!
PASSED!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:56:39' prior: 50597206!
girarIzquierda
	(apuntandoHacia = 'N') ifTrue: [self modificarDireccion:  'O'].
	(apuntandoHacia = 'O') ifTrue: [self modificarDireccion:  'S'].
	(apuntandoHacia = 'S') ifTrue: [self modificarDireccion:  'E'].
	(apuntandoHacia = 'E') ifTrue: [self modificarDireccion:  'N'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:56:51' prior: 50597194!
girarDerecha
	(apuntandoHacia = 'N') ifTrue: [self modificarDireccion: 'E'].
	(apuntandoHacia = 'O') ifTrue: [self modificarDireccion: 'N'].
	(apuntandoHacia = 'S') ifTrue: [self modificarDireccion: 'O'].
	(apuntandoHacia = 'E') ifTrue: [self modificarDireccion: 'S'].! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:56:58'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:57:03' prior: 50597242!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:57:05'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 16:57:07' prior: 50597392!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !
!MarsRover methodsFor: 'posicion' stamp: 'BSN 10/23/2025 16:57:26' prior: 50597166!
modificarDireccion: unaDireccion
	apuntandoHacia := unaDireccion! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 16:57:29'!
FAILURE!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 16:59:28' prior: 50597368!
girarIzquierda
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion:  'O'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion:  'S'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion:  'E'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion:  'N'].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:01:06' prior: 50597380!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S'].! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:01:11'!
FAILURE!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 17:01:14'!
PASSED!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 17:01:15'!
PASSED!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 17:01:17'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:04:10' prior: 50597404!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarIzquierda.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:04:12'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:04:16' prior: 50597444!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarIzquierda.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:04:17'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:04:31' prior: 50597456!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarDerecha.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'O').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:04:34'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:04:36'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:04:57' prior: 50597468!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarDerecha.
	marsRover girarDerecha.
	marsRover girarDerecha.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:04:58'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:05:18' prior: 50597480!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarDerecha.
	marsRover girarDerecha.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:05:19'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:05:27' prior: 50597494!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarDerecha.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'O').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:05:29'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:05:40' prior: 50597507!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:05:42'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:05:53' prior: 50597519!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarDerecha.
	marsRover girarDerecha.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'N').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:05:55'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:06:07' prior: 50597531!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarDerecha.
	marsRover girarDerecha.
	marsRover girarDerecha.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:06:08'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:06:17' prior: 50597544!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover girarDerecha.
	marsRover girarDerecha.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'N').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:06:19'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:07:02' prior: 50597558!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'N'.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:07:03'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:07:13' prior: 50597571!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'N'.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:07:14'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:07:58' prior: 50597583!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'N'.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:07:59'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:08:03' prior: 50597595!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'N'.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:08:04'!
PASSED!

'N' = 'N'!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:11:17' prior: 50597432!
girarDerecha
	apuntandoHacia := 'E'
"
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S']."! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:11:22'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:11:27' prior: 50597607!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'N'.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:11:28'!
PASSED!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:11:51' prior: 50597619!
girarDerecha
	apuntandoHacia = 'N' ifTrue:  [apuntandoHacia := 'E']
"
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S']."! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:11:56'!
PASSED!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:12:21' prior: 50597643!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	"
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S']."! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:12:28'!
PASSED!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:12:44' prior: 50597656!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S'].! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:12:49'!
FAILURE!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:13:03' prior: 50597668!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	"
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S']."! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:13:06'!
PASSED!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:13:23' prior: 50597680!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	"
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S']."! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:13:26'!
PASSED!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:13:36' prior: 50597692!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S'].! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:13:45'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:14:07' prior: 50597632!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #N.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: #E).! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:14:42' prior: 50597704!
girarDerecha
	apuntandoHacia = #N ifTrue: [self modificarDireccion: #E].
	apuntandoHacia = #O ifTrue: [self modificarDireccion: #N].
	apuntandoHacia = #S ifTrue: [self modificarDireccion: #O].
	apuntandoHacia = #E ifTrue: [self modificarDireccion: #S].! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:14:46'!
FAILURE!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:14:58' prior: 50597727!
girarDerecha
	apuntandoHacia = #N ifTrue: [self modificarDireccion: #E].
	apuntandoHacia = #O ifTrue: [self modificarDireccion: #N].
	apuntandoHacia = #S ifTrue: [self modificarDireccion: #O].! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:15:07'!
PASSED!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:15:39' prior: 50597738!
girarDerecha
	apuntandoHacia = #N ifTrue: [self modificarDireccion: #E].
	apuntandoHacia = #O ifTrue: [self modificarDireccion: #N].
	apuntandoHacia = #S ifTrue: [self modificarDireccion: #O].
	"apuntandoHacia = #E ifTrue: [self modificarDireccion: #S]."! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:15:58' prior: 50597716!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #O.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: #N).! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:16:00'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:16:08' prior: 50597759!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #S.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: #O).! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:16:10'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:16:29' prior: 50597770!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #N.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: #E).! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:16:31'!
PASSED!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:16:39' prior: 50597747!
girarDerecha
	apuntandoHacia = #N ifTrue: [self modificarDireccion: #E].
	apuntandoHacia = #O ifTrue: [self modificarDireccion: #N].
	apuntandoHacia = #S ifTrue: [self modificarDireccion: #O].
	apuntandoHacia = #E ifTrue: [self modificarDireccion: #S].! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:16:42'!
FAILURE!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:16:59' prior: 50597792!
girarDerecha
	apuntandoHacia = #N ifTrue: [self modificarDireccion: #E].
	apuntandoHacia = #O ifTrue: [self modificarDireccion: #N].
	"apuntandoHacia = #S ifTrue: [self modificarDireccion: #O]."
	apuntandoHacia = #E ifTrue: [self modificarDireccion: #S].! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:17:03'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:17:07'!
FAILURE!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/23/2025 17:17:30' prior: 50597803!
girarDerecha
	apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E'].
	apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'].
	apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'].
	apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S'].! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/23/2025 17:17:38' prior: 50597781!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'N'.
	marsRover girarDerecha.
	self assert: (marsRover isAt: 0@0 heading: 'E').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:17:40'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:17:43'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:17:46'!
FAILURE!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 17:17:48'!
PASSED!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 17:17:49'!
PASSED!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/23/2025 17:17:51'!
FAILURE!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVeces stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'BSN 10/23/2025 17:17:51'!
PASSED!

----STARTUP---- (23 October 2025 17:19:32) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ejercicio-1-p3-mars-rover-este-grupo-es-un-objeto/MarsRover.st----!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'bsn 10/23/2025 17:20:11'!
FAILURE!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'bsn 10/23/2025 17:20:14'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'bsn 10/23/2025 17:20:16'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:32:00' prior: 50596322!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrrfffibbrrrff'.
	self assert: (marsRover isAt: 2@2 heading: 'S').! !
!MarsRover methodsFor: 'movimientos base' stamp: 'bsn 10/23/2025 17:32:19' prior: 50596131!
girarDerecha
    apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'E']
    ifFalse: [
        apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'N'] ifFalse: [
            apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'O'] ifFalse: [
            apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'S']]]].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'bsn 10/23/2025 17:32:27' prior: 50596142!
girarIzquierda
    apuntandoHacia = 'N' ifTrue: [self modificarDireccion: 'O']
    ifFalse: [
        apuntandoHacia = 'O' ifTrue: [self modificarDireccion: 'S'] ifFalse: [
            apuntandoHacia = 'S' ifTrue: [self modificarDireccion: 'E'] ifFalse: [
            apuntandoHacia = 'E' ifTrue: [self modificarDireccion: 'N']]]].! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:32:33'!
FAILURE!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:32:36'!
FAILURE!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'bsn 10/23/2025 17:32:39'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:32:57' prior: 50596301!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'N'.
	marsRover process: 'Ir'.
	self assert: (marsRover isAt: 0@0 heading: 'N').! !

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'bsn 10/23/2025 17:33:00'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:33:10' prior: 50596453!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrrfffibbrrrff'.
	self assert: (marsRover isAt: 2@2 heading: 'E').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:33:11'!
FAILURE!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:33:14'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:33:28' prior: 50596504!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrrfff'.
	self assert: (marsRover isAt: 0@0 heading: 'O').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:33:31'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:34:01' prior: 50596515!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrrfffibb'.
	self assert: (marsRover isAt: 0@2 heading: 'O').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:34:03'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:34:15' prior: 50596526!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrrfffibb'.
	self assert: (marsRover isAt: 0@2 heading: 'S').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:34:16'!
FAILURE!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:34:19'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:34:24' prior: 50596537!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrrfffi'.
	self assert: (marsRover isAt: 0@0 heading: 'S').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:34:25'!
FAILURE!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:34:29'!
FAILURE!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:34:51' prior: 50596548!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrrfff'.
	self assert: (marsRover isAt: 0@0 heading: 'O').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:34:52'!
PASSED!

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:35:12'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:35:24' prior: 50596559!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrrfffIbb'.
	self assert: (marsRover isAt: 0@2 heading: 'S').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:35:25'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'bsn 10/23/2025 17:36:39' prior: 50596570!
test12ComandoLargo
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: 'E'.
	marsRover process: 'fffrrfffIbbrrrff'.
	self assert: (marsRover isAt: 2@2 heading: 'E').! !

!testRun: #MarsRoverTest #test12ComandoLargo stamp: 'bsn 10/23/2025 17:36:41'!
PASSED!

----STARTUP---- (24 October 2025 12:29:44) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ejercicio-1-p3-mars-rover-este-grupo-es-un-objeto/MarsRover.st----!
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/24/2025 12:32:41' prior: 50596155!
retroceder
	apuntandoHacia = #North ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia = #West ifTrue:  [self modificarPosicionSobreXEn: 1].
	apuntandoHacia  = #South ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia  = #East ifTrue: [self modificarPosicionSobreXEn: -1].
! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/24/2025 12:33:14' prior: 50596143!
girarIzquierda	
	apuntandoHacia = #North ifTrue: [self modificarDireccion: 'O']
	ifFalse: [
		apuntandoHacia = #West ifTrue: [self modificarDireccion: 'S'] ifFalse: [
			apuntandoHacia = #South ifTrue: [self modificarDireccion: 'E'] ifFalse: [
			apuntandoHacia = #East ifTrue: [self modificarDireccion: 'N']]]].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/24/2025 12:33:51' prior: 50596351!
girarIzquierda	
	apuntandoHacia = #North ifTrue: [self modificarDireccion: #West]
	ifFalse: [
		apuntandoHacia = #West ifTrue: [self modificarDireccion: #South] ifFalse: [
			apuntandoHacia = #South ifTrue: [self modificarDireccion: #East] ifFalse: [
			apuntandoHacia = #East ifTrue: [self modificarDireccion: #North]]]].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/24/2025 12:34:47' prior: 50596131!
girarDerecha
	apuntandoHacia = #North ifTrue: [self modificarDireccion: #East]
	ifFalse: [
		apuntandoHacia = #West ifTrue: [self modificarDireccion: #North] ifFalse: [
			apuntandoHacia = #South ifTrue: [self modificarDireccion: #West] ifFalse: [
			apuntandoHacia = #East ifTrue: [self modificarDireccion: #South]]]].! !
!MarsRover methodsFor: 'movimientos base' stamp: 'BSN 10/24/2025 12:35:12' prior: 50596119!
avanzar
	apuntandoHacia = #North ifTrue: [self modificarPosicionSobreYEn: 1].
	apuntandoHacia = #West ifTrue:  [self modificarPosicionSobreXEn: -1].
	apuntandoHacia  = #South ifTrue: [self modificarPosicionSobreYEn: -1].
	apuntandoHacia  = #East ifTrue: [self modificarPosicionSobreXEn: 1].
! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:35:24' prior: 50596208!
test01ComandoVacioRoverNoSeMueve
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: ''.
	self assert: (marsRover isAt: 0@0 heading: #East).! !

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/24/2025 12:35:26'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:35:36' prior: 50596218!
test02RoverSeMueveParaAdelante
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'f'.
	self assert: (marsRover isAt: 1@0 heading: #East).
	! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:35:45' prior: 50596228!
test03RoverSeMueveParaAtras
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'b'.
	self assert: (marsRover isAt: -1@0 heading: #East).
! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:35:56' prior: 50596238!
test04RoverRota90GradosAIzquierdaSinMoverseDespues
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'l'.
	self assert: (marsRover isAt: 0@0 heading: #North).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:36:08' prior: 50596249!
test05RoverRota90GradosADerechaSinMoverse
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'r'.
	self assert: (marsRover isAt: 0@0 heading: #South).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:36:18' prior: 50596259!
test06RoverRota90GradosAIzquierdaYAvanza
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'lf'.
	self assert: (marsRover isAt: 0@1 heading: #North).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:36:28' prior: 50596270!
test07RoverRota90GradosADerechaYAvanza
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'rf'.
	self assert: (marsRover isAt: 0@-1 heading: #South).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:36:37' prior: 50596280!
test08RoverRota90GradosAIzquierdayRetrocede
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'lb'.
	self assert: (marsRover isAt: 0@-1 heading: #Noth).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:36:49' prior: 50596291!
test09RoverRota90GradosADerechaYRetrocede
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'rb'.
	self assert: (marsRover isAt: 0@1 heading: #South).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:37:01' prior: 50596302!
test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #North.
	marsRover process: 'rl'.
	self assert: (marsRover isAt: 0@0 heading: #North).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:37:14' prior: 50596313!
test11RoverAvanzaDosVecesCorrectamente
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'ff'.
	self assert: (marsRover isAt: 2@0 heading: #East).! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:37:25' prior: 50596323!
test12RoverProcesaComandoLargoCorrectamente
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'fffrrffflbbrrrff'.
       self assert: (marsRover isAt: 2@2 heading: #East).! !

!testRun: #MarsRoverTest #test12RoverProcesaComandoLargoCorrectamente stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/24/2025 12:37:28'!
FAILURE!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVecesCorrectamente stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!

!testRun: #MarsRoverTest #test12RoverProcesaComandoLargoCorrectamente stamp: 'BSN 10/24/2025 12:37:28'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'BSN 10/24/2025 12:37:44' prior: 50596481!
test08RoverRota90GradosAIzquierdayRetrocede
	| marsRover startingPosition | 
	startingPosition := 0@0.
	marsRover := MarsRover at: startingPosition heading: #East.
	marsRover process: 'lb'.
	self assert: (marsRover isAt: 0@-1 heading: #North).! !

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/24/2025 12:37:45'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test01ComandoVacioRoverNoSeMueve stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test02RoverSeMueveParaAdelante stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test03RoverSeMueveParaAtras stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test04RoverRota90GradosAIzquierdaSinMoverseDespues stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test05RoverRota90GradosADerechaSinMoverse stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test06RoverRota90GradosAIzquierdaYAvanza stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test07RoverRota90GradosADerechaYAvanza stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test08RoverRota90GradosAIzquierdayRetrocede stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test09RoverRota90GradosADerechaYRetrocede stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test10RoverRota90GradosADerechaYAIzquierdaMantienePosicion stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test11RoverAvanzaDosVecesCorrectamente stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

!testRun: #MarsRoverTest #test12RoverProcesaComandoLargoCorrectamente stamp: 'BSN 10/24/2025 12:37:47'!
PASSED!

----STARTUP---- (31 October 2025 14:13:01) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ejercicio-2-p3-portfolio-1-este-grupo-es-un-objeto/Portfolio.st----!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'BSN 10/31/2025 14:19:11'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'BSN 10/31/2025 14:19:11'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'BSN 10/31/2025 14:19:11'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'BSN 10/31/2025 14:19:11'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'BSN 10/31/2025 14:19:11'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'BSN 10/31/2025 14:19:11'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'BSN 10/31/2025 14:19:11'!
PASSED!

!testRun: #FinancialAssetsTests #test01PortfolioNuevoEmpiezaSinCuentas stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test02PortfolioAgregaCorrectamenteUnaCuenta stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioAgregaCorrectamenteDosCuentas stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioSinCuentasDevuelveBalanceCero stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test05PortfolioConUnaCuentaDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test06PortfolioConDosCuentasDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test07PortfolioSinTrasaccionesDevuelveCollectionVacia stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test08PortfolioDevuelveUnaTransaccionDeUnaCuentaCorrectamente stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test09PortfolioDevuelveDosTransaccionesDeCuentasDistintas stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test10PortfolioSinTransaccionesNoRegistraTransacciones stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test11PortfolioRegistraUnaTransaccionCorrectamente stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test12PortfolioRegistraDosTransaccionesDeCuentasDistintasCorrectamente stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test13ReceptiveAccountNoPuedeTenerCuentasAdentro stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test14PortfolioNoPuedeTenerCuentasRepetidas stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test15PortfolioNoPuedeTenerPortfoliosRepetidos stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test16PortfolioNoPuedeRegistrarTransacciones stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test17PortfolioConUnPortfolioVacioAdentroDevuelveBalanceEnCero stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test18PortfolioConUnPortfolioNoVacioAdentroDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test19PortfolioConDosPortfoliosNoVaciosAdentroDevuelvenBalanceCorrecto stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test20PortfolioConUnPortfolioVacioAdentroDevuelveCollectionDeTransactionsVacia stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test21PortfolioConUnPortfolioNoVacioAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:19:14'!
FAILURE!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:19:14'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:19:48'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:19:50'!
PASSED!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 14:19:52'!
PASSED!

!testRun: #FinancialAssetsTests #test01PortfolioNuevoEmpiezaSinCuentas stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test02PortfolioAgregaCorrectamenteUnaCuenta stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioAgregaCorrectamenteDosCuentas stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioSinCuentasDevuelveBalanceCero stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test05PortfolioConUnaCuentaDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test06PortfolioConDosCuentasDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test07PortfolioSinTrasaccionesDevuelveCollectionVacia stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test08PortfolioDevuelveUnaTransaccionDeUnaCuentaCorrectamente stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test09PortfolioDevuelveDosTransaccionesDeCuentasDistintas stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test10PortfolioSinTransaccionesNoRegistraTransacciones stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test11PortfolioRegistraUnaTransaccionCorrectamente stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test12PortfolioRegistraDosTransaccionesDeCuentasDistintasCorrectamente stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test13ReceptiveAccountNoPuedeTenerCuentasAdentro stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test14PortfolioNoPuedeTenerCuentasRepetidas stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test15PortfolioNoPuedeTenerPortfoliosRepetidos stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test16PortfolioNoPuedeRegistrarTransacciones stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test17PortfolioConUnPortfolioVacioAdentroDevuelveBalanceEnCero stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test18PortfolioConUnPortfolioNoVacioAdentroDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test19PortfolioConDosPortfoliosNoVaciosAdentroDevuelvenBalanceCorrecto stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test20PortfolioConUnPortfolioVacioAdentroDevuelveCollectionDeTransactionsVacia stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test21PortfolioConUnPortfolioNoVacioAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:19:54'!
FAILURE!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:19:54'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:19:59'!
FAILURE!
!ReceptiveAccount methodsFor: 'testing' stamp: 'BSN 10/31/2025 14:39:12' prior: 50596413!
accountsSize
	^ 1.! !
!Portfolio methodsFor: 'control' stamp: 'BSN 10/31/2025 14:41:13' prior: 50596320!
accountsSize
	| size |
	size := 0.
	assets do: [:asset | size := size + asset accountsSize ].! !

{1. 2. 3.}!

#(1 2 3 4 5) anySatisfy: [:x | x > 3].!

true not!

#(1 2 3 4 5) anySatisfy: [:x | x > 3] not!

(#(1 2 3 4 5) anySatisfy: [:x | x > 3]) not!

true not not !

#() allSatisfy: []!
!Portfolio methodsFor: 'asserts' stamp: 'BSN 10/31/2025 14:48:07' prior: 50596284!
accountsIsEmpty
	^ assets allSatisfy: [:asset | asset accountsIsEmpty].! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'BSN 10/31/2025 14:48:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'BSN 10/31/2025 14:48:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'BSN 10/31/2025 14:48:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'BSN 10/31/2025 14:48:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'BSN 10/31/2025 14:48:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'BSN 10/31/2025 14:48:17'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'BSN 10/31/2025 14:48:17'!
PASSED!

!testRun: #FinancialAssetsTests #test01PortfolioNuevoEmpiezaSinCuentas stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test02PortfolioAgregaCorrectamenteUnaCuenta stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioAgregaCorrectamenteDosCuentas stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioSinCuentasDevuelveBalanceCero stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test05PortfolioConUnaCuentaDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test06PortfolioConDosCuentasDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test07PortfolioSinTrasaccionesDevuelveCollectionVacia stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test08PortfolioDevuelveUnaTransaccionDeUnaCuentaCorrectamente stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test09PortfolioDevuelveDosTransaccionesDeCuentasDistintas stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test10PortfolioSinTransaccionesNoRegistraTransacciones stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test11PortfolioRegistraUnaTransaccionCorrectamente stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test12PortfolioRegistraDosTransaccionesDeCuentasDistintasCorrectamente stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test13ReceptiveAccountNoPuedeTenerCuentasAdentro stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test14PortfolioNoPuedeTenerCuentasRepetidas stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test15PortfolioNoPuedeTenerPortfoliosRepetidos stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test16PortfolioNoPuedeRegistrarTransacciones stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test17PortfolioConUnPortfolioVacioAdentroDevuelveBalanceEnCero stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test18PortfolioConUnPortfolioNoVacioAdentroDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test19PortfolioConDosPortfoliosNoVaciosAdentroDevuelvenBalanceCorrecto stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test20PortfolioConUnPortfolioVacioAdentroDevuelveCollectionDeTransactionsVacia stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test21PortfolioConUnPortfolioNoVacioAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:48:19'!
FAILURE!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:48:19'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:48:23'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:53:42'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:53:47'!
FAILURE!
!Portfolio methodsFor: 'control' stamp: 'BSN 10/31/2025 14:59:02' prior: 50596332!
enumerateTransactions

	^ assets do: [:anAccount | transactions addAll: (anAccount transactions)]! !

!testRun: #FinancialAssetsTests #test01PortfolioNuevoEmpiezaSinCuentas stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test02PortfolioAgregaCorrectamenteUnaCuenta stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioAgregaCorrectamenteDosCuentas stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioSinCuentasDevuelveBalanceCero stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test05PortfolioConUnaCuentaDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test06PortfolioConDosCuentasDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test07PortfolioSinTrasaccionesDevuelveCollectionVacia stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test08PortfolioDevuelveUnaTransaccionDeUnaCuentaCorrectamente stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test09PortfolioDevuelveDosTransaccionesDeCuentasDistintas stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test10PortfolioSinTransaccionesNoRegistraTransacciones stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test11PortfolioRegistraUnaTransaccionCorrectamente stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test12PortfolioRegistraDosTransaccionesDeCuentasDistintasCorrectamente stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test13ReceptiveAccountNoPuedeTenerCuentasAdentro stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test14PortfolioNoPuedeTenerCuentasRepetidas stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test15PortfolioNoPuedeTenerPortfoliosRepetidos stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test16PortfolioNoPuedeRegistrarTransacciones stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test17PortfolioConUnPortfolioVacioAdentroDevuelveBalanceEnCero stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test18PortfolioConUnPortfolioNoVacioAdentroDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test19PortfolioConDosPortfoliosNoVaciosAdentroDevuelvenBalanceCorrecto stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test20PortfolioConUnPortfolioVacioAdentroDevuelveCollectionDeTransactionsVacia stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test21PortfolioConUnPortfolioNoVacioAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 14:59:05'!
FAILURE!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 14:59:05'!
PASSED!
!Portfolio methodsFor: 'control' stamp: 'BSN 10/31/2025 15:02:33' prior: 50596909!
enumerateTransactions
	assets do: [:anAccount | transactions addAll: (anAccount transactions)]! !

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:02:39'!
FAILURE!

!testRun: #FinancialAssetsTests #test01PortfolioNuevoEmpiezaSinCuentas stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test02PortfolioAgregaCorrectamenteUnaCuenta stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioAgregaCorrectamenteDosCuentas stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioSinCuentasDevuelveBalanceCero stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test05PortfolioConUnaCuentaDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test06PortfolioConDosCuentasDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test07PortfolioSinTrasaccionesDevuelveCollectionVacia stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test08PortfolioDevuelveUnaTransaccionDeUnaCuentaCorrectamente stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test09PortfolioDevuelveDosTransaccionesDeCuentasDistintas stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test10PortfolioSinTransaccionesNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test11PortfolioRegistraUnaTransaccionCorrectamente stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test12PortfolioRegistraDosTransaccionesDeCuentasDistintasCorrectamente stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test13ReceptiveAccountNoPuedeTenerCuentasAdentro stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test14PortfolioNoPuedeTenerCuentasRepetidas stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test15PortfolioNoPuedeTenerPortfoliosRepetidos stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test16PortfolioNoPuedeRegistrarTransacciones stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test17PortfolioConUnPortfolioVacioAdentroDevuelveBalanceEnCero stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test18PortfolioConUnPortfolioNoVacioAdentroDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test19PortfolioConDosPortfoliosNoVaciosAdentroDevuelvenBalanceCorrecto stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test20PortfolioConUnPortfolioVacioAdentroDevuelveCollectionDeTransactionsVacia stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test21PortfolioConUnPortfolioNoVacioAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:02:44'!
FAILURE!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:02:44'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:02:47'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:02:48'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:03:06'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:03:13'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:03:21'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:03:42'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:03:46'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:03:48'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:04:08'!
PASSED!

   portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Deposit register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.!

	cuenta1 transactions!

	cuenta2 transactions!

	portfolio transactions!
!FinancialAssetsTests methodsFor: 'tests' stamp: 'BSN 10/31/2025 15:06:06' prior: 50596725!
test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente
	| portfolio subPortfolio1 subPortfolio2 cuenta1 cuenta2 transaccion1 transaccion2 |
	portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Deposit register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.
	
	self assert: (portfolio transactions = ((cuenta2 transactions) addAll: cuenta1 transactions) )! !

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:06:08'!
FAILURE!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'BSN 10/31/2025 15:07:20' prior: 50596390!
transactions 

	^ transactions.! !

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:07:25'!
FAILURE!

!testRun: #FinancialAssetsTests #test01PortfolioNuevoEmpiezaSinCuentas stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test02PortfolioAgregaCorrectamenteUnaCuenta stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioAgregaCorrectamenteDosCuentas stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioSinCuentasDevuelveBalanceCero stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test05PortfolioConUnaCuentaDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test06PortfolioConDosCuentasDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test07PortfolioSinTrasaccionesDevuelveCollectionVacia stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test08PortfolioDevuelveUnaTransaccionDeUnaCuentaCorrectamente stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test09PortfolioDevuelveDosTransaccionesDeCuentasDistintas stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test10PortfolioSinTransaccionesNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test11PortfolioRegistraUnaTransaccionCorrectamente stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test12PortfolioRegistraDosTransaccionesDeCuentasDistintasCorrectamente stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test13ReceptiveAccountNoPuedeTenerCuentasAdentro stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test14PortfolioNoPuedeTenerCuentasRepetidas stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test15PortfolioNoPuedeTenerPortfoliosRepetidos stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test16PortfolioNoPuedeRegistrarTransacciones stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test17PortfolioConUnPortfolioVacioAdentroDevuelveBalanceEnCero stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test18PortfolioConUnPortfolioNoVacioAdentroDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test19PortfolioConDosPortfoliosNoVaciosAdentroDevuelvenBalanceCorrecto stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test20PortfolioConUnPortfolioVacioAdentroDevuelveCollectionDeTransactionsVacia stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test21PortfolioConUnPortfolioNoVacioAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:07:29'!
FAILURE!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:07:29'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:07:35'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:08:33'!
FAILURE!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:08:34'!
FAILURE!

#(1 2 3) = #(1 2 3)!

a = a copy !

a = (a copy)!

cuenta1 := ReceptiveAccount new!

Deposit register: 50 on: cuenta1.!

a := Deposit register: 50 on: cuenta1.!

a = a!

a = (a copy)!

portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Deposit register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.!

portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Deposit register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.!

	cuenta1 transactions !

	cuenta1 transactions on: 1!

	cuenta1 transactions at: 0!

	(cuenta1 transactions) at: 0!

	(cuenta1 transactions) at: 1!

	(cuenta1 transactions) at: 1 value!

	((cuenta1 transactions) at: 1) value!

	((portfolio transactions) at: 1) value!

	((portfolio transactions) at: 2) value!

	((cuenta1 transactions) at: 1) operationValue !

	((portfolio transactions) at: 1) operationValue !

	((portfolio transactions) at: 2) operationValue !

	((cuenta2 transactions) at: 1) operationValue.!

	transaccion2 := Withdraw register: 50 on: cuenta2.!

portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Withdraw register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.!

	((cuenta2 transactions) at: 1) operationValue.!

	((portfolio transactions) at: 2) operationValue !

	((portfolio transactions) at: 1) operationValue !

	(portfolio transactions) = ((cuenta2 transactions) addAll: cuenta1 transactions)!

	(portfolio transactions) = ((cuenta1 transactions) addAll: cuenta2 transactions)!

	(portfolio transactions) at: 1!

	(portfolio transactions at: 1) = (cuenta1  transactions at: 1)!

	(portfolio transactions at: 2) = (cuenta1  transactions at: 2)!

	(portfolio transactions at: 1) = (cuenta1  transactions at: 1) true .!

	(portfolio transactions at: 1) = (cuenta1  transactions at: 1).!

	portfolio transactions!

portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Withdraw register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.!
!FinancialAssetsTests methodsFor: 'tests' stamp: 'BSN 10/31/2025 15:19:30' prior: 50596936!
test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente
	| portfolio subPortfolio1 subPortfolio2 cuenta1 cuenta2 transaccion1 transaccion2 |
	portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Deposit register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.
	
	self assert: (portfolio transactions = ((cuenta1 transactions) addAll: cuenta2 transactions) )! !

!methodRemoval: Portfolio #enumerateTransactions stamp: 'BSN 10/31/2025 15:20:14'!
enumerateTransactions
	assets do: [:anAccount | transactions addAll: (anAccount transactions)]!
!Portfolio methodsFor: 'control' stamp: 'BSN 10/31/2025 15:20:55' prior: 50596339!
transactions 
	|transactionsa|
	transactions = OrderedCollection new
	assets do: [:anAccount | transactions addAll: (anAccount transactions)]
	^ transactions ! !

Object subclass: #FinancialAssets
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio'!

!classDefinition: #FinancialAssets category: #Portfolio stamp: 'BSN 10/31/2025 15:21:05'!
Object subclass: #FinancialAssets
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio'!

FinancialAssets subclass: #Portfolio
	instanceVariableNames: 'assets transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio'!

!classDefinition: #Portfolio category: #Portfolio stamp: 'BSN 10/31/2025 15:21:18'!
FinancialAssets subclass: #Portfolio
	instanceVariableNames: 'assets transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio'!

FinancialAssets subclass: #Portfolio
	instanceVariableNames: 'assets'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio'!

!classDefinition: #Portfolio category: #Portfolio stamp: 'BSN 10/31/2025 15:22:00'!
FinancialAssets subclass: #Portfolio
	instanceVariableNames: 'assets'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio'!

FinancialAssets subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio'!

!classDefinition: #ReceptiveAccount category: #Portfolio stamp: 'BSN 10/31/2025 15:22:07'!
FinancialAssets subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio'!
!Portfolio methodsFor: 'control' stamp: 'BSN 10/31/2025 15:22:22' prior: 50597087!
transactions 
	|transactions|
	transactions = OrderedCollection new.
	assets do: [:anAccount | transactions addAll: (anAccount transactions)].
	^ transactions .! !
!Portfolio methodsFor: 'control' stamp: 'BSN 10/31/2025 15:22:36' prior: 50597142!
transactions 
	|transactions|
	transactions := OrderedCollection new.
	assets do: [:anAccount | transactions addAll: (anAccount transactions)].
	^ transactions .! !

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:22:41'!
FAILURE!

!testRun: #FinancialAssetsTests #test01PortfolioNuevoEmpiezaSinCuentas stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test02PortfolioAgregaCorrectamenteUnaCuenta stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioAgregaCorrectamenteDosCuentas stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioSinCuentasDevuelveBalanceCero stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test05PortfolioConUnaCuentaDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test06PortfolioConDosCuentasDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test07PortfolioSinTrasaccionesDevuelveCollectionVacia stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test08PortfolioDevuelveUnaTransaccionDeUnaCuentaCorrectamente stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test09PortfolioDevuelveDosTransaccionesDeCuentasDistintas stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test10PortfolioSinTransaccionesNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test11PortfolioRegistraUnaTransaccionCorrectamente stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test12PortfolioRegistraDosTransaccionesDeCuentasDistintasCorrectamente stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test13ReceptiveAccountNoPuedeTenerCuentasAdentro stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test14PortfolioNoPuedeTenerCuentasRepetidas stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test15PortfolioNoPuedeTenerPortfoliosRepetidos stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test16PortfolioNoPuedeRegistrarTransacciones stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test17PortfolioConUnPortfolioVacioAdentroDevuelveBalanceEnCero stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test18PortfolioConUnPortfolioNoVacioAdentroDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test19PortfolioConDosPortfoliosNoVaciosAdentroDevuelvenBalanceCorrecto stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test20PortfolioConUnPortfolioVacioAdentroDevuelveCollectionDeTransactionsVacia stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test21PortfolioConUnPortfolioNoVacioAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:22:44'!
FAILURE!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:22:44'!
PASSED!

portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Withdraw register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.!

	portfolio transactions!

	(portfolio transactions at: 1) = (cuenta1  transactions at: 1).!

	portfolio transactions!

	portfolio transactions at: 1!

	portfolio transactions at: 2!

	portfolio transactions.!

	(portfolio transactions at: 2) = (cuenta1  transactions at: 1).!

	(portfolio transactions at: 2) = (cuenta2  transactions at: 1).!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'BSN 10/31/2025 15:23:43' prior: 50596960!
transactions 

	^ transactions copy.! !

portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Withdraw register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.!

	portfolio transactions.!

	(portfolio transactions at: 1) = (cuenta2  transactions at: 1).!

	(portfolio transactions at: 1) = (cuenta1  transactions at: 1).!

	(portfolio transactions at: 1) = (cuenta2  transactions at: 1).!

	(portfolio transactions at: 2) = (cuenta2  transactions at: 1).!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:24:10'!
FAILURE!

	portfolio transactions.!

	cuenta2  transactions.!

	cuenta1  transactions.!

	(cuenta1 transactions) addAll: cuenta2 transactions.!

	((cuenta1 transactions) addAll: cuenta2 transactions)!

	cuenta1 transactions !

	cuenta1 transactions. !

	cuenta2 transactions. !

	cuenta1 transactions. !

	((cuenta1 transactions) addAll: cuenta2 transactions)!

	(portfolio transactions at: 2) = (cuenta2  transactions at: 1).!

	portfolio transactions!

	(cuenta1 transactions , cuenta2 transactions)!

	(portfolio transactions) = (cuenta1 transactions , cuenta2 transactions)!
!FinancialAssetsTests methodsFor: 'tests' stamp: 'BSN 10/31/2025 15:27:19' prior: 50597058!
test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente
	| portfolio subPortfolio1 subPortfolio2 cuenta1 cuenta2 transaccion1 transaccion2 |
	portfolio := Portfolio new.
	subPortfolio1 := Portfolio new.
	subPortfolio2 := Portfolio new.
	
	cuenta1 := ReceptiveAccount new.
	cuenta2 := ReceptiveAccount new.
	
	transaccion1 := Deposit register: 50 on: cuenta1.
	transaccion2 := Deposit register: 50 on: cuenta2.
	
	portfolio add: subPortfolio1.
	subPortfolio1 add: cuenta1.
	portfolio add: subPortfolio2.
	subPortfolio2 add: cuenta2.
	
	self assert: (portfolio transactions) = (cuenta1 transactions , cuenta2 transactions)! !

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:27:21'!
PASSED!

!testRun: #FinancialAssetsTests #test01PortfolioNuevoEmpiezaSinCuentas stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test02PortfolioAgregaCorrectamenteUnaCuenta stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioAgregaCorrectamenteDosCuentas stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioSinCuentasDevuelveBalanceCero stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test05PortfolioConUnaCuentaDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test06PortfolioConDosCuentasDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test07PortfolioSinTrasaccionesDevuelveCollectionVacia stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test08PortfolioDevuelveUnaTransaccionDeUnaCuentaCorrectamente stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test09PortfolioDevuelveDosTransaccionesDeCuentasDistintas stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test10PortfolioSinTransaccionesNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test11PortfolioRegistraUnaTransaccionCorrectamente stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test12PortfolioRegistraDosTransaccionesDeCuentasDistintasCorrectamente stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test13ReceptiveAccountNoPuedeTenerCuentasAdentro stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test14PortfolioNoPuedeTenerCuentasRepetidas stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test15PortfolioNoPuedeTenerPortfoliosRepetidos stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test16PortfolioNoPuedeRegistrarTransacciones stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test17PortfolioConUnPortfolioVacioAdentroDevuelveBalanceEnCero stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test18PortfolioConUnPortfolioNoVacioAdentroDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test19PortfolioConDosPortfoliosNoVaciosAdentroDevuelvenBalanceCorrecto stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test20PortfolioConUnPortfolioVacioAdentroDevuelveCollectionDeTransactionsVacia stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test21PortfolioConUnPortfolioNoVacioAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:27:23'!
PASSED!

!testRun: #FinancialAssetsTests #test01PortfolioNuevoEmpiezaSinCuentas stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test02PortfolioAgregaCorrectamenteUnaCuenta stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioAgregaCorrectamenteDosCuentas stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test03PortfolioSinCuentasDevuelveBalanceCero stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test05PortfolioConUnaCuentaDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test06PortfolioConDosCuentasDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test07PortfolioSinTrasaccionesDevuelveCollectionVacia stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test08PortfolioDevuelveUnaTransaccionDeUnaCuentaCorrectamente stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test09PortfolioDevuelveDosTransaccionesDeCuentasDistintas stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test10PortfolioSinTransaccionesNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test11PortfolioRegistraUnaTransaccionCorrectamente stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test12PortfolioRegistraDosTransaccionesDeCuentasDistintasCorrectamente stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test13ReceptiveAccountNoPuedeTenerCuentasAdentro stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test14PortfolioNoPuedeTenerCuentasRepetidas stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test15PortfolioNoPuedeTenerPortfoliosRepetidos stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test16PortfolioNoPuedeRegistrarTransacciones stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test17PortfolioConUnPortfolioVacioAdentroDevuelveBalanceEnCero stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test18PortfolioConUnPortfolioNoVacioAdentroDevuelveBalanceCorrecto stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test19PortfolioConDosPortfoliosNoVaciosAdentroDevuelvenBalanceCorrecto stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test20PortfolioConUnPortfolioVacioAdentroDevuelveCollectionDeTransactionsVacia stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test21PortfolioConUnPortfolioNoVacioAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test22PortfolioConDosPortfoliosNoVaciosAdentroDevuelveTransactionsCorrectamente stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test23PortfolioConUnPortfolioVacioAdentroNoRegistraTransacciones stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test24PortfolioConUnPortfolioNoVacioAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

!testRun: #FinancialAssetsTests #test25PortfolioConDosPortfoliosNoVaciosAdentroRegistraTransaccionesCorrectamente stamp: 'BSN 10/31/2025 15:27:38'!
PASSED!

----STARTUP---- (7 November 2025 14:25:45) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----STARTUP---- (7 November 2025 14:26:17) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ejercicio-3-p3-portfolio-2-este-grupo-es-un-objeto/Portfolio2.st----!

!classRenamed: #TransferNet as: #AccountTransferNet stamp: 'BSN 11/7/2025 14:35:33'!
Smalltalk renameClassNamed: #TransferNet as: #AccountTransferNet!

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 14:35:44'!
FAILURE!

!testRun: #ReportTest #test02AccountSummaryForAccountWithDepositReturnsCorrectSummary stamp: 'BSN 11/7/2025 14:35:44'!
FAILURE!

!testRun: #ReportTest #test03AccountSummaryForAccountWithDepositAndWithdrawReturnsCorrectSummary stamp: 'BSN 11/7/2025 14:35:44'!
FAILURE!

!testRun: #ReportTest #test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary stamp: 'BSN 11/7/2025 14:35:44'!
FAILURE!

!testRun: #ReportTest #test05AccountSummaryForAccountWithDepositWithdrawAndDoubleTransferReturnsCorrectSummary stamp: 'BSN 11/7/2025 14:35:44'!
FAILURE!

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 14:35:58'!
FAILURE!

----STARTUP---- (7 November 2025 14:36:09) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ejercicio-3-p3-portfolio-2-este-grupo-es-un-objeto/Portfolio2.st----!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'BSN 11/7/2025 14:37:44'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithAccountsIsSumOfAccountsBalance stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'BSN 11/7/2025 14:37:46'!
PASSED!

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 14:37:54'!
FAILURE!

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 14:37:57'!
FAILURE!

!testRun: #ReportTest #test02AccountSummaryForAccountWithDepositReturnsCorrectSummary stamp: 'BSN 11/7/2025 14:37:57'!
FAILURE!

!testRun: #ReportTest #test03AccountSummaryForAccountWithDepositAndWithdrawReturnsCorrectSummary stamp: 'BSN 11/7/2025 14:37:57'!
FAILURE!

!testRun: #ReportTest #test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary stamp: 'BSN 11/7/2025 14:37:57'!
FAILURE!

!testRun: #ReportTest #test05AccountSummaryForAccountWithDepositWithdrawAndDoubleTransferReturnsCorrectSummary stamp: 'BSN 11/7/2025 14:37:57'!
FAILURE!

!testRun: #TransferTest #test01TransferenceOnlyCanHaveAccountsAsSenders stamp: 'BSN 11/7/2025 14:38:01'!
PASSED!

!testRun: #TransferTest #test02TransferenceCanOnlyHaveNumbersAsValue stamp: 'BSN 11/7/2025 14:38:01'!
PASSED!

!testRun: #TransferTest #test03TransferenceRepresentsAWithdrawForSender stamp: 'BSN 11/7/2025 14:38:01'!
PASSED!

!testRun: #TransferTest #test04TransferenceRepresentsADepositForReceiver stamp: 'BSN 11/7/2025 14:38:01'!
PASSED!

!testRun: #TransferTest #test05TransferenceLegsHaveSameTransference stamp: 'BSN 11/7/2025 14:38:01'!
PASSED!

!testRun: #TransferTest #test06DepositLegCanGoToWithdrawLeg stamp: 'BSN 11/7/2025 14:38:01'!
PASSED!

!testRun: #TransferTest #test07WithdrawLegCanGoToDepositLeg stamp: 'BSN 11/7/2025 14:38:01'!
PASSED!

!classRenamed: #TransferNet as: #AccountTransferNet stamp: 'BSN 11/7/2025 14:38:22'!
Smalltalk renameClassNamed: #TransferNet as: #AccountTransferNet!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'BSN 11/7/2025 14:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'BSN 11/7/2025 14:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'BSN 11/7/2025 14:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'BSN 11/7/2025 14:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'BSN 11/7/2025 14:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'BSN 11/7/2025 14:38:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'BSN 11/7/2025 14:38:25'!
PASSED!

!testRun: #TransferTest #test01TransferenceOnlyCanHaveAccountsAsSenders stamp: 'BSN 11/7/2025 14:38:27'!
PASSED!

!testRun: #TransferTest #test02TransferenceCanOnlyHaveNumbersAsValue stamp: 'BSN 11/7/2025 14:38:27'!
PASSED!

!testRun: #TransferTest #test03TransferenceRepresentsAWithdrawForSender stamp: 'BSN 11/7/2025 14:38:27'!
PASSED!

!testRun: #TransferTest #test04TransferenceRepresentsADepositForReceiver stamp: 'BSN 11/7/2025 14:38:27'!
PASSED!

!testRun: #TransferTest #test05TransferenceLegsHaveSameTransference stamp: 'BSN 11/7/2025 14:38:27'!
PASSED!

!testRun: #TransferTest #test06DepositLegCanGoToWithdrawLeg stamp: 'BSN 11/7/2025 14:38:27'!
PASSED!

!testRun: #TransferTest #test07WithdrawLegCanGoToDepositLeg stamp: 'BSN 11/7/2025 14:38:27'!
PASSED!

account := ReceptiveAccount new.!

accountSummary := AccountSummary on: account.!

accountSummary value!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 14:51:59' prior: 50598219!
test01AccountSummaryForEmptyAccountShouldBeAllZeros
	| account accountSummary |
	account := ReceptiveAccount new.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary value = ('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 0'))
	
	! !
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 14:52:29' prior: 50598413!
test01AccountSummaryForEmptyAccountShouldBeAllZeros
	| account accountSummary |
	account := ReceptiveAccount new.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary value = ('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 0'))
! !

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 14:52:31'!
FAILURE!

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 14:52:32'!
FAILURE!

----STARTUP---- (7 November 2025 14:57:09) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ejercicio-3-p3-portfolio-2-este-grupo-es-un-objeto/Portfolio2.st----!
!Object methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^self! !
!Evaluation methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self subclassResponsibility! !
!CachedEvaluation methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	cachedValue isNil ifTrue: [self initializeCachedValue].
	^cachedValue! !
!DummyEvaluation methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^measure! !
!TopologicalSort methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	| tempGraph result |

	tempGraph := graph copy.
	result := OrderedCollection new.

	[tempGraph notEmpty] whileTrue: [| startingNodes |
		startingNodes := tempGraph nodesWithoutConvergingEdges.
		result addAll: startingNodes.
		tempGraph := tempGraph removeNodes: startingNodes].

	^result! !
!GregorianTimespan methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^self class from: from value duration: duration! !
!DecisionConditionCoverageReportBuilder methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^ CodeCoverageReport
		for: compiledMethod
		executed: compiledMethodWasExecuted
		with: self consolidateCoverageResults
		messages: self messages.! !
!CodeCoverageAnalyzerBuilder methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^ CodeCoverageAnalyzer toAnalyzeAll: self compiledMethodsToAnalyze! !
!AssignmentNode methodsFor: 'initialization' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	^ value! !
!CodeCoverageSourceCodeGenerator methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	"Add tracing to methodNode to generate its traced source code.
	
	I traverse the method node's AST adding tracing to each parse node.
	For more information about how each type of parse node is traced, see methods in my 'visiting' protocol."
	
	methodNode accept: self.
	
	"Force source text generation"
	methodNode sourceText: nil.
	
	tracedSourceCode := methodNode sourceText.! !
!MessageSendingBlocksVariablesToExtractFinder methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	messageNode arguments do: [:argument |
		currentScopeTemporaries := Bag new.
		argument accept: self].

	variablesToExtract remove: 'true' ifAbsent: [nil].
	variablesToExtract remove: 'false' ifAbsent: [nil].
	variablesToExtract remove: 'nil' ifAbsent: [nil].
	variablesToExtract remove: variableToExclude ifAbsent: [nil].

	^OrderedCollection newFrom: variablesToExtract! !
!VariablesToExtractFinder methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	variablesToExtract addAll: methodNode argumentNames.
	methodNode accept: self.

	^variablesToExtract! !
!CodeForNodeOnMethod methodsFor: 'accessing' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	
	self initializeNodeInterval.
	self initializeOffset.
	self intervalsToModify.
	^self newModifiedCode.
	
! !
!ClassVarAssignationChecker methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	returnBlockTrue := [^true].
	compiledMethod methodNode accept: self.
	^false! !
!CodeForNodeToMove methodsFor: 'accessing' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	| newCode newCodeForNode |
	self initializeNodeInterval.
	self initializeOffset.
	node accept: self.
	intervalsToModify := intervalsToModify collect: [ :anAssociation | (anAssociation key - nodeOffsetInSourceCode) -> anAssociation value ].
	newCodeForNode := methodNode sourceText copyFrom: nodeInterval first to: nodeInterval last.
	
	intervalsToModify sort: [ :left :right | left key first < right key first ].
	newCode := newCodeForNode copyReplacing: intervalsToModify.
	 
	hasImplicitSelfReturn 	ifTrue: [ 
			(newCode last = $.) ifFalse: [newCode := newCode append: '.'].
			newCode := newCode append: String newLineString, String tab, '^', parameterNeeded parameterName, '.'
			].
	^CodeForNodeToMoveResult 
				newWith: newCode 
				sourceClass: methodNode methodClass
				targetClass: targetClass
				methodsToCompileOnSourceClass: methodToCompileOnSourceClass! !
!MethodWorksAsGetterVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	returnMethodIsNotGetterClousure := [^false].
	returnMethodIsGetterClousure := [^true].
	getterCandidate methodNode accept: self.
	^false! !
!NeedParameterName methodsFor: 'public' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	  
	methodNode := compiledMethod methodNode.
	methodNode accept: self.
	^self needParameterName ! !
!MultiImplementorsActualMessageSendsCollector methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self
		calculateSendersInfo;
		groupSendersByType;
		createMessageList ! !
!ReceiverTypesOfMessageSendsConform methodsFor: 'evaluation' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	notIncludedReceiverTypesInMessageSends := OrderedCollection new.

	implementors ifNotEmpty: [
		sentSelector := implementors anyOne selector.
		types := implementors collect: [ :anImplementor | anImplementor methodClass ].

		senders do: [ :aSender |
			currentSender := aSender.
			currentSenderMethodClass := aSender methodClass.
			currentSender notOptimizedMethodNode accept: self ]].

	^notIncludedReceiverTypesInMessageSends! !
!MethodTypeCheckerVisitor methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self
		prepareToValue;
		visitMethodNode: methodNode.
! !
!ZipEncoderNode methodsFor: 'accessing' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	^value! !
!Collaborator methodsFor: 'value' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^owner instVarNamed: name! !
!Delegator methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	
	| implementor |
	
	implementor := currentMethodClass superclass.
	[ implementor ~= DenotativeObject class ] whileTrue: [
		(implementor includesSelector: selector) ifTrue: [ | methodToDelegate |
			methodToDelegate := implementor compiledMethodAt: selector.
			^ methodToDelegate
				valueWithReceiver: receiver
				arguments: arguments ].
		implementor := implementor superclass ].
	
	self error: 'No parent implements ' , selector.
! !
!ArgumentsAndReturnsFinder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	| paramsAndReturnsFinder |
	
	ranges := OrderedCollection new.
	
	paramsAndReturnsFinder := ParseNodeEnumerator ofBlock: [ :node | 	
		(self isReturnIvar: node) ifTrue: [self addReturnRangesFrom: node].
		(self isMessageWithIvarAsArg: node) ifTrue: [ self addParametersRangesFrom: node]].

	methodNode accept: paramsAndReturnsFinder.
! !
!ReturnStatementAdder methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	self nonImplicitNumberOfStatements = 1 ifTrue: [ self valueOneStatement ].
	self nonImplicitNumberOfStatements > 1 ifTrue: [ self valueMultipleStatements ].	! !
!IfNilChecksFinder methodsFor: 'initialization' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	| selectors |

	selectors := contextClass whichSelectorsAccess: instanceVariable.

	^selectors inject: OrderedCollection new into: [:ifNilChecks :selector |
		ifNilChecks addAll: (self ifNilChecksIn: selector). ifNilChecks.].! !
!TTKernPair methodsFor: 'accessing' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	^value! !
!WeakActionSequence methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	"Do the same as my parent, but make sure that all actions that do not  
	give errors are evaluated before resignaling the ones that gave errors  
	(giving the chance to clients to handle them)."

	^self valueStartingFrom: 1! !
!BlockClosure methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the copied values to the activation as its copied
	 temps. Primitive. Essential."
	<primitive: 201>

	numArgs ~= 0 ifTrue:
		[self numArgsError: 0].
	self primitiveFailed.! !
!FilteredGregorianDate methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^date
! !
!RelativeGregorianDate methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^self absoluteDate! !
!Association methodsFor: 'accessing' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	"Answer the value of the receiver."
	^value! !
!ReadOnlyVariableBinding methodsFor: 'accessing' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	^value! !
!MessageSend methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	"Send the message and answer the return value"

	arguments ifNil: [^ receiver perform: selector].

	^ receiver 
		perform: selector 
		withArguments: (self collectArguments: arguments)! !
!WeakMessageSend methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	^ arguments
		ifNil: [
			self withEnsuredReceiverDo: [ :r | r perform: selector ]]
		ifNotNil: [
			self withEnsuredReceiverAndArgumentsDo: [ :r :a |
				r
					perform: selector
					withArguments: a ]]! !
!ActualImplementorsFinder methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self subclassResponsibility ! !
!AllActualImplementors methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	| typeImplementors |

	notImplemented := OrderedCollection new.
	implementors := Set new.
	types do: [ :aType |
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self! !
!AllActualLocalImplementors methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	notImplemented := OrderedCollection new.
	implementors := types
		inject: IdentitySet new
		into: [ :methods :aClass |
			(aClass lookupSelector: selector )
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ].

	implementors := implementors collect: [ :method | method asMethodReference ].

	^self
! !
!TypeChecker methodsFor: 'type checking' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self subclassResponsibility! !
!ManyMethodsTypeChecker methodsFor: 'type checking' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	typeCheckers := methodsToCheck collect: [:aMethod | aMethod typeCheck ].

	^self! !
!MethodTypeChecker methodsFor: 'type checking' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self
		initializeErrorsWarningsAndProblems;
		typeCheck.

	^self! !
!DropFilesAction methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	stopHereBlock := [ ^self ].
	dropFilesEvent fileNamesDo: [ :fileName | self fileNamedDropped: fileName ]
		
! !
!AccountTransaction methodsFor: 'value' stamp: 'BSN 11/7/2025 14:58:18'!
lines 

	self subclassResponsibility ! !
!Deposit methodsFor: 'value' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^ value! !
!Withdraw methodsFor: 'value' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^ value! !
!AccountSummary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18'!
lines 
	^ summary ! !
!TransferNet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	^ net! !
!Transfer methodsFor: 'testing' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	^ value! !
!ControlChangeEvent methodsFor: 'accessing' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^ value
! !
!Preference methodsFor: 'accessing' stamp: 'BSN 11/7/2025 14:58:18'!
lines
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value value]
		ifFalse: [value]
	! !
!SubstringMatcher methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	^ resultsSorter value: (self filterCollection asOrderedCollection)! !
!CatalogButton methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	
	model changeSelectedCatalog: catalog! !
!ClassReferencesCollector methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	| withAllSubclasses |
	
	withAllSubclasses := classToLookForReferences withAllSubclasses.
	self initializeCollectionFor: withAllSubclasses.
		
	withAllSubclasses do: [ :aClass | self collectReferencesOf: aClass ].
		
	! !
!ExtractMethodNewMethodSourceCode methodsFor: 'value' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self 
		initializeSourceCodeToExtract;
		initiliazeNewSourceCode;
		renameArguments. 
	
	^newSourceCode ! !
!ExtractMethodParametersDetector methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	
	"Return the parse nodes of the parameters to use in the extracted method.
	
	Implementation details
	--------------
	The enumeration order of the parse nodes is non-deterministic.
	
	To fix this, I keep track of the position for each parameter node to sort
	results in the order they appear in the source code."
	
	| parameterNodePositions |
	
	parameterNodePositions := Dictionary new.
	
	methodNodeToRefactor completeSourceRangesDo: [ :parseNode :sourceRanges |
		(self shouldBeParameterized: parseNode appearingIn: sourceRanges)
			ifTrue: [ 
				parameterNodePositions
					at: parseNode
					put: (self firstPositionInIntervalToExtractIn: sourceRanges) ]].
		
	^ parameterNodePositions keys sort: [ :parameterNode :anotherParameterNode |
		(parameterNodePositions at: parameterNode) <= (parameterNodePositions at: anotherParameterNode) ]! !
!ExtractMethodReplacementsFinder methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	nodesToExtract := self nodesToExtract.
	replacements := OrderedCollection new.
	findingStrategy := self defineFindingStrategy.
	
	self findReplacementInHierarchy.! !
!NodesInRangeFinder methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	
	| nodeAtLastPositionFound |

	"Because some nodes have many ranges, like the literal nodes, we count the time we pass by a node that is equivalent
	to the index in the source ranges collection. sourceRangeIndexByNode is used to count per node - Hernan"
	sourceMethodNode := sourceMethod methodNode.
	sourceCode := sourceMethod sourceCode.
	statements := OrderedCollection new.
	sourceRangeIndexByNode := IdentityBag new.
	firstNodeFound := false.

	sourceMethodNode nodesDo: [ :aNode | | nodeRange |
		sourceRangeIndexByNode add: aNode.
		nodeRange := self completeSourceRangeOf: aNode.
		nodeAtLastPositionFound := self ifInsideRangeAddToStatements: aNode locatedAt: nodeRange.
		nodeAtLastPositionFound ifTrue: [ ^statements ]].
			
	self error: 'nodes not found'
	! !
!RefactoringApplier methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	requestExitBlock := [ ^self ].
	
	self 
		requestRefactoringParametersHandlingRefactoringExceptions;
		createRefactoringHandlingRefactoringExceptions;
		applyRefactoring;
		showChanges
	
	! !
!ExtractClassApplier methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	self requestRefactoringParametersHandlingRefactoringExceptions.! !
!ExtractToMethodObjectApplier methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self requestRefactoringParametersHandlingRefactoringExceptions.! !
!IntroduceNullObjectApplier methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self requestRefactoringParametersHandlingRefactoringExceptions.! !
!ExtractMethodApplier methodsFor: 'value' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	requestExitBlock := [ ^self ].
	
	self requestRefactoringParametersHandlingRefactoringExceptions
! !
!ChangeSelectorApplier methodsFor: 'evaluation' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	requestExitBlock := [ ^self ].
		
	self requestRefactoringParametersHandlingRefactoringExceptions.
	
	self 
		ifHasNoSendersAndOneImplementor: [ :anImplementor | 
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor ]
		ifNot: [ self askForImplementosAndSenders ]! !
!ExtractParameterObjectApplier methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	requestExitBlock := [ ^self ].
	methodToRefactor := selectedClass compiledMethodAt: oldSelector.
		
	self requestRefactoringParametersHandlingRefactoringExceptions.! !
!InlineMethodApplier methodsFor: 'evaluation' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollection new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]! !
!RefactoringPrecondition methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self subclassResponsibility! !
!NewClassPrecondition methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self assertNewClassNameIsNotEmpty.
	self assertNewClassNameSymbol.
	self assertNewClassNameStartsWithRightLetter.
	self assertNewClassNameHasNoSeparators.
	self assertNewClassNameDoesNotExistInSystem.
	self assertNewClassNameIsNotDeclaredInUndeclared.

! !
!NewGlobalPrecondition methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self 
		assertNewNameIsNotEmpty;
		assertNewNameIsSymbol;
		assertNewNameHasNoSeparators;
		assertNewNameDoesNotExistInSystem.

! !
!NewInstanceVariablePrecondition methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	
	self assertIsNotEmpty.
	self assertIsNotAReservedName.
	self assertIsValidInstanceVariableName.
	self assertIsNotAlreadyDefined.

	self assertIsNotDefinedInMethods.! !
!NewSelectorPrecondition methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self
		assertNewSelectorIsNotEmpty;
		assertNewSelectorDoesNotContainSeparators;
		assertNewSelectorBeginsWithAValidCharacter;
		assertNewSelectorContainsOnlyValidCharacters;
		assertNewSelectorIsNotAlreadyDefinedWithinTheClassHierarchy! !
!NewTemporaryPrecondition methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self
		assertIsNotEmpty;
		assertIsValidVariableName;
		assertIsNotAReservedName;
		assertIsNotDefinedAsInstanceVariableInHierarchyOfMethodClass;
		assertIsNotDeclaredInParentsOrChildrenScopes! !
!SourceCodeIntervalPrecondition methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self subclassResponsibility! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self
		initializeParseNodesMatchingSelectionInterval;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotLeftSideOfAssignment;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeDoesNotIncludeTemporaryAssignmentsWithoutDeclaration;
		assertSourceCodeDoesNotHaveTemporaryVariablesUsedOutsideOfSelectionInterval;
		assertSourceCodeContainsAValidExpression! !
!SourceCodeOfTemporaryToBeExtractedPrecondition methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	self
		initializeParseNodeToExtract;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeHasOneStatement;
		assertSourceCodeIsACompleteExpression;
		assertSourceCodeContainValidNodes! !
!ProgressiveTestRunner methodsFor: 'evaluating' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	Utilities authorInitials.
	testsStream := ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]! !
!CodeCoverageTest methodsFor: 'test objects' stamp: 'BSN 11/7/2025 14:58:18'!
lines

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super value! !
!WebCookie methodsFor: 'accessing' stamp: 'BSN 11/7/2025 14:58:18'!
lines
	"The value of the cookie"

	^value! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50455822!
topBlockTempsMap

	self blockExtentsToTempsMap associationsDo: [ :anAssociation | anAssociation key first = 0 ifTrue: [ ^anAssociation lines ]].

	self error: 'Should not happen, there is always a topContext'! !
!DebuggerMethodMap methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16845716!
rangeForPC: contextsConcretePC contextIsActiveContext: contextIsActiveContext
	"Answer the indices in the source code for the supplied pc.
	 If the context is the actve context (is at the hot end of the stack)
	 then its pc is the current pc.  But if the context isn't, because it is
	 suspended sending a message, then its current pc is the previous pc."

	| pc end |
	pc := self method abstractPCForConcretePC:
		(contextIsActiveContext
			ifTrue: [ contextsConcretePC ]
			ifFalse: [
				(self method pcPreviousTo: contextsConcretePC) ifNil: [ contextsConcretePC ]]).
	(self abstractSourceMap includesKey: pc) ifTrue: [
		^self abstractSourceMap at: pc].
	sortedSourceMap ifNil: [
		sortedSourceMap := self abstractSourceMap.
		sortedSourceMap := (sortedSourceMap keys
			collect: [ :key | key -> (sortedSourceMap at: key)])
				asSortedCollection ].
	sortedSourceMap
		findBinaryIndex: [ :assoc | pc - assoc key ]
		do: [ :i | ^(sortedSourceMap at: i) lines ]
		ifNone: [ :lower :upper |
			lower = 0 ifTrue: [ ^1 to: 0 ].
			upper <= sortedSourceMap size ifTrue: [
				^(sortedSourceMap at: upper) lines ].    "No match, but  a nearby element."
			end := sortedSourceMap detectMax: [ :each |
				each lines last ].
			end := end lines last.
			^end + 1 to: end ].

	"| method source scanner map |
	 method := DebuggerMethodMap compiledMethodAt: #rangeForPC:contextIsActiveContext:.
	method := Debugger >> #pcRange.
	source := method getSourceFromFile asString.
	scanner := InstructionStream on: method.
	map := method debuggerMap.
	Array streamContents:
		[:ranges|
		[scanner atEnd] whileFalse:
			[| range |
			 range := map rangeForPC: scanner pc contextIsActiveContext: true.
			 ((map abstractSourceMap includesKey: scanner abstractPC)
			  and: [range first ~= 0]) ifTrue:
				[ranges nextPut: (source copyFrom: range first to: range last)].
			scanner interpretNextInstructionFor: InstructionClient new]]"! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50599430!
test03AccountSummaryForAccountWithDepositAndWithdrawReturnsCorrectSummary
	| account accountSummary |
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Withdraw register: 50 on: account.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary lines = ('Dposito por 50' , 'Extraccin por 50' , 'Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 0'))
	! !
!Socket methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50585596!
waitForDataIfClosed: closedBlock
	"Wait indefinitely for data to arrive.  This method will block until
	data is available or the socket is closed."

	[socketHandle ifNil: [^closedBlock lines ].
	(self primSocketReceiveDataAvailable: socketHandle) ifTrue: [ ^self ].
	 self isConnected ifFalse: [ ^closedBlock lines ].
	 "ul 8/13/2014 21:16
	  Providing a maximum for the time for waiting is a workaround for a VM bug which
	  causes sockets waiting for data forever in some rare cases, because the semaphore
	  doesn't get signaled. Replace the ""waitTimeoutMSecs: self class maximumReadSemaphoreWaitTimeout""
	  part with ""wait"" when the bug is fixed."
	 readSemaphore waitTimeoutMSecs: self class maximumReadSemaphoreWaitTimeout ] repeat! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16854455!
criteriaToSortSourceRangeBetween: parseNodeWithSourceRangeOne and: parseNodeWithSourceRangeTwo

	| sourceRangeOne sourceRangeTwo |
	sourceRangeOne := parseNodeWithSourceRangeOne lines.
	sourceRangeTwo := parseNodeWithSourceRangeTwo lines.
	^ sourceRangeOne first > sourceRangeTwo first
		or: [ sourceRangeOne first = sourceRangeTwo first
			and: [ sourceRangeOne last <= sourceRangeTwo last ] ]! !
!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16938881!
dumpPigStackOn: aStream
	"Must run forked on its own process, so the monitored behavior is not affected too much"

	| promise tally process stack suspendedContext |
	promise := Processor tallyCPUUsageFor: 1 every: 10.
	tally := promise lines.
	process := tally sortedCounts first lines.
	"Avoid, if possible, the background process, and terminated processes."
	tally sortedCounts do: [ :entry |
		(process == Processor backgroundProcess or: [process isTerminated])
			ifTrue: [ process := entry lines ]].
	"UISupervisor whenUIinSafeState: [self dumpTallyOnTranscript: tally]."
	aStream nextPutAll: '====Al processes===='; newLine.
	self dumpTally: tally on: aStream.
	aStream newLine; nextPutAll: '====Process using most CPU===='; newLine.
	(100.0 * (tally occurrencesOf: process) / tally size) rounded printOn: aStream.
	aStream
		nextPutAll: ' % ';
		nextPutAll: (process browserPrintStringFull: false);
		newLine.
	stack := process == Processor activeProcess
		ifTrue: [thisContext stackOfSize: Debugger defaultDebugStackSize]
		ifFalse: [
			suspendedContext := process suspendedContext.
			suspendedContext
				ifNotNil: [suspendedContext stackOfSize: Debugger defaultDebugStackSize]].
	stack 
		ifNil: [ aStream nextPutAll: 'No context'; newLine]
		ifNotNil: [
			stack do: [ :c | 
				c printOn: aStream.
				aStream newLine ]].
	^process! !
!WebUtils class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50594113!
handleAuth: aBlock
	"Utility method to handle web authentication requests interactively.

	Use like here:
		| wc |
		wc := WebClient new.
		WebUtils handleAuth:[wc httpGet: 'http://some.auth.required'].
	"

	| user pass |
	^[aBlock lines] on: WebAuthRequired do:[:ex|
		"Allow outer handlers to take over authentication"
		ex isNested ifFalse:[
			user := StringRequestMorph request:  ex message, 
				'\Please enter your user name:' initialAnswer:''.
			user ifNotEmpty:[
				"Just a little obfuscation to avoid completely plain passwords"
				pass := (StringRequestMorph request:
					'Please enter the password for "', user,'":') asUtf8Bytes base64Encoded.
				 ex username: user password: [String fromUtf8Bytes: pass base64Decoded]]].
		ex pass].! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16838730!
resumeEvaluating: aBlock
	"Unwind thisContext to self and resume with aBlock value as result of last send.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"

	| ctxt unwindBlock |
	self isDead ifTrue: [self cannotReturn: aBlock lines to: self].
	ctxt := thisContext.
	[
		ctxt := ctxt findNextUnwindContextUpTo: self.
		ctxt isNil
	] whileFalse: [
		(ctxt tempAt: 2) isNil ifTrue:
			[
				ctxt tempAt: 2 put: true.
				unwindBlock := ctxt tempAt: 1.
				thisContext terminateTo: ctxt.
				unwindBlock lines
			]
	].
	thisContext terminateTo: self.
	^aBlock lines! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16853968!
tempNodes 
	| tempNodes |
	tempNodes := SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].
	scopeTable associationsDo:
		[:assn |
		(assn lines is: #Array)
			ifTrue: [assn lines do: [:temp| tempNodes add: temp]]
			ifFalse: [assn lines isTemp ifTrue: [tempNodes add: assn lines]]].
	^tempNodes
	"jmv: perhaps better not include remote temps...
	^ tempNodes reject:
		[ : a |  a isUnusedTemp ]"! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16793939!
newProcessForDebugging
	"Answer a Process running the code in the receiver. The process is not 
	scheduled."
	<primitive: 19> "Simulation guard"
	| p |
	p := Process
		forContext: [
			self lines.
			p name: Debugger debuggingTerminatedProcessName.
			p terminate] asContext
		priority: Processor activePriority.
	^p! !
!CodeForNodeOnMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50531677!
shouldAddParenthesisOnValueOf: anAssignmentNode

	^ ((anAssignmentNode lines isMessageNode and: [anAssignmentNode lines isKeywordMessageSend])) or: [anAssignmentNode lines isAssignmentNode ]! !
!InlineTemporaryVariableApplier class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16886092!
findSourceRangesOfNode: aParseNode using: completeSourceRanges

	| ranges |
	
	ranges := OrderedCollection new.
	
	(completeSourceRanges associations select: [:aNodeAndRange | aNodeAndRange key equivalentTo: aParseNode])
	 	do: [:nodeAndRanges | ranges addAll: nodeAndRanges lines].
	
	^ranges.! !
!Dictionary methodsFor: 'as yet unclassified' library: #MinimalKernel04HashedCollections stamp: 'BSN 11/7/2025 14:58:18' prior: 50371890!
select: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect into a new 
	dictionary, only those associations for which aBlock evaluates to true."

	| newCollection |
	newCollection := self species new.
	self associationsDo: 
		[:each | 
		(aBlock value: each lines) ifTrue: [newCollection add: each]].
	^newCollection! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16799755!
removeAllUnreferencedInstVar

	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RemoveAllUnreferencedInstanceVariablesApplier on: self for: aClass) lines ].! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16907470!
withParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock lines ].
	^aBlock value: nodeAndPosition key.! !
!MoveMethod class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50541080!
needParameterNameToMove: methodName from: sourceClass accessingThrough: instanceVariable 
	| compiledMethod needParameterNameVisitor |
	compiledMethod := sourceClass compiledMethodAt: methodName.
	needParameterNameVisitor := NeedParameterName for: compiledMethod newAccessingThrough: instanceVariable .
	^needParameterNameVisitor lines! !
!Object methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16923783!
profilerFriendlyCall: aBlock
	"In AndreasSystemProfiler, usually primitives are reported as children of the wrong node.
	The reason is that while the primitive is recorded, it is only taken into account at next suspension point.
	
	For long running primitives, and maybe only while profiling, this method provides a workaround.
	Evaluate and compare

		AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 timesTwoPower: 10000]].
		AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 profilerFriendlyTimesTwoPower: 10000]].

	Also see #runProfilerProcess, and this more complex example (you might want to make it use #profilerFriendlyCall:)
		AndreasSystemProfiler spyOn:[10000 timesRepeat: [3.14159 printString]]

	Keep in mind there is a performance penaly each time this method is called.
	Consider doing it only for long-running primitives, or only while profiling code.
	"

	"The apparently useless loop is to ensure we have a suspension point in this method, after block evaluation.
	Suspension points are activation of message sends and bytecode back jumps."
	| primResult primWasCalled |
	primWasCalled := false.
	[ primWasCalled ] whileFalse: [
		primResult := aBlock lines.
		primWasCalled := true ].
	^primResult! !
!Parser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16927592!
fail

	| exitBlock |
	(encoder == nil or: [encoder == self])
		ifFalse: [encoder release. encoder := nil]. "break cycle"
	exitBlock := failBlock.
	failBlock := nil.
	^exitBlock lines! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50456778!
typesOfInstanceVariableNamed: anInstVarName ifAbsent: aBlock

	^(self instanceVariablesTypes typeInfoOf: anInstVarName ifAbsent: [ ^aBlock lines ]) types
	! !
!Collection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16828585!
detect: aBlock ifFound: foundBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.
	Answer the evaluation of foundBlock at the first element for which aBlock evaluates to true."
	^ foundBlock value: (self detect: aBlock ifNone: [^ exceptionBlock lines])! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16820512!
chooseDefiningInstanceVariableAlphabeticallyWith: aCaption thenDo: aBlock ifNone: noneBlock

	| vars index |
	"Put up a menu of the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."

	vars := self instVarNames sorted.
	vars isEmpty ifTrue: [^ noneBlock lines ].

	index := (PopUpMenu labelArray: vars lines: #()) startUpWithCaption: aCaption.
	index = 0 ifTrue: [^ self].
	aBlock value: (vars at: index)! !
!IntroduceNullObjectApplier methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50541310!
requestRefactoringParameters

	self chooseInstanceVariable.

	instanceVariable ifNil: [^self].

	ifNilChecks := (IfNilChecksFinder on: classToRefactor for: instanceVariable) lines.

	ifNilChecks ifEmpty: [^self inform: ('There are no ifNil checks on ', instanceVariable)].

	form := IntroduceNullObjectWindow open: self.! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16948643!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition.
	outlineMorph delete.
	action ifNotNil: [
		action lines.
		self delete]! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16854711!
withRangesOf: nodeAtRange including: aPosition do: aBlock

	| currentNodeRange ranges |

	currentNodeRange := nodeAtRange lines.
	ranges := currentNodeRange isInterval ifTrue: [ Array with: currentNodeRange ] ifFalse: [ currentNodeRange ].

	ranges do: [ :aRange | (aRange includes: aPosition) ifTrue: [ aBlock value: aRange ]].

	! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16848950!
at: key ifPresent: presentBlock ifAbsent: absentBlock
	"Answer the value associated with the key or, if key isn't found,
	answer the result of evaluating aBlock."
	"
		Smalltalk at: #zork ifPresent: [ :cls | (cls name, ' present') print ] ifAbsent: [ 'zork absent' print ]
		Smalltalk at: #Number ifPresent: [ :cls | (cls name, ' present') print ] ifAbsent: [ 'Number absent' print ]
	"

	| assoc |
	assoc := array at: (self findElementOrNil: key).
	assoc ifNil: [ ^ absentBlock lines ].
	^ presentBlock value: assoc lines! !
!InnerTextMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16887290!
processKeystrokeEvent: evt

	(acceptOn = #enter and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.

	"Return - check for special action"
	evt isReturnKey ifTrue: [
		self crAction ifNotNil: [ :action |
			^action lines ]].

	"Esc - check for special action"
	evt isEsc ifTrue: [			
		self escAction ifNotNil: [ :action |
			^action lines ]].

	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].

	"Only accept (on any) if we have unaccepted edits, otherwise the morph will flash."
	(hasUnacceptedEdits and: [ acceptOn == #any ]) ifTrue: [ self acceptContents ].! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16936988!
saveUserPrefs
	"
	PreferenceSet saveUserPrefs
	"
	| file |
	file := DirectoryEntry userBaseDirectory // 'UserPrefs.txt'.
	file forceWriteStreamDo: [ :stream |
		Preferences allPreferences keysAndValuesDo: [ :symbolName :preference |
			preference isSavedToDisk ifTrue: [
				stream
					nextPutAll: symbolName;
					nextPut: $=.
				preference lines printOn: stream.
				stream newLine ]]].! !
!TTCompositeGlyph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16980865!
glyphs

	^glyphs collect:[:assoc| assoc lines].! !
!True methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16999533!
ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer with the value of trueAlternativeBlock. Execution does not 
	actually reach here because the expression is compiled in-line."

	^trueAlternativeBlock lines! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50400993!
testIsCleanClosure
	"
	ClosureTests new testIsCleanClosure
	"
	| tempVar |
	tempVar := 1.
	self assert: [ 3 + 4 ] isCleanClosure.
	self assert: [ :a | a * 2 ] isCleanClosure.
	self assert: [ Smalltalk size ] isCleanClosure.
	self assert: [ ClosureTests selectors size ] isCleanClosure.
	self assert: [ :blockArg | blockArg printString ] isCleanClosure.
	self assert: [ | blockTemp | blockTemp printString ] isCleanClosure.
	self assert: [ | blockTemp | blockTemp := 7 ] isCleanClosure.
	self assert: [ | c | c := [ :a :b | a+b ]. c value: 3 value: 4 ] isCleanClosure.

	self assert: [[ 3 + 4 ] lines] isCleanClosure.
	self assert: [[ :a | a * 2 ] lines] isCleanClosure.
	self assert: [[ Smalltalk size ] lines] isCleanClosure.
	self assert: [[ ClosureTests selectors size ] lines] isCleanClosure.
	self assert: [[ :blockArg | blockArg printString ] lines] isCleanClosure.
	self assert: [[ | blockTemp | blockTemp printString ] lines] isCleanClosure.
	self assert: [[ | blockTemp | blockTemp := 7 ] lines] isCleanClosure.
	self assert: [[ | c | c := [ :a :b | a+b ]. c value: 3 value: 4 ] lines] isCleanClosure.

	self assert: [ | outerBlockTemp | [ outerBlockTemp printString ] ] isCleanClosure.
	self assert: [ | outerBlockTemp | [ outerBlockTemp := 7 ] ] isCleanClosure.
	self assert: [ | outerBlockTemp | [[ outerBlockTemp printString ]] ] isCleanClosure.
	self assert: [ | outerBlockTemp | [[ outerBlockTemp := 7 ]] ] isCleanClosure.
	self assert: [ [| outerBlockTemp | [ outerBlockTemp printString ]] ] isCleanClosure.
	self assert: [ [| outerBlockTemp | [ outerBlockTemp := 7 ]] ] isCleanClosure.

	self deny: [ | outerBlockTemp | [ outerBlockTemp printString ] isCleanClosure ] lines.
	self deny: [ | outerBlockTemp | [ outerBlockTemp := 7 ] isCleanClosure ] lines.
	self deny: [ | outerBlockTemp | [[ outerBlockTemp printString ]] isCleanClosure ] lines.
	self deny: [ | outerBlockTemp | [[ outerBlockTemp := 7 ]] isCleanClosure ] lines.

	self deny: [ tempVar + 1 ] isCleanClosure.
	self deny: [ tempVar := 1 ] isCleanClosure.
	self deny: [ ivar + 1 ] isCleanClosure.
	self deny: [ ivar := 1 ] isCleanClosure.
	self deny: [ ^ true ] isCleanClosure.
	self deny: [ self printString ] isCleanClosure.
	self deny: [ ^ self ] isCleanClosure.
	self deny: [ super printString ] isCleanClosure.
	self deny: [ ClassVar + 1 ] isCleanClosure.
	self deny: [ ClassVar := 1 ] isCleanClosure.

	self deny: [[ 3 + 4 ]. [ tempVar + 1 ] lines ] isCleanClosure.
	self deny: [[ 3 + 4 ]. [ tempVar := 1 ] lines ] isCleanClosure.
	self deny: [[ 3 + 4 ]. [ ivar + 1 ] lines ] isCleanClosure.
	self deny: [[ 3 + 4 ]. [ ivar := 1 ] lines ] isCleanClosure.
	self deny: [[ 3 + 4 ]. [ ^ true ] lines ] isCleanClosure.
	self deny: [[ 3 + 4 ].[ self printString ] lines ] isCleanClosure.
	self deny: [[ 3 + 4 ].[ ^ self ] lines ] isCleanClosure.
	self deny: [[ 3 + 4 ].[ super printString ] lines ] isCleanClosure.
	self deny: [[ 3 + 4 ].[ ClassVar + 1 ] lines ] isCleanClosure.
	self deny: [[ 3 + 4 ].[ ClassVar := 1 ] lines ] isCleanClosure.! !
!InstanceVariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50452134!
assertTypesAreCollectedCorrectlyFor: anInstVarTypeInfoCreator

	| root sibling1 sibling2 ivrootTypeInfo |

	self initializeHierarchyForTestingInstanceVariablesTypes.

	root := TypeInfoRootTestClass new.
	sibling1 := TypeInfoSibling1TestClass new.
	sibling2 := TypeInfoSibling2TestClass new.

	root ivroot: 1/2.
	sibling1 ivroot: 1.
	sibling2 ivroot: 1.0.

	ivrootTypeInfo := anInstVarTypeInfoCreator lines.

	self assert: 3 equals: ivrootTypeInfo typesSize.
	self assert: (ivrootTypeInfo typesIncludes: (1/2) class).
	self assert: (ivrootTypeInfo typesIncludes: 1 class).
	self assert: (ivrootTypeInfo typesIncludes: 1.0 class)! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50461356!
+ anAritmethicObject

	^self lines + anAritmethicObject lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50461674!
doesNotUnderstand: aMessage

	^aMessage sendTo: self lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50461539!
subtractFrom: aNumber

	^self lines subtractFrom: aNumber! !
!Morph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50334523!
balloonText
	"Answer balloon help text or nil, if no help is available.
	NB: subclasses may override such that they programatically
	construct the text, for economy's sake, such as model phrases in
	a Viewer.
	Allow for dynamic balloon text."

	^ (self valueOfProperty: #balloonText ifAbsent: nil) lines.! !
!PluggableButtonMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16930803!
performAction
	"Inform the model that this button has been pressed. "
	self isEnabled ifFalse: [^ self ].
	actionSelector ifNil: [ ^ self ].
	
	self actionBlock lines.! !
!InstanceVariablesTypes methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50446279!
typeInfoOf: anInstVarName ifAbsent: anAbsentBlock

	(class definesInstanceVariableNamedInHierarchy: anInstVarName) ifFalse:[ ^anAbsentBlock lines ].

	^ self typeInfoInHierarchyOf: anInstVarName! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16793510!
bench
	"See how many times I can value in 5 seconds.  I'll answer a meaningful description.
	[ Float pi printString ] bench print.
	[ 80000 factorial printString ] bench print.
	"

	| secondsPerRun startTime endTime count run elapsedTime gcStart gcTime |
	count := 0.
	run := true.
	Smalltalk garbageCollect.
	[ (Delay forSeconds: 5) wait. run := false ] forkAt: Processor timingPriority - 1.
	startTime := Time localMillisecondClock.
	gcStart := (Smalltalk vmParameterAt: 8) + (Smalltalk vmParameterAt: 10).
	[ run ] whileTrue: [ self lines. count := count + 1 ].
	endTime := Time localMillisecondClock.
	elapsedTime := endTime - startTime.
	gcTime := (Smalltalk vmParameterAt: 8) + (Smalltalk vmParameterAt: 10) - gcStart.
	secondsPerRun := (endTime - startTime) / (count * 1000).
	^String streamContents: [ :strm |
		secondsPerRun < 1 ifTrue: [
			1.0 / secondsPerRun withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
				value printOn: strm fractionDigits: 2.
				strm
					space;
					nextPutAll: unitPrefixSymbol;
					nextPutAll: ' runs per second. ' ]].
		secondsPerRun withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixSymbol;
				nextPutAll: ' seconds per run. '].
		gcTime / elapsedTime * 100 printOn: strm fractionDigits: 2.
		strm
			space;
			nextPutAll: ' % GC time.' ]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50461484!
divideCompoundMeasure: aMeasureBag

	^self lines divideCompoundMeasure: aMeasureBag! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50461688!
floor
	
	^self lines floor
	! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50463400!
timesRepeat: aBlock
	
	[ aBlock lines.
	true ] whileTrue! !
!Workspace methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 17017871!
classOfBindingOf: aName
												
	^ (self bindingOf: aName) lines ifNotNil: [ :aValue | aValue class ] ! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50426930!
test18FindsMultipleLiteralNodes

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 1. 1. 1. 1. 1'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 7) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 7) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (10 to: 13) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50461364!
/ anAritmethicObject

	^self lines / anAritmethicObject lines! !
!Collection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 16829307!
average: aBlock ifEmpty: emptyBlock 
	
	^ (self sum: aBlock ifEmpty: [ ^emptyBlock lines ]) / self size! !
!GregorianTimespan methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50478854!
value

	^self class from: from lines duration: duration! !
!ReturnStatementAdder class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:18' prior: 50532864!
valueTo: aCompiledMethod
	
	(self new to: aCompiledMethod) lines.! !
!CodeCoverageSourceCodeGenerator methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50503002!
visitCascadeNode: aCascadeNode

	"Add tracing to cascade nodes.
	I consider a cascade node covered when its receiver is covered and all of the sent messages are evaluated.
	
	Implementation Details
	===============
	
	I need to rewrite the cascade node as a sequence of regular message sends to add tracing to them.
	
	I go from this:
	
	 aReceiver
	        m1;
	        m2: #foo.
	
	to this:
	    
	    cascadeReceiver := aReceiver.
	    cascadeReceiver m1.
	    cascadeReceiver m2: #foo.
	
	This solves two issues:
	
	1) Correctly adding tracing to the receiver
	------------------------------------------------------
	The receiver can be any valid Smalltalk expression. In particular, it can be a message send or a block.
	No matter the case, I need to visit it to add tracing to it.
	I store the cascade receiver into the cascadeReceiver variable to ensure it is evaluated only once to keep the cascade semantics.
	
	2) Correctly adding tracing to the cascade message sends
	-------------------------------------------------------------------------
	By design MessageNodes in CascadeNode instances have their receiver set to nil, as it is the cascade node that provides it.
	This presents a problem for me: if I add tracing to the message nodes as they come out of aCascadeNode messages, the source code I will generate
	won't be a valid Smalltalk code as the message will be sent to no one.
	
	To fix it, I rewrite the cascade messages by assigning them a receiver: the cascadeReceiver variable that I mentioned above. This makes them valid
	message nodes, ones I know how to add tracing to."
 
	| cascadeBlockNode temporaryVariableForCascadeReceiver tracedMessageNodes temporariesDeclarations cascadeReceiverAssignment |
		
	"I create a temporary variable to hold a reference to the cascade receiver"
	temporaryVariableForCascadeReceiver := 	decompilerConstructor codeTemp: 0 named: 'cascadeReceiver'.
	temporariesDeclarations := TemporariesDeclarationNode withAll: { TemporaryDeclarationNode of: temporaryVariableForCascadeReceiver }.
	
	"Add tracing to the receiver node and assign it to its variable"
	cascadeReceiverAssignment := decompilerConstructor
		codeAssignTo: temporaryVariableForCascadeReceiver
		value: (aCascadeNode receiver accept: self).

	"As I mentioned above, I need to rewrite aCascadeNode as a sequence of regular message sends.
	For doing that I assign to each message send their missing receiver: the cascade node receiver which I just stored in the
	cascadeReceiver temporary variable."
	tracedMessageNodes := aCascadeNode messages
		collect: [ :messageNode | 
			messageNode receiver: temporaryVariableForCascadeReceiver.
			self visitMessageNodeInCascade: messageNode ].
		
	"Finally, I create a block that will cover 	aCascadeNode when it is evaluated.
	The first statement should be the assignment I created avobe to hold a reference
	to the cascade receiver that the other pase nodes used."
	tracedMessageNodes addFirst: cascadeReceiverAssignment.
	
	cascadeBlockNode := decompilerConstructor
		codeBlock: tracedMessageNodes
		returns: false. 
	
	cascadeBlockNode temporariesDeclaration: temporariesDeclarations.
	
	^ decompilerConstructor
		codeMessage: cascadeBlockNode
		selector: (encoder encodeSelector: #lines)
		arguments: {}! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16854527!
messageSendSelectorKeywordPositionsOf: aSelector ifAbsent: aBlock

	| ranges sortedRanges |

	ranges := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: [ :aMessageSendNode | aMessageSendNode keywordRanges ].

	ranges isEmpty ifTrue: [ ^aBlock lines ].
	sortedRanges := ranges asSortedCollection: [ :left :right | left first first < right first first ].

	^sortedRanges ! !
!ClassDefinitionNodeAnalyzer methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16818766!
superclass
	
	^superClassNode key lines ! !
!Switch methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16969731!
doAction: anAction 
	"Execute anAction if it is non-nil."

	anAction
		ifNotNil: [anAction lines]! !
!WebMessage methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50590855!
headerAt: key ifAbsent: aBlock
	"Answers a single value for the given http header. 
	Do not use for headers that may appear multiple times, such at www-authenticate."

	self headersAt: key do:[:value| ^value].
	^aBlock lines! !
!NotImplementedMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50449033!
typesOfVariableNamed: aVarName ifAbsent: aBlockClosure

	"I have not been compiled yet, so there is no info about parameters or temps - Hernan"
	^aBlockClosure lines! !
!True methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16999515!
ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 
	"Answer the value of trueAlternativeBlock. Execution does not 
	actually reach here because the expression is compiled in-line."

	^trueAlternativeBlock lines! !
!Trie methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16998910!
removeKey: aString ifAbsent: aBlock
	"Remove key (and its associated value) from the receiver. If key is not in 
	the receiver, answer the result of evaluating aBlock. Otherwise, answer 
	the value externally named by key."

	| answer |
	rootNode ifNil: [ ^aBlock lines ].
	answer := rootNode removeKey: aString ifAbsent: aBlock characterIndex: 1.
	rootNode isEmpty ifTrue: [
		rootNode := nil ].
	^answer! !
!FinalizationRegistry methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50334400!
finalizeEphemeron: anEphemeron
	"Finalize the ephemeron's key and remove the ephemeron from myself.
	 N.B. Here we send #finalize since finalization is called for by placing
	 objects in a FinalizationRegistry. i.e. the response to the ephemeron
	 being triggered is a property of the container of the ephemeron, not
	 the ephemeron itself."

	self removeKey: anEphemeron key ifAbsent: nil.
	
	"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
	 Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value.
	 N.B. errors here will not stall the finalization process."
	
	(anEphemeron lines ifNil: [anEphemeron key]) finalize! !
!TypeCheckerTestMethods methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50448272!
castWithBlockInRejectBlock

	nil ifNotNil: [ :temp1 | [ temp1 mod: 5 ] lines ]! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16787975!
literalScannedAs: scannedLiteral notifying: requestor
	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).
	If scannedLiteral is not an association, answer it.
	Else, if it is of the form:
		nil->#NameOfMetaclass
	answer nil->theMetaclass, if any has that name, else report an error.
	Else, if it is of the form:
		#NameOfGlobalVariable->anythiEng
	answer the global, class, or pool association with that nameE, if any, else
	add it to Undeclared a answer the new Association."

	| key value |
	(scannedLiteral isVariableBinding)
		ifFalse: [^ scannedLiteral].
	key := scannedLiteral key.
	value := scannedLiteral lines.
	key ifNil: [
		(self bindingOf: value) ifNotNil: [ :assoc |
				 (assoc lines isKindOf: Behavior)
					ifTrue: [^ nil->assoc lines class]].
		requestor notify: 'No such metaclass'.
		^false].
	key isSymbol
		ifTrue: [ "##<global var name>"
			(self bindingOf: key) ifNotNil:[ :assoc | ^assoc].
			Undeclared at: key put: nil.
			 ^Undeclared bindingOf: key].
	requestor notify: '## must be followed by a non-local variable name'.
	^false

"	Form literalScannedAs: 14 notifying: nil 14
	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm
	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form
	Form literalScannedAs: ##Form notifying: nil   Form->Form
	Form literalScannedAs: ###Form notifying: nil   nilE->Form class
"! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16862221!
nodeToExtractFrom: methodNode at: trimmedIntervalToReplace or: intervalToReplace
	
	| nodeWithRangeToExtract nodesWithFirstPosition |
	
	nodesWithFirstPosition := methodNode parseNodesPathAt: trimmedIntervalToReplace first ifAbsent: [ self signalInvalidSelection ].
	nodeWithRangeToExtract := nodesWithFirstPosition 
		detect: [ :nodeAndRange | self is: nodeAndRange lines equalTo: trimmedIntervalToReplace or: intervalToReplace ]
		ifNone: [ self signalInvalidSelection ].
	 
	^nodeWithRangeToExtract key.
	! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16808248!
methodsWithoutComments
	"Return a collection representing methods in the receiver which have no precode comments"

	| slips |
	slips := OrderedCollection new.
	self changedClasses do:
		[:aClass |
		(self methodChangesAtClass: aClass name) associationsDo: 
				[:mAssoc | (#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc lines) ifFalse:
					[(aClass selectors includes:  mAssoc key) ifTrue:
						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithoutComments) name: 'methods lacking comments'
	"! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50446525!
m1_temps_not_in_block_read_temp

	| n1 n2 t1 |

	t1 := 1.
	[t1 + 1 ] lines.

	n1 := n2 := 'hola'.
	n1 size + n2 size.

	^t1! !
!Object methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16921692!
caseOf: aBlockAssociationCollection otherwise: aBlock
	"The elements of aBlockAssociationCollection are associations between blocks.
	 Answer the evaluated value of the first association in aBlockAssociationCollection
	 whose evaluated key equals the receiver.  If no match is found, answer the result
	 of evaluating aBlock."

	aBlockAssociationCollection associationsDo:
		[:assoc | (assoc key lines = self) ifTrue: [^assoc lines lines]].
	^ aBlock lines

"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]"
"| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]"
"The following are compiled in-line:"
"#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"
"#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461368!
// anAritmethicObject

	^self lines // anAritmethicObject lines! !
!ParseNodeTypesDisplay methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50445108!
browseSelected

	| action |

	action := actions at: selectedIndex ifAbsent: [ ^self ].
	action lines! !
!MethodReference methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16907995!
sourceCodeIfAbsent: aBlock

	| actualClass |

	actualClass := self actualClassIfAbsent: [ ^aBlock lines ].
	^actualClass sourceCodeAt: methodSymbol ifAbsent: aBlock! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50539269!
isAssignmentToNonNil: aNode

	^(aNode isAssignmentNode and: [aNode variable name =  instVar]) and: [aNode lines isNilPseudoVariable not].! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16907758!
preenIfNotNilNode: messageNode preenableNodes: preenableNodes
	"Transform a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block
	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where
	 the block already declares the variable and the decompile case where it does not."

	| variable relevantNodes |
	self assert: (messageNode isMessageNode
				and: [messageNode macroPrinter == #printIfNilNotNil:indent:
				and: [messageNode receiver receiver isAssignmentNode]]).
	variable := messageNode receiver receiver variable.
	self assert: (variable isTemp and: [variable isRemote not]).
	relevantNodes := preenableNodes keys select:
						[:node| 
						node isMessageNode
						and: [messageNode macroPrinter == #printIfNilNotNil:indent:]].
	(variable isLocalToBlocksInIfNilIfNotNilNodes: relevantNodes in: self) ifFalse:
		[messageNode arguments do:
			[:argBlock|
			(argBlock arguments size = 1
			and: [argBlock firstArgument = variable]) ifTrue:
				[argBlock arguments: #()]].
		 variable beTemp.
		 ^self].
	messageNode arguments last arguments isEmpty
		ifTrue: [messageNode arguments last arguments: { variable }]
		ifFalse:
			[self assert: messageNode arguments last arguments asArray = { variable }.
			 variable := nil].
	messageNode receiver receiver: messageNode receiver receiver lines.
	(temporaries includes: variable) ifTrue: "can't use removeAtIndex: cuz temporaries could be an Array"
		[temporaries := temporaries copyWithout: variable].
	variable ifNil: [^self].
	self nodesDo:
		[:node|
		((node == self or: [node isBlockNode])
		 and: [node temporaries anySatisfy: [:temp| temp = variable]]) ifTrue:
			[node temporaries: (node temporaries reject: [:temp| temp = variable])]]! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16899202!
sizeCodeForValue: encoder
	self reserve: encoder.
	(key isVariableBinding and: [key isSpecialReadBinding]) 
		ifFalse:
			[^encoder sizePushLiteralVar: index].
	readNode := MessageNode new 
		receiver: (encoder encodeLiteral: key)
		selector: (encoder encodeSelector: #lines)
		arguments: #()
		precedence: #lines precedence.
	^readNode sizeCodeForValue: encoder! !
!Time class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16996657!
millisecondsToRun: timedBlock 
	"Answer the number of milliseconds timedBlock takes to return its value."

	| initialMilliseconds |
	initialMilliseconds := self localMillisecondClock.
	timedBlock lines.
	^self localMillisecondClock - initialMilliseconds! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16883126!
declareTemporaries: temporariesToDeclare in: aMethodOrBlockNode of: aSenderMethod

	| positionToInsertNewVariablesDeclarations renamedTemporaries temporariesToDeclareInPosition|

	renamedTemporaries := self renameTemporariesIfNeeded: temporariesToDeclare accordingToNode: aMethodOrBlockNode of: aSenderMethod.

	aMethodOrBlockNode hasTemporaryVariables
		ifTrue: [
			positionToInsertNewVariablesDeclarations := (aSenderMethod notOptimizedMethodNode
				singleCompleteSourceRangeOf: (aMethodOrBlockNode temporariesDeclaration)) last.
		]
		ifFalse: [
			| firstStatementRange |
			firstStatementRange := aSenderMethod notOptimizedMethodNode singleCompleteSourceRangeOf: (aMethodOrBlockNode statements first).
			positionToInsertNewVariablesDeclarations := firstStatementRange first.
		].
	temporariesToDeclareInPosition := self temporariesToDeclareByInsertionPoint: (aSenderMethod -> positionToInsertNewVariablesDeclarations).
	temporariesToDeclareInPosition addAll: (renamedTemporaries collect: [:aReplacementAssociation | aReplacementAssociation lines]).
	^renamedTemporaries.
	! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16799678!
runSystemCategoryTests
	
	selectedSystemCategory ifNotNil: [ | suite |
		suite := TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer.
		(ProgressiveTestRunner for: suite) lines ]
	
	! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16906494!
removeDangerouslyKey: key ifAbsent: aBlock
	"This is not really dangerous.  But if normal removal
	were done WHILE a MethodDict were being used, the
	system might crash.  So instead we make a copy, then do
	this operation (which is NOT dangerous in a copy that is
	not being used), and then use the copy after the removal."

	| index element |
	index := self findElementOrNil: key.
	(self basicAt: index) ifNil: [ ^ aBlock lines ].
	element := array at: index.
	array at: index put: nil.
	self basicAt: index put: nil.
	tally := tally - 1.
	self fixCollisionsFrom: index.
	^ element! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16883702!
sourceCodeOfImplementorStatement: aStatementToInline withReplacements: replacementsDict removingReturn: removeReturn

	| sourceRange originalSourceCode statementReplacements implementorSourceCode |

	implementorSourceCode := methodToInline sourceCode.
	sourceRange := (self findRangesOf: aStatementToInline in: implementorCompleteSourceRanges) anyOne
		asSourceCodeInterval expandUntilStatementEndOn: implementorSourceCode.
	originalSourceCode := implementorSourceCode copyFrom: sourceRange first to: sourceRange last.
	"Replacements must be adjusted because the statement string begins at index 1 instead of the
	original position on the source code"
	statementReplacements := ((replacementsDict associations select: [:anAssociation | sourceRange includesAllOf: (anAssociation key)])
		collect: [:anAssociation | ((anAssociation key first - sourceRange first + 1) to: (anAssociation key last - sourceRange first + 1)) -> anAssociation lines])
		asSortedCollection: [ :left :right | left key first < right key first ].

	"Remove the return character if present"
	(removeReturn and: [aStatementToInline isReturn]) ifTrue: [statementReplacements add: (1 to: 1) -> ''].
	^(originalSourceCode copyReplacing: statementReplacements).! !
!InnerListMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50334772!
rowAtLocation: aPoint ifNone: aNoneBlock

	| potentialRowNumber |
	
	potentialRowNumber := aPoint y // font lineSpacing + 1.
	
	^(listItems isInBounds: potentialRowNumber) 
		ifTrue: [ potentialRowNumber ]
		ifFalse: [ aNoneBlock lines ]! !
!UniFileStream class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 17001952!
retryWithGC: execBlock until: testBlock forFileNamed: fullName
	"Re-implemented to only force GC if a file with the given name exists"
	| blockValue foundIt |
	blockValue := execBlock lines.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	"See if we have a file with the given name"
	foundIt := self registry keys "hold on strongly for now" 
		anySatisfy:[:file| file name sameAs: fullName].
	foundIt ifFalse:[^blockValue].
	Smalltalk garbageCollectMost.
	blockValue := execBlock lines.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollect.
	^execBlock lines.! !
!TTCompositeGlyph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16980889!
addContourDataTo: stream tx: aGeometryTransformationOrNil
	| glyph tx |
	glyphs do: [ :txAndGlyph |
		tx := txAndGlyph key.
		aGeometryTransformationOrNil notNil ifTrue: [
			tx := aGeometryTransformationOrNil composedWith: tx ].
		glyph := txAndGlyph lines.
		glyph addContourDataTo: stream tx: tx ]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50504532!
block
	
	[ 1 ] lines! !
!True methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16999497!
and: aBlock1 and: aBlock2 and: aBlock3 and: aBlock4

	"I sending value to aBlock4 to optimize the generated byte-code - Hernan"
	^aBlock1 lines and: [ aBlock2 lines and: [ aBlock3 lines and: [ aBlock4 lines ]]] ! !
!CodeCoverageSourceCodeGenerator methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50502639!
parseNodeToCoverAll: sourceRanges whenExecutingMessageNode: aMessageNode

	"Generate a parse node that, when compiled and executed, will register that aMessageNode covered sourceRanges
	in the selector and class of methodNode.
	
	Implementation Details
	================
	
	For tracking code coverage in this case I send the CompiledMethodCoverageTracker>>#coverAll:evaluating:thatSends:to: message
	passing as collaborators:
	
	1) the source ranges to be covered when the message is sent
	2) a block that captures the message to be sent and its context
	3) the selector
	4) the message receiver
	
	Notice that in this rewrite the message receiver is referenced twice:
	- one inside the block in 2) to actually send the message and 
	- one in 4) so the message receiver can be passed to the method that tracks the coverage
	
	To avoid changing the semantics of aMessageNode, I make sure to reference aMessageNode receiver only once
	and store it in a temp variable. If I dont do this (say I reference it more than once) then the semantics might be changed.
	
	For instance, consider the following message send: (Set new) add: 1.
	If I use the message receiver more than once, then the code coverage message send will look something like this
	(important: for this example, the code has been simplified - this is not how the generated code will look like):

	nameOfTheCodeCoverageTrackerInstance
		coverAll: ...source ranges here....
		evaluating: [ (Set new) add: 1 ]
		thatSends: #add:
		to: Set new
		
	Notice that Set new is referenced twice, so a new receiver (and not the original) is passed to the method that tracks the coverage.
	
	To fix this, I rewrite the code to make it look like this
	[
		|receiver|
	 	receiver := Set new.
		
		nameOfTheCodeCoverageTrackerInstance
		coverAll: ...source ranges here....
		evaluating: [ receiver add: 1 ]
		thatSends: #add:
		to: receiver
	] value

	Notice that the receiver temporary has been introduced to reference aMessageNode receiver only once.
	"
	
	| receiverTemp blockAssigningTheMessageReceiverTemp receiverTempAssignment codeCoverageTrackingNode receiverTempDeclaration |
	"Increment the number of source range traced by the number of source ranges aMessageNode will cover when executed"
	tracedSourceRanges addAll: sourceRanges.
	
	aMessageNode originalReceiver isSuperPseudoVariable ifTrue: [
		"Special case.
		Because this is a super send, I cannot rewrite the message send like I mentioned in the comment avobe.
		Doing that would change the semantics of aMessageNode.
		For instance, if the message send is: super printString:
		
		[
			|receiver|
		 	receiver := super.
		
			nameOfTheCodeCoverageTrackerInstance
			coverAll: ...source ranges here....
			evaluating: [ receiver printString ]
			thatSends: #printString
			to: receiver
		] value
		
		Notice that, If I do this, then receiver will hold a reference to self and the message will be sent to self instead of super.
		
		In this case it is safe to reference the message receiver more than once (because it is self), so I dont do that rewrite.
		"
		^ self
			parseNodeToSendToCodeCoverageTracker: #coverAll:evaluating:thatSends:to:
			withAll: {
				self parseNodeForRanges: sourceRanges.
				decompilerConstructor codeBlock: { aMessageNode } returns: false.
				encoder encodeLiteral: aMessageNode selector key.
				aMessageNode originalReceiver.
			} ].
	
	
	"General case. rewrite the message send as mentioned in my comment avobe"
	
	"Assign the receiver to a new temporary variable"
	receiverTemp := self parseNodeForStoringMessageReceiver.
	receiverTempAssignment := decompilerConstructor codeAssignTo: receiverTemp value: aMessageNode receiver.
	
	"Change the message receiver to be that temporary variable"
	aMessageNode receiver: receiverTemp.
	
	"Create the parse node that will track the code coverage for aMessageNode.
	Notice it references receiverTemp."	
	codeCoverageTrackingNode := self
		parseNodeToSendToCodeCoverageTracker: #coverAll:evaluating:thatSends:to:
		withAll: {
			self parseNodeForRanges: sourceRanges.
			decompilerConstructor codeBlock: { aMessageNode }  returns: false.
			encoder encodeLiteral: aMessageNode selector key.
			receiverTemp.
		}.
		
	"Create the block that actually assigns the aMessageNode receiver to receiverTemp and evaluates codeCoverageTrackingNode"
	receiverTempDeclaration := TemporariesDeclarationNode withAll:{ TemporaryDeclarationNode of: receiverTemp }.
	blockAssigningTheMessageReceiverTemp := decompilerConstructor codeBlock: { receiverTempAssignment. codeCoverageTrackingNode }  returns: false.
	blockAssigningTheMessageReceiverTemp temporariesDeclaration: receiverTempDeclaration.
	
	"Create the message send node that will evaluate the block created avobe."
	^ decompilerConstructor
		codeMessage: blockAssigningTheMessageReceiverTemp
		selector: (encoder encodeSelector: #lines)
		arguments: {}! !
!NewInstanceVariablePrecondition class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16919024!
valueOf: anInstanceVariableName for: aClass

	^(self of: anInstanceVariableName for: aClass) lines! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16793716!
valueWithin: aDuration onTimeout: timeoutBlock
	"Evaluate the receiver.
	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"

	| theProcess delay watchdog tag |

	aDuration <= `Duration zero` ifTrue: [^ timeoutBlock lines ].

	"the block will be executed in the current process"
	theProcess := Processor activeProcess.
	delay := aDuration asDelay.
	tag := self.

	"make a watchdog process"
	watchdog := [
		delay wait. 	"wait for timeout or completion"
		theProcess ifNotNil:[ theProcess signalException: (TimedOut new tag: tag)] 
	] newProcess.

	"Watchdog needs to run at high priority to do its job (but not at timing priority)"
	watchdog priority: Processor timingPriority-1.

	"catch the timeout signal"
	^ [	watchdog resume.				"start up the watchdog"
		self ensure:[						"evaluate the receiver"
			theProcess := nil.				"it has completed, so ..."
			delay delaySemaphore signal.	"arrange for the watchdog to exit"
		]] on: TimedOut do: [ :e | 
			e tag == tag 
				ifTrue:[ timeoutBlock lines ]
				ifFalse:[ e pass]].! !
!PushUpMethodApplier methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16942672!
withEquivalentMethodsMessage: withEquivalentMethod

	^ String streamContents: [ :stream |		
		withEquivalentMethod associationsDo: [:assoc |
			stream
				nextPutAll: assoc key selector;
				nextPutAll: ' has equivalent methods declared in ';
				nextPutAll: assoc lines asCommaStringAnd;
				newLine.
		].
		stream nextPutAll: 'How do you want to proceed?' ].! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50400635!
testSample05
	| blockClosure materialized |
	blockClosure _ self bc05.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure lines = materialized lines.
	self assert: blockClosure lines = materialized lines.
	self assert: blockClosure lines = materialized lines.! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50504566!
blockWithReadTemporaryVariable

	[ |a| a ] lines! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50599446!
test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary
	| account1 account2 accountSummary transfer |
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account1.
	Withdraw register: 50 on: account1.
	transfer := Transfer register: 50 from: account2 to: account1.
	accountSummary := AccountSummary on: account1.
	
	self assert: (accountSummary lines = ('Dposito por 50' , 'Extraccin por 50' , 'Salida por transferencia por 0' , 'Entrada por transferencia por 50' , 'Balance = 50'))! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16984420!
assert: anAction changes: aCondition from: anInitialObject to: aFinalObject 

	| after before |
	
	before := aCondition lines.
	anAction lines.
	after := aCondition lines.
	
	self assert: before equals: anInitialObject.
	self assert: after equals: aFinalObject! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50426694!
test10FindsRepetitionsWithBrace

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 {1 . 2 }. {1 . 2 }'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 11) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 11) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (14 to: 21) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16854607!
positionsForLiteralNode: aName ifAbsent: aBlock

	| variableNode |

	variableNode := litSet at: aName ifAbsent: [ ^aBlock lines ].

	^sourceRanges at: variableNode ifAbsent: aBlock! !
!IfNilChecksFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50547088!
test12WhenThereAreIfNilChecksInMultipleMethodsTheResultIncludesAllOfThem

	| contextClass result sourcem1 sourcem2 |

	contextClass := self createClassNamed: #ContextClass instanceVariableNames: self instVar.

	sourcem1 := 'm1 ', self instVar, ' ifNil: [1 + 1]'.
	contextClass compile: sourcem1.
	sourcem2 := 'm2 ', self instVar, ' ifNil: [2 + 2]'.
	contextClass compile: sourcem2.

	result := (IfNilChecksFinder on: contextClass for: self instVar) lines.

	self assert: 2 equals: result size.
	self assert: #m1 equals: result first methodNode selector.
	self assert: #m2 equals: result second methodNode selector.! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50446579!
m4_many_temps_in_remote_vector

	| t1 t2 t3 |

	[ t1 := 1 ] lines.
	[ t2 := 'hello' ] lines.

	t3 := t1 + t2 size.

	^t3! !
!Trie methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16998857!
at: aString ifAbsent: aBlock

	rootNode ifNil: [ ^aBlock lines ].
	^ rootNode at: aString ifAbsent: aBlock characterIndex: 1! !
!Process methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16937840!
environmentRemoveKey: key ifAbsent: errorBlock
	
	^(env ifNil: [ ^errorBlock lines ]) removeKey: key ifAbsent: errorBlock! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461451!
= anObject

	^self lines = anObject lines! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50505053!
value

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super lines! !
!WebMessage methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50590903!
headersDo: aBlock
	"Evaluate aBlock with all of the headers key-value pairs"

	headers do:[:assoc|
		aBlock value: assoc key value: assoc lines.
	].! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50598973!
initializeFor: anAccount on: aTransference
	(anAccount isKindOf: ReceptiveAccount ) ifFalse: 
	[self error: self class errorTransferenceSenderOrReceiverShouldBeAReceptiveAccount ].
	deposit := Deposit register: (aTransference lines) on: anAccount.
	transference := aTransference ! !
!BlockClosure methodsFor: 'as yet unclassified' library: #MinimalKernel01 stamp: 'BSN 11/7/2025 14:58:19' prior: 50368188!
ensure: aBlock
	"Evaluate a termination block after evaluating the receiver, regardless of
	 whether the receiver's evaluation completes.  N.B.  This method is *not*
	 implemented as a primitive.  Primitive 198 always fails.  The VM uses prim
	 198 in a context's method as the mark for an ensure:/ifCurtailed: activation."

	| complete returnValue |
	<primitive: 198>
	returnValue := self valueNoContextSwitch.
	complete ifNil:[
		complete := true.
		aBlock lines.
	].
	^ returnValue! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461334!
oddInBaseUnit
	
	^self lines oddInBaseUnit ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461380!
negated
	
	^self lines negated! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50504653!
emptyBlock
	
	[] lines! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16808220!
methodsWithInitialsOtherThan: myInits
	"Return a collection of method refs whose author appears to be different from the given one"
	| slips |
	slips := OrderedCollection new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |
				(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc lines) ifFalse: [
					method := aClass compiledMethodAt: mAssoc key ifAbsent: nil.
					method ifNotNil: [ | aTimeStamp |
						((aTimeStamp := method timeStamp) notNil and: [
							(aTimeStamp beginsWith: myInits) not])
								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'
	"! !
!NewTemporaryPrecondition class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16919356!
valueFor: aNewTemporaryVariableName in: aBlockNode of: aMethodNode

	^ (self for: aNewTemporaryVariableName in: aBlockNode of: aMethodNode) lines! !
!Process methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50337602!
evaluate: aBlock onBehalfOf: aProcess
	"Evaluate aBlock setting effectiveProcess to aProcess.
	Needed so #effectiveProcess gives the correct answer.
	See senders."

	| oldEffectiveProcess |
	aProcess == self ifTrue: [^ aBlock lines]. "Optimization"
	
	oldEffectiveProcess := self environmentAt: #effectiveProcess ifAbsent: nil.
	self environmentAt: #effectiveProcess put: aProcess.
	^ aBlock ensure: [
		oldEffectiveProcess
			ifNotNil: [ self environmentAt: #effectiveProcess put: oldEffectiveProcess]
			ifNil: [ self environmentRemoveKey: #effectiveProcess ifAbsent: nil ]]! !
!Dictionary methodsFor: 'as yet unclassified' library: #MinimalKernel04HashedCollections stamp: 'BSN 11/7/2025 14:58:19' prior: 50371811!
at: key ifAbsent: absentBlock
	"Answer the value associated with the key or, if key isn't found,
	answer the result of evaluating aBlock."

	| assoc |
	assoc := array at: (self findElementOrNil: key).
	assoc ifNil: [ ^ absentBlock lines ].
	^ assoc lines! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16883163!
declareTemporaries: temporariesToDeclare inBlockOf: aMessageNodeReference

	| methodOrBlockNodeDeclaringNewVariables renamedTemporaries replacements |

	methodOrBlockNodeDeclaringNewVariables := self enclosingBlockOf: aMessageNodeReference.
	renamedTemporaries := self declareTemporaries: temporariesToDeclare in: methodOrBlockNodeDeclaringNewVariables of: aMessageNodeReference compiledMethod.

	replacements := self replacementsMapForMessageSend: aMessageNodeReference .
	renamedTemporaries do: [:oldVariableAndNewName |
			(self findRangesOf: oldVariableAndNewName key in: implementorCompleteSourceRanges) do: [:range |
				replacements at: range put: oldVariableAndNewName lines.
			]
	]
	! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16949809!
error
	self 
		rangeType: #excessCode
		start: (ranges isEmpty ifTrue: [1] ifFalse: [ranges last end + 1])
		end: source size.
	errorBlock lines! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50539397!
replaceIvarWithNilIfNullObject

	replacementParameters do: [:replacementParameter | | refactoredSource  finder methodNode |
		methodNode := replacementParameter methodNode.
		finder := ArgumentsAndReturnsFinder in: methodNode for: instVar.
		finder lines.	
		refactoredSource := replacementParameter methodSourceCode copyReplacing: finder ranges with: instVar, ' nilIfNullObject'.
		methodNode methodClass compile: refactoredSource]! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16909769!
critical: aBlock
	"Critical section.
	Executes aBlock as a critical section. At any time, only one process can be executing code 
	in a critical section.
	NOTE: All the following synchronization operations are only valid inside the critical section 
	of the monitor!!"

	^[
	self enter.
	aBlock lines]
		ensure: [self exit].! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50400607!
testSample02
	| blockClosure materialized |
	blockClosure _ self bc02.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure lines = materialized lines.! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50504598!
cascadeNodeWithBlockReceiverThatIsEvaluated

	[ self lines ]
		class;
		lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461324!
isNothing

	^self lines isNothing! !
!Socket methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50585496!
waitForConnectionFor: timeout ifTimedOut: timeoutBlock ifRefused: refusedBlock
	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."

	| deadline timeLeft status |
	deadline := Time millisecondClockValue + (timeout * 1000) truncated.
	(status := self primSocketConnectionStatus: socketHandle) == Connected ifTrue: [^true].
	[ (status == WaitingForConnection) and: [ (timeLeft := deadline - Time millisecondClockValue) > 0 ] ]
		whileTrue: [
			semaphore waitTimeoutMSecs: timeLeft.
			status := self primSocketConnectionStatus: socketHandle ].
	status == Connected ifTrue: [ ^true ].
	status == WaitingForConnection 
		ifTrue: [ timeoutBlock lines ]
		ifFalse: [ refusedBlock lines ].
	^false! !
!IfNilChecksFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50547110!
test13WhenThereAreMultipleIfNilChecksInTheSameMethodWithTheSameCodeTheResultIncludesAllOfThem

	| contextClass anIfNilCheckStatement methodHeader source result firstIfNilIndex |

	contextClass := self createClassNamed: #ContextClass instanceVariableNames: self instVar.

	methodHeader := 'm1 '.
	anIfNilCheckStatement := self instVar, ' ifNil: [1 + 1].'.
	source := methodHeader, anIfNilCheckStatement, anIfNilCheckStatement.
	contextClass compile: source.

	result := (IfNilChecksFinder on: contextClass for: self instVar) lines.

	self assert: 2 equals: result size.
	firstIfNilIndex := source findString: 'ifNil'.
	self assert: (source findString: 'ifNil' startingAt: firstIfNilIndex + 1) equals: result first messageNodeIndex.
	self assert: #m1 equals: result first methodNode selector.
	self assert: firstIfNilIndex equals: result second messageNodeIndex.
	self assert: #m1 equals: result second methodNode selector.
	! !
!MethodVariableTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50452492!
methodWithParameterOfClassToRemove: p1

	| tempNotInRemoteVector tempInRemoteVector |

	tempNotInRemoteVector := p1.
	[ tempInRemoteVector := p1 ] lines.

	^10! !
!InlineTemporaryVariableApplier class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16886105!
on: anEditor for: aSelectionInterval of: aMethodToRefactor

	| noTempFoundBlock tempToInline usageInterval |

	noTempFoundBlock := [
		"This case will usually end in a failure because a temporary variable is not related to the selected interval"
		tempToInline := anEditor wordAt: aSelectionInterval first.
		usageInterval := aSelectionInterval.
	].

	anEditor
		withNodeUnderCursorDo: [:aNode | | methodNode sourceRanges |
			methodNode := aMethodToRefactor notOptimizedMethodNode.
			sourceRanges := methodNode completeSourceRanges.
			(aNode isVariableNode and: [methodNode argumentNames noneSatisfy: [:argument | argument = aNode name]])
				ifTrue: [
					tempToInline := aNode name.
					usageInterval := self findSourceRangeOfNode: aNode containingIndex: anEditor startIndex using: sourceRanges.
				]
				ifFalse: [ | assignmentNodeAndRange |
					assignmentNodeAndRange := self searchAssignmentInStatementContaining: aSelectionInterval first
						in: methodNode.
					assignmentNodeAndRange 	ifNil: [noTempFoundBlock lines].
					tempToInline ifNil: [
						tempToInline := assignmentNodeAndRange key variable name.
						usageInterval := self findLeftmostSourceRangeOfNode: assignmentNodeAndRange key variable
							inside: assignmentNodeAndRange lines using: sourceRanges.
					]
				]
		]
		ifAbsent: [
			noTempFoundBlock lines.
		].

	^self new initializeOn: anEditor codeProvider forTemporary: tempToInline
		at: usageInterval of: aMethodToRefactor ! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50426812!
test14FindsRepetitionsOfLiteralVariable

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 Array. Array new'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 8) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 8) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (11 to: 15) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!CodeForNodeToMove methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50532200!
newSenderFor: aMessageNode
	|  newSend argumentsCode argumentIndex replacer replacerResult argumentNode |
	argumentsCode := OrderedCollection new.
	argumentIndex := 1.
	"self halt."
	aMessageNode selector key keywords do: [ :aKeyword | 
		argumentNode := aMessageNode argumentsInEvaluationOrder at: argumentIndex.
		replacer := CodeForNodeToMove 
					methodNode: methodNode
					variableToAcessThrough: variableToAccesThrough
					onNode: argumentNode
					parameterNeeded: parameterNeeded
					targetClass: targetClass.
		replacerResult := replacer lines.
		(self shouldAddParenthesis: argumentNode) 
			ifTrue: [argumentsCode add: '(', replacerResult sourceCode, ')'.]
			ifFalse: [argumentsCode add: replacerResult sourceCode.].
		methodToCompileOnSourceClass addAll: replacerResult methodToCompileOnSourceClass.
		argumentIndex := argumentIndex +1].
	argumentIndex := 1.
	newSend := ''.
	aMessageNode selector key keywords do: [ :aKeyword | newSend := newSend, ' ', aKeyword, ' ', (argumentsCode at: argumentIndex). argumentIndex := argumentIndex +1].
	^parameterNeeded parameterName, ' CHANGE_ME_super_', (newSend copyFrom: 2 to: newSend size).
! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16883804!
findOutermostStatementContaining: aMessageNodeReference enclosedBy: enclosingBlock ifFound: ifFoundBlock ifNone: ifNoneBlock

	| usageNodesPath isDifferentMessageNode isIncludedInBlock |

	usageNodesPath := aMessageNodeReference methodNode parseNodesPathAt: aMessageNodeReference completeSourceRange first
		ifAbsent: [self shouldNotHappen].
	isDifferentMessageNode := [:aNode | aNode isMessageNode and: [(aNode equivalentTo: aMessageNodeReference messageNode) not]].
	isIncludedInBlock := [:aRange | |sourceRangeOfEnclosingBlock |
		sourceRangeOfEnclosingBlock := enclosingBlock isBlockNode
			ifTrue: [self findSourceRangeOf: enclosingBlock in: aMessageNodeReference compiledMethod.]
			ifFalse: [(1 to: aMessageNodeReference compiledMethod sourceCode size)].
		sourceRangeOfEnclosingBlock includesAllOf: aRange.
	].
	usageNodesPath reversed
		detect: [:aNodeAndRange | | node range |
			node := aNodeAndRange key.
			range := aNodeAndRange lines.
			((node isAssignmentNode or: [isDifferentMessageNode value: node]) and: [isIncludedInBlock value: range])
		]
		ifFound: [:aNodeAndRange | ^ifFoundBlock value: aNodeAndRange]
		ifNone: [^ifNoneBlock lines].




	! !
!BoxMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16796958!
basicAdjustExtentFor: aBlock
	"Ensure extent is at least minimumExtent.
	This may mean do the same with owner.
	See implementors. See senders."

	| forceMinimumExtent |
	forceMinimumExtent := extent = self minimumExtent.
	aBlock lines.
	self morphExtent: (forceMinimumExtent ifTrue: [`0@0`] ifFalse: [extent]).! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 17000751!
whichClassDefinesInstanceVariable: aVariable ifNone: aNoneBlock

	^aNoneBlock lines! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16854000!
unusedTempNames
	| unused |
	unused := OrderedCollection new.
	scopeTable associationsDo:
		[:assn | | name |
		(assn lines isUnusedTemp) ifTrue:
			[name := assn lines key.
			 name ~= Encoder doItInContextName ifTrue: [unused add: name]]].
	^ unused! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 17000610!
ifNil: nilBlock ifNotNil: ifNotNilBlock
	"Evaluate the block for nil because I'm == nil"

	^ nilBlock lines! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50400647!
testSample06
	| blockClosures materialized firstRun |

	blockClosures _ self bc06.
	firstRun _ blockClosures second lines.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first lines = materialized first lines.
	self assert: blockClosures second lines = materialized second lines.
	self assert: blockClosures third lines = materialized third lines.
	self assert: blockClosures first lines = materialized first lines.
	self assert: firstRun = materialized second lines.
	self deny: blockClosures second lines = materialized second lines.

	blockClosures _ self bc06.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first lines = materialized first lines.
	self assert: blockClosures second lines = materialized second lines.
	self assert: blockClosures third lines = materialized third lines.
	self assert: blockClosures first lines = materialized first lines.
	self deny: firstRun = materialized second lines.
	self assert: blockClosures second lines = materialized second lines.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461641!
composeWith: aMeasure

	^self lines composeWith: aMeasure! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16786463!
addAll: aCollection
	"Refer to the comment in Collection|addAll:."

	(aCollection is: #Bag) ifFalse: [^ super addAll: aCollection].
	aCollection contents associationsDo: [ :each |
		self add: each key withOccurrences: each lines].
	^ aCollection! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16955645!
indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock
	"Answer the index of the receiver's first element, such that that element 
	equals the first element of sub, and the next elements equal 
	the rest of the elements of sub. Begin the search at element 
	start of the receiver. If no such match is found, answer the result of 
	evaluating argument, exceptionBlock."
	| first index |
	sub isEmpty ifTrue: [^ exceptionBlock lines].
	first := sub first.
	start to: self size - sub size + 1 do:
		[:startIndex |
		(self at: startIndex) = first ifTrue:
			[index := 1.
			[(self at: startIndex+index-1) = (sub at: index)]
				whileTrue:
				[index = sub size ifTrue: [^startIndex].
				index := index+1]]].
	^ exceptionBlock lines! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16793466!
whileFalse: aBlock 
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the argument, aBlock, as long as the value of the receiver is false."

	^ [self lines] whileFalse: [aBlock lines]! !
!ParseNodeVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16927050!
visitAssignmentNode: anAssignmentNode
	"N.B.  since assigment happens after the value is evaluated the value is visited first."
	anAssignmentNode lines accept: self.
	anAssignmentNode variable accept: self! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16883274!
declaredTemporariesFor: aParseNode ofSender: aSender

	^temporariesDeclarationsByNode keys
		detect: [:senderAndNode | senderAndNode key = aSender and: [senderAndNode lines equivalentTo: aParseNode]]
		ifFound: [ :key | temporariesDeclarationsByNode at: key]
		ifNone: [| temporariesAndArgsDict |

			temporariesAndArgsDict := self temporariesAndArgsInScopeOf: aParseNode ofSender: aSender.
			temporariesDeclarationsByNode at: (aSender -> aParseNode) put: temporariesAndArgsDict.
			temporariesAndArgsDict].


	! !
!ReplaceIfNilWithPolymorphismParameters methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50534118!
rangesOfVariablesToParametrizeToReplacingParameterWith: aMapping

	| rangeToReplacementParameter |

	rangeToReplacementParameter := SortedCollection sortBlock: [:rangeToStringA :rangeToStringB | rangeToStringA key first < rangeToStringB key first].
	self variablesToParametrize do: [:aVariableName | 
		self addAllRangesOf: aVariableName to: rangeToReplacementParameter usingAsReplacement: (self parameterNameFor: aVariableName)].
	
	self addAllRangesOf: aMapping key to: rangeToReplacementParameter usingAsReplacement: aMapping lines.

	^rangeToReplacementParameter
! !
!Socket methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50585433!
sendStreamContents: stream checkBlock: checkBlock
	"Send the data in the stream. Close the stream after you are done. After each block of data evaluate checkBlock and abort if it returns false.
	Usefull for directly sending contents of a file without reading into memory first."
	[
	| chunkSize buffer |
	chunkSize := 5000.
	buffer := ByteArray new: chunkSize.
	stream binary.
	[stream atEnd and: [checkBlock lines]]
		whileFalse: [
			buffer := stream next: chunkSize into: buffer.
			self sendData: buffer]]
		ensure: [stream close]! !
!Dictionary methodsFor: 'as yet unclassified' library: #MinimalKernel04HashedCollections stamp: 'BSN 11/7/2025 14:58:19' prior: 50371783!
associationAt: key ifAbsent: aBlock 
	"Answer the association with the given key.
	If key is not found, return the result of evaluating aBlock."

	| index assoc |
	index := self findElementOrNil: key.
	assoc := array at: index.
	nil == assoc ifTrue: [ ^ aBlock lines ].
	^ assoc! !
!Dictionary methodsFor: 'as yet unclassified' library: #MinimalKernel04HashedCollections stamp: 'BSN 11/7/2025 14:58:19' prior: 50388961!
= aDictionary
	"Two dictionaries are equal if
	 (a) they are the same 'kind' of thing.
	 (b) they have the same set of keys.
	 (c) for each (common) key, they have the same value"

	self == aDictionary ifTrue: [^ true].	"Any object is equal to itself"
	(aDictionary is: #Dictionary) ifFalse: [^false].
	self size = aDictionary size ifFalse: [^false].
	self associationsDo: [:assoc|
		(aDictionary at: assoc key ifAbsent: [^false]) = assoc lines
			ifFalse: [^false]].
	^true

! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16906367!
keyAtValue: value ifAbsent: exceptionBlock
	"Answer the key whose value equals the argument, value. If there is
	none, answer the result of evaluating exceptionBlock."

	1 to: self basicSize do:
		[:index |
		value = (array at: index)
			ifTrue: [
				(self basicAt: index)
					ifNotNil: [ :theKey | ^ theKey]]].
	^ exceptionBlock lines! !
!Set methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16957684!
remove: oldObject ifAbsent: aBlock

	| index |
	index := self findElementOrNil: oldObject.
	(array at: index) ifNil: [ ^ aBlock lines ].
	array at: index put: nil.
	tally := tally - 1.
	self fixCollisionsFrom: index.
	^ oldObject! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16786636!
sum: aBlock ifEmpty: emptyBlockOrValue
	| answer |
	self isEmpty ifTrue: [^ emptyBlockOrValue lines].
	self withOccurrencesDo: [ :each :times | | v |
		v := aBlock value: each.
		answer := answer isNil
			ifTrue: [v * times]
			ifFalse: [v * times + answer]].
	^ answer! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50493926!
createSuperclassOf: aDenotativeObject onCancel: aBlock

	| denotativeObjectParent categoryName superclass superclassName |
	
	denotativeObjectParent := aDenotativeObject parentIfNone: [ ^Object ].
	
	superclassName := ClassNameRequestMorph request: 'Class for ', denotativeObjectParent name orCancel: [ ^aBlock lines ].
	(Smalltalk classNamed: superclassName) ifNotNil: [ :alreadyExistingSuperclass |
		(PopUpMenu 
			confirm: superclassName, ' already exist. Do you want to recreate or reuse it?' 
			trueChoice: 'Recreate it' 
			falseChoice: 'Reuse it') ifFalse: [ ^alreadyExistingSuperclass ]].
		
	categoryName := StringRequestMorph 
		request: 'Enter category name' 
		initialAnswer: denotativeObjectParent category 
		orCancel: [ ^aBlock lines ].	
		
	superclass := self createSuperclassOf: denotativeObjectParent onCancel: aBlock.
	
	^denotativeObjectParent createClassNamed: superclassName asSymbol subclassOf: superclass category: categoryName! !
!String methodsFor: 'as yet unclassified' library: #MinimalKernel01 stamp: 'BSN 11/7/2025 14:58:19' prior: 50366688!
indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| ans |
	aCharacter isCharacter ifFalse: [ ^ aBlock lines ].
	"String can only hold ASCII + Latin1"
	aCharacter codePoint >255 ifTrue: [ ^ aBlock lines ].
	ans := ByteArray indexOfByte: aCharacter codePoint inBytes: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock lines ]
		ifFalse: [ ans ]! !
!CodeForNodeOnMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50531524!
visitAssignmentNode: anAssignmentNode 
	| rangesOfassigmentNode assigmentValue newAssignmentCode newCodeForValue nodeReplacer resultForValue |

	anAssignmentNode variable name = instanceVariableName ifFalse: [anAssignmentNode lines accept: self. ^self].
	
	rangesOfassigmentNode := self firstUnseenIntervalFor: anAssignmentNode.
	nodeReplacer := CodeForNodeOnMethod 
					replace: instanceVariableName 
					onMethod: compiledMethod 
					accessingThrough: instVarNameTargetClass 
					usingGetter: getterToUse
					usingSetter: setterToUse
					for: anAssignmentNode lines 
					rejectingIntervals: intervalsToReject.
	resultForValue :=			nodeReplacer lines.
	newCodeForValue := resultForValue resultCode .
	(self shouldAddParenthesisOnValueOf: anAssignmentNode)
		ifTrue: [assigmentValue := '(', newCodeForValue, ')'.] 
		ifFalse: [assigmentValue := newCodeForValue.].
	newAssignmentCode := instVarNameTargetClass, ' ', setterToUse, ' ', assigmentValue.
	self registerInterval: rangesOfassigmentNode withModification: newAssignmentCode.
	modifiedWrites := modifiedWrites + 1.
	modifiedReads := modifiedReads + resultForValue modifiedReads.! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50454599!
test02ClassesCanBeTypeChecked

	| typeChecker typeCheckers |

	typeChecker := MethodTypeCheckerTest typeCheck.

	typeChecker lines.

	typeCheckers := MethodTypeCheckerTest selectors collect: [ :aSelector |  (MethodTypeCheckerTest >> aSelector) typeCheck].
	typeCheckers := typeCheckers, (MethodTypeCheckerTest class selectors collect: [ :aSelector | (MethodTypeCheckerTest >> aSelector) typeCheck ]).

	self assert: typeChecker errorsSize equals: (typeCheckers sum: [ :aTypeCheker | aTypeCheker errorsSize ]).
	self assert: typeChecker warningsSize equals: (typeCheckers sum: [ :aTypeCheker | aTypeCheker warningsSize ]).
! !
!DenotativeObjectBrowserWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50494988!
renameInstVar
	
	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(DenotativeObjectRenameCollaboratorApplier on: model at: aClass) lines ].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461616!
unit
	
	^self lines unit! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50497768!
askAutosaveTypeIfCancelled: aBlock

	| menuIndex options labels |

	options := {SingleFileSystemCategoryAutoSaver. MultiFileSystemCategoryAutoSaver}.
	labels := options collect: [ :autoSaverClass | autoSaverClass menuDescription].
	menuIndex := (PopUpMenu labelArray: labels) startUpWithCaption: 'Autosave Type'.
	
	^ menuIndex = 0
		ifTrue: [ aBlock lines ]
		ifFalse: [ options at: menuIndex ]
	! !
!False methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16864872!
or: aBlock1 or: aBlock2 or: aBlock3 or: aBlock4

	"I sending value to aBlock4 to optimize the generated byte-code - Hernan"
	^aBlock1 lines or: [ aBlock2 lines or: [ aBlock3 lines or: [ aBlock4  lines ]]].
! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16794000!
grabProcessorFor: milliseconds onTimeout: timeoutBlock
	"Evaluate the receiver (block), without the possibility of preemption by regular priority processes.
	If not finished after milliseconds, evaluate timeoutBlock and restore original priority.
	Use with care!!"
	"Based on #valueUnpreemptively"
	
	| activeProcess oldPriority result done |
	activeProcess := Processor activeProcess.
	oldPriority := activeProcess priority.
	done := false.
	
	activeProcess priority: Processor highIOPriority + Processor lowIOPriority // 2.
	milliseconds ifNotNil: [
		[
			(Delay forMilliseconds: milliseconds) wait.
			done ifFalse: [
				activeProcess
					suspend;
					priority: oldPriority.
				timeoutBlock lines.
				"The timeoutBlock might terminate it, or even resume it!!"
				activeProcess isSuspended ifTrue: [
					activeProcess resume ]]
		] forkAt: Processor highIOPriority named: '#grabProcessorFor:onTimeout:' ].

	result := self ensure: [
		done := true.
		activeProcess priority: oldPriority].
	
	"Yield after restoring priority to give the preempted processes a chance to run"
	Processor yield.
	^result! !
!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16938926!
dumpTally: tally on: aStream
	"tally is from ProcessorScheduler>>tallyCPUUsageFor:
	Dumps lines with percentage of time, hash of process, and a friendly name"

	tally sortedCounts do: [ :assoc |
		((assoc key / tally size) * 100.0) rounded printOn: aStream.
		aStream
			nextPutAll: '%   ';
			print: assoc lines identityHash; space;
			nextPutAll: assoc lines name;
			newLine.
	]! !
!DenotativeObjectDebugger methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50494612!
askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes := aClass soleInstance withParents collect: [ :denotativeObject | denotativeObject class ].
	classes size = 1 ifTrue: [ ^aClass ].
	
	chosenClassIndex := PopUpMenu
		withCaption: 'Define #', aSelector, ' in which object?'
		chooseFrom: (classes collect: [:c | c soleInstance name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock lines].

	^ classes at: chosenClassIndex

	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461519!
quoFrom: aNumber

	^self lines quoFrom: aNumber
! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461455!
equalsCompoundMeasure: aMeasureBag

	^self lines = aMeasureBag! !
!DirectoryEntry methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16850182!
binaryAt: localFileName ifAbsent: block

	^ [self binaryAt: localFileName]
		on: FileDoesNotExistException
		do: [:ex | block lines]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461403!
>= aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^(self lines < aMagnitude) not! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461327!
negative

	^self lines negative! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16786413!
cumulativeCounts
	"Answer with a collection of cumulative percents covered by elements so far."
	| s n |
	s := self size / 100.0.
	n := 0.
	^ self sortedCounts asArray collect: [ :a |
		n := n + a key.
		(n / s roundTo: 0.1) -> a lines]! !
!WebMessage methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50590891!
headersAt: key ifAbsent: aBlock
	"Answers a collection of values for the given http header. 
	Use for headers that may appear multiple times, such at www-authenticate."

	| hdrs |
	hdrs := OrderedCollection new.
	self headersAt: key do:[:value| hdrs add: value].
	^hdrs asArray ifEmpty:[aBlock lines]
! !
!UnicodeString methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 17002350!
indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start.
	The set can only contain ASCII + Latin1 codePoints, i.e. < 256."

	"Fast lane."
	| index |
	self isAscii ifTrue: [
		^ bytes indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock ].

	"If only ASCII bytes are included in the map..."
	(ByteArray indexOfByte: 1 inBytes: aByteSetByteArray startingAt: 128) = 0 ifTrue: [
		|startBI foundBI|
		startBI := self byteIndexAt: start.
		foundBI := bytes indexOfAnyIn: aByteSetByteArray startingAt: startBI ifAbsent: aBlock.
		^ self codePointIndexAt: foundBI ].

	index := start.
	self do: [ :codePoint |
		codePoint < 256 ifTrue: [
			(aByteSetByteArray at: codePoint + 1) > 0 ifTrue: [ ^index ]].
		index := index + 1].

	^aBlock lines! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16780836!
removeKey: aKey ifAbsent: aBlock
	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."
	
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
				ifTrue: [propertyOrPragma key]
				ifFalse: [propertyOrPragma keyword])
			== aKey ifTrue:
			[^method removeProperty: aKey]].
	^aBlock lines! !
!Assert class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50493127!
isTrue: aBooleanOrBlock description: aFailureDescription
 
	aBooleanOrBlock lines ifFalse: [ self signalFailure: aFailureDescription ]
! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16808455!
checkForSlips
	"Return a collection of method refs with possible debugging code in them."
	| slips |
	slips := OrderedCollection new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc |  | method |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc lines) ifFalse: [
				method := aClass compiledMethodAt: mAssoc key ifAbsent: nil.
				method ifNotNil: [
					method hasReportableSlip
						ifTrue: [slips add: (MethodReference method: method)]]]]].
	^ slips! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16807927!
changedMessageList
	"Used by a message set browser to access the list view information."

	| messageList |
	messageList := OrderedCollection new.
	changeRecords associationsDo: [ :clAssoc | | classNameInFull classNameInParts |
		classNameInFull := clAssoc key asString.
		classNameInParts := classNameInFull findTokens: ' '.

		(clAssoc lines allChangeTypes includes: #comment) ifTrue: [
			messageList add:
				(MethodReference new
					setClassSymbol: classNameInParts first asSymbol
					classIsMeta: false 
					methodSymbol: #Comment 
					stringVersion: classNameInFull, ' Comment')].

		clAssoc lines methodChangeTypes associationsDo: [ :mAssoc |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc lines) ifFalse: [
				messageList add:
					(MethodReference new
						setClassSymbol: classNameInParts first asSymbol
						classIsMeta: classNameInParts size > 1 
						methodSymbol: mAssoc key 
						stringVersion: classNameInFull, ' ' , mAssoc key)]]].
	^ messageList sorted! !
!Number methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16920822!
to: stop do: elementBlock separatedBy: separatorBlock
	"
	String streamContents: [ :strm |
		1 to: 10 do: [ :i | i printOn: strm ] separatedBy: [ strm nextPutAll: ' -- ' ]]
	"
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst := true.
	self to: stop do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock lines].
		elementBlock value: element]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16961563!
renameClassOn: aBrowser for: aClassToRefactor

	(RenameClassApplier for: aClassToRefactor) lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461528!
remainderCompoundMeasure: aMeasureBag

	^self lines remainderCompoundMeasure: aMeasureBag! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16833802!
propertyValueAt: propName ifAbsent: aBlock
	
	^self withPropertiesDo: [ :properties | properties propertyValueAt: propName ifAbsent: aBlock ] ifSelector: [ :selector | aBlock lines ]
	! !
!ExtractMethodTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50430766!
test50ExtractsManyRepetitionsWithMultipleStatementsOnSameMethod

	| sourceMethodName finder sourceMethod extractMethod intervalToExtract newMessage |
	
	sourceMethodName := classToRefactor compile: 'm1 10 factorial. 10 factorial. true ifTrue: [ 10 factorial. 10 factorial]'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 29) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder lines.
	
	extractMethod := ExtractMethod 
		newDefinition: (ExtractMethodNewMethod 
			fromInterval: intervalToExtract 
			of: sourceMethod 
			to: newMessage 
			categorizedAs: #something
			withArgumentNames: Dictionary new)
		replacements: finder replacements.
		
	extractMethod apply.
	
	self assert: 
 'm2

	10 factorial. 10 factorial' equals: (classToRefactor >> #m2) sourceCode.
	self assert: 'm1 self m2. true ifTrue: [ self m2]' equals: (classToRefactor >> #m1) sourceCode.
	! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50427017!
test21FindsTemporaryWhenSelectingDefinition

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 | t1 | t1'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 12) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 12) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!Assert class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50493114!
isFalse: aBooleanOrBlock description: aFailureDescription

	self isTrue: aBooleanOrBlock lines not description: aFailureDescription ! !
!Graph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50463836!
removeNode: anObject ifAbsent: aBlock

	| nodesWithoutNode edgesWithoutNode |

	(nodes includes: anObject) ifFalse: [^aBlock lines].

	nodesWithoutNode := nodes reject: [:node | node = anObject].
	edgesWithoutNode := edges reject: [:edge | edge isIncidentTo: anObject].

	^self class edges: edgesWithoutNode nodes: nodesWithoutNode! !
!PackageSnapshot methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50498948!
snapshotOf: aBehavior ifAbsent: aBlock

	| snapshotOfClass |
	snapshotOfClass _ self
		snapshotOfClassNamed: aBehavior theNonMetaClass name
		ifAbsent: [ ^ aBlock lines ].

	^ aBehavior isMeta
		ifTrue: [ snapshotOfClass class ]
		ifFalse: [ snapshotOfClass ]! !
!InlineMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16883093!
declareNecessaryTemporaries

	temporariesToDeclareByInsertionPoint keysAndValuesDo: [:aSenderAndPosition :temporariesToDeclare |
		| sender positionToInsertTemporaries temporariesString |
		sender := aSenderAndPosition key.
		positionToInsertTemporaries := aSenderAndPosition lines.
		temporariesString := temporariesToDeclare reduce: [:t1 : t2 | t1 lines, ' ', t2 lines].
		((sender notOptimizedMethodNode parseNodesPathAt: positionToInsertTemporaries ifAbsent: 	[self shouldNotHappen ]) first key isTemporariesDeclaration)
			ifTrue: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: temporariesString, ' |'
				inMethod: sender.
			]
			ifFalse: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: '| ',  temporariesString, ' |', Character newLineCharacter asString, Character tab asString
				inMethod: sender
			]
	]! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16907434!
singleCompleteSourceRangeOf: requestedParseNode ifPresent: sourceRangePresentBlock ifAbsent: sourceRangeAbsentBlock
	"Finds the source range associated with the requested parse node.
	If it is present, evaluates sourceRangePresentBlock with the result.
	Otherwise, it evaluates sourceRangeAbsentBlock.
	Raises an error if the requested parse node has multiple source ranges"
	| sourceRanges |

	sourceRanges := self
		completeSourceRangesOf: requestedParseNode
		ifAbsent: [^sourceRangeAbsentBlock lines].

	^sourceRanges size > 1
		ifTrue: [self error: 'there are multiple source ranges for the parse node: ' , requestedParseNode printString ]
		ifFalse: [sourceRangePresentBlock value: sourceRanges anyOne].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461464!
hash

	^self lines hash! !
!TTCompositeGlyph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16980882!
replaceIndexesByComponentGlyphsIn: anArray
	glyphs := glyphs collect: [ :assoc | assoc key -> (anArray at: assoc lines) ]! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16812990!
indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	subString isString ifFalse: [
		^super indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock ].
	index := self findString: subString startingAt: start.
	index = 0 ifTrue: [ ^exceptionBlock lines ].
	^index! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16785735!
selectSelectorsThatSatisfy: aSelectorsSelectionCondition while: aClosure
	
	| currentSelectorsSelectionCondition |
	
	currentSelectorsSelectionCondition := selectorSelectionCondition.
	[ selectorSelectionCondition := aSelectorsSelectionCondition.
	aClosure lines ] ensure: [ selectorSelectionCondition := currentSelectorsSelectionCondition ].! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50446539!
m1_write_temp_outside_block

	| t1 |

	t1 := 1.
	[ t1 + 1 ] lines.

	t1 := 2.

	^t1! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16799874!
pushDownCategorySelectorsToOneSubclass
	
	self messageList do: [ :selectedSelector | selectedSelector ifNotNil: 
		[(PushDownMethodToOneSubclassApplier on: self for: self selectedClassOrMetaClass>>selectedSelector) lines ]
	].
	
	self removeMessageCategory.! !
!DenotativeObjectSmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50495984!
renameClassOn: aBrowser for: aClassToRefactor

	(DenotativeObjectRenameApplier for: aClassToRefactor) lines ! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50497299!
runDenotativeObjectSystemCategoryTests

	selectedSystemCategory ifNotNil: [ | suite classes |
		suite := TestSuite named: 'Tests of ', selectedSystemCategory.
		classes := systemOrganizer classesAt: selectedSystemCategory.
		classes notEmpty ifTrue: [
			classes do: [ :aClass |
				aClass class selectors do: [ :aSelector |
					aSelector isTestSelector ifTrue: [ suite addTest: (DenotativeObjectTestCase for: aClass class>>aSelector)]]].
			(DenotativeObjectProgessiveTestRunner for: suite) lines ]]
	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16854696!
withMessageSendKeywordPositionsOf: aSelector do: aMessageSendNodeBlock ifAbsent: aBlock

	| positions sortedPositions |

	positions := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: aMessageSendNodeBlock.

	positions isEmpty ifTrue: [ ^aBlock lines ].
	sortedPositions := positions asSortedCollection.

	^sortedPositions ! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50442927!
builderForClassNotEqualOrNotIdenticalTo: aMessageNode

	^EqualsTypeCastApplierBuilder
		to: aMessageNode receiver receiver key lines
		on: aMessageNode receiver arguments first receiver
		during: aMessageNode arguments second
		rejectingDuring: aMessageNode arguments first
		! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461331!
odd
	
	^self lines odd! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16941320!
fileOutMethods: aCollection on: aStream
	"FileOut all methods with selectors taken from aCollection"
	| categories |
	categories := Dictionary new.
	aCollection do:[:sel|
		| cat |
		cat := self organization categoryOfElement: sel.
		cat = self class removedCategoryName ifFalse:[
			(categories includesKey: cat) 
				ifFalse:[ categories at: cat put: Set new ].
			(categories at: cat) add: sel].
	].
	categories associationsDo:[:assoc|
		assoc lines do: [ :sel |
			aStream newLine.
			(self sourceCode at: sel) fileOutOn: aStream.
		].
	].! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50494059!
renameClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(DenotativeObjectRenameApplier for: aBehavior theNonMetaClass) lines ].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461427!
min: aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand.
	Self is given back and not self value to continue maintaining the evaluation"

	self lines < aMagnitude ifTrue: [^self].
	^aMagnitude! !
!RunArray methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16949250!
sum: aBlock ifEmpty: emptyBlockOrValue
        "
        (RunArray new: 4096 withAll: 3) sum =  12288.
        ([(RunArray new) sum] on: Error do: [:ex | ex messageText] ) = 'this collection is empty'.
        "
	| initial sum |
	self isEmpty ifTrue: [^ emptyBlockOrValue lines].
        initial := aBlock value: self first.
        sum := initial.
        self runsAndValuesDo: [:run :value | sum := sum + (run * (aBlock value: value))].
        ^ sum - initial! !
!NewSelectorPrecondition class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16919177!
valueFor: aSelectorToValidate on: aClass

	^ (self for: aSelectorToValidate on: aClass) lines! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16838707!
resume: value through: firstUnwindCtxt
	"Unwind thisContext to self and resume with value as result of last send.
	 Execute any unwind blocks while unwinding.
	 ASSUMES self is a sender of thisContext."

	| ctxt unwindBlock |
	self isDead ifTrue: [self cannotReturn: value to: self].
	ctxt := firstUnwindCtxt ifNil: [thisContext findNextUnwindContextUpTo: self].
	[ctxt isNil] whileFalse:
		[(ctxt tempAt: 2) ifNil:
			[ctxt tempAt: 2 put: true.
			 unwindBlock := ctxt tempAt: 1.
			 thisContext terminateTo: ctxt.
			 unwindBlock lines].
		 ctxt := ctxt findNextUnwindContextUpTo: self].
	thisContext terminateTo: self.
	^value
! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16984431!
assert: aBooleanOrBlock description: aStringOrBlock
	self incrementAssertionCount.
	aBooleanOrBlock lines ifFalse: [
		failureString := String streamContents: [:stream |
			stream 	nextPutAll: 'Assertion ('.
			assertCount printOn: stream.
			stream nextPutAll: ') failed. '.
			stream nextPutAll: aStringOrBlock lines].
		self logFailure: failureString.
		TestResult failure sunitSignalWith: failureString]! !
!False methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16864851!
or: alternativeBlock 
	"Nonevaluating disjunction -- answer value of alternativeBlock."

	^alternativeBlock lines! !
!ClassReferencesCollector class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16821521!
valueOf: aClassToLookForReferences

	^(self of: aClassToLookForReferences) lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461410!
between: min and: max
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^(min <= self lines) and: [self lines <= max]! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50400627!
testSample04
	| blockClosure materialized |
	blockClosure _ self bc04.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure lines = materialized lines.! !
!PopUpMenu class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16934781!
confirm: queryString orCancel: cancelBlock
	"Put up a yes/no/cancel menu with caption aString. Answer true if  
	the response is yes, false if no. If cancel is chosen, evaluate  
	cancelBlock. This is a modal question--the user must respond yes or no."

	"PopUpMenu confirm: 'Reboot universe' orCancel: [^'Nevermind']"

	| menu choice |
	menu := self labelArray: {'Yes'. 'No'. 'Cancel'} lines: #() icons: #(acceptIcon cancelIcon collapseIcon).
	choice := menu startUpWithCaption: queryString.
	choice = 1 ifTrue: [^ true].
	choice = 2 ifTrue: [^ false].
	^ cancelBlock lines! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16984540!
deny: aBooleanOrBlock description: aStringOrBlock

	self assert: aBooleanOrBlock lines not description: aStringOrBlock
			! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50457988!
typeCheckCategory

	| typeChecker |

	selectedSystemCategory ifNotNil: [
		typeChecker := ManyMethodsTypeChecker forAllClasses: (systemOrganizer allClassesAt: selectedSystemCategory).
		typeChecker lines.
		typeChecker showResultsWith: selectedSystemCategory name ]

	! !
!WeakActionSequence methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 17015465!
valueStartingFrom: startIndex
	"Do the same as my parent, but make sure that all actions that do not 
	give errors are evaluated before resignaling the ones that gave errors 
	(giving the chance to clients to handle them)."

	| each answer |
	startIndex to: self size do: [:index |
		each := self at: index.
		[ answer := each lines ]
			on: UnhandledError
			do: [:exc | 
				self valueStartingFrom: index + 1.
				exc pass]].
	^ answer! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16909892!
waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: anIntegerOrNil
	"Same as Monitor>>waitUntil:for:, but the process gets automatically woken up when the 
	specified time has passed."

	^ self waitWhile: [aBlock lines not] for: aSymbolOrNil maxMilliseconds: anIntegerOrNil! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16961649!
afterCompiling: aSourceCode do: aBlock for: aReceiver in: anEvaluationContext ifFail: aFailBlock
	
	| methodNode method compiler |
	methodNode := [
		compiler := Compiler new.
		compiler		
			compileNoPattern: aSourceCode
			in: aReceiver class
			context: anEvaluationContext
			notifying: self
			ifFail: [ ^ aFailBlock lines ]]
		on: OutOfScopeNotification
		do: [ :ex | ex resume: true ].

	methodNode block returnLast.
	method := methodNode generate.
	method methodNode: methodNode.

	^aBlock value: compiler value: method value: aReceiver value: anEvaluationContext 
! !
!False methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16864822!
ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 
	"Answer the value of falseAlternativeBlock. Execution does not
	actually reach here because the expression is compiled in-line."

	^falseAlternativeBlock lines! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50553884!
contextualExtractClass

	| classToRefactor |
	
	classToRefactor := model selectedClassOrMetaClass.

	classToRefactor ifNotNil: [(ExtractClassApplier applyOn: classToRefactor) lines.].! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16955299!
after: target ifNone: exceptionBlock
	"Answer the element after target.  Answer the result of evaluating
	the exceptionBlock if there are no elements after it."

	| index |
	index := self indexOf: target.
	^ index = 0
		ifTrue: [self errorNotFound: target]
		ifFalse: [index = self size 
			ifTrue: [exceptionBlock lines]
			ifFalse: [self at: index + 1]]! !
!TTCompositeGlyph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16980857!
contourCount
	| glyph count |
	count := 0.
	glyphs do: [ :txAndGlyph |
		glyph := txAndGlyph lines.
		count := count + glyph contourCount.
		].
	^count! !
!TTCompositeGlyph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16980875!
drawGlyphOn: aVectorCanvas
	glyphs do: [ :each |
		each lines drawGlyphOn: aVectorCanvas geometryTransformation: each key ]! !
!ExtractMethodTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50430701!
test42ExtractsManyRepetitionsOnSameMethod

	| sourceMethodName finder sourceMethod extractMethod intervalToExtract newMessage |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 5) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder lines.
	
	extractMethod := ExtractMethod 
		newDefinition: (ExtractMethodNewMethod 
			fromInterval: intervalToExtract 
			of: sourceMethod 
			to: newMessage 
			categorizedAs: #something
			withArgumentNames: Dictionary new)
		replacements: finder replacements.
		
	extractMethod apply.
	
	self assert: 
 'm2

	^ 10' equals: (classToRefactor >> #m2) sourceCode.
	self assert: 'm1 self m2. self m2' equals: (classToRefactor >> #m1) sourceCode.
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461468!
addCompoundMeasure: aMeasureBag

	^self lines addCompoundMeasure: aMeasureBag! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461619!
unitNameFor: aNumber

	^self lines unitNameFor: aNumber! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461623!
compareGreaterThan: aNumber

	^self lines compareGreaterThan: aNumber! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461605!
atBaseUnit: aBaseUnit ifNone: aBlock

	^self lines atBaseUnit: aBaseUnit ifNone: aBlock! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16854651!
rangesForLiteralNode: aName ifAbsent: aBlock

	| variableNode |
	
	variableNode := litSet at: aName ifAbsent: [ ^aBlock lines ].
	
	^sourceRanges at: variableNode ifAbsent: aBlock! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16936946!
pointer: pointerPref
	| enabled |
	enabled := pointerPref lines == #touch.
	#(tapAndHoldEmulatesButton2 clickGrabsMorphs) do: [:aPref | 	
		self sysPreferences at: aPref put: enabled]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50504796!
messageSendWithMessageSendReceiver

	(OrderedCollection new)
		lines! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50427237!
test28FindsRepeatedBlocks

	| sourceMethodName finder sourceMethod intervalToExtract newMessage methodsToExtractFrom replacement |

	sourceMethodName := classToRefactor compile: 'm1 [self m1]. [self m1]'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 12) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
		
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 12) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).

	replacement := methodsToExtractFrom second.
	self assert: (15 to: 23) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
! !
!FinalizationTestObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50397429!
finalize
	finalizeAction lines! !
!StringRequestMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16969429!
getUserResponseOrCancel: aBlock
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."
	| w delay done canceled |
	w := self world.
	w isNil ifTrue: [^ response asString asByteStringIfAscii ].
	done := false.
	canceled := false.
	(Preferences at: #focusFollowsMouse) ifFalse: [self textBox focusText].
	acceptBlock := [:aString| done := true].
	cancelBlock := [done := true. canceled := true].
	delay := Delay forMilliseconds: 10.
	[done not and: [self isInWorld]] whileTrue: [ w doOneMinimalCycleNow. delay wait ].
	self delete.
	w doOneMinimalCycleNow.
	canceled ifTrue: [^ aBlock lines].
	^ response asString asByteStringIfAscii.! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50426478!
test03FindsRepetitionsBeforeSelection

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (8 to: 9) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!ExtractMethodTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50430733!
test43ExtractsRepetitionsOnMoreThanOneMethod

	| sourceMethodName finder sourceMethod extractMethod intervalToExtract newMessage |
	
	sourceMethodName := classToRefactor compile: 'm1 10'.
	classToRefactor compile: 'm1b 100+10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 5) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder lines.
	
	extractMethod := ExtractMethod 
		newDefinition: (ExtractMethodNewMethod 
			fromInterval: intervalToExtract 
			of: sourceMethod 
			to: newMessage 
			categorizedAs: #something
			withArgumentNames: Dictionary new)
		replacements: finder replacements.
		
	extractMethod apply.
	
	self assert: 'm1 self m2' equals: (classToRefactor >> #m1) sourceCode.
	self assert: 'm1b 100+self m2' equals: (classToRefactor >> #m1b) sourceCode.
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50504969!
optimizedMessage
	
	1 to: 10 do: [ :number | number lines ]! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50427269!
test29DoesNotFailWithUnnecesaryDot

	| sourceMethodName finder sourceMethod intervalToExtract newMessage |

	sourceMethodName := classToRefactor compile: 'm1. self m2'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (5 to: 11) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	
	self 
		shouldnt: [ finder lines ] 
		raise: Error! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461360!
- anAritmethicObject

	^self lines - anAritmethicObject lines! !
!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16924897!
visitAssignmentNode: anAssignmentNode
	anAssignmentNode lines accept: self.
	anAssignmentNode variable isTemp
		ifTrue:
			[written ifNil: [written := IdentitySet new].
			 written add: anAssignmentNode variable]
		ifFalse:
			[anAssignmentNode variable accept: self]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16799715!
insertSuperclass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(InsertSuperclassApplier on: self for: aBehavior theNonMetaClass) lines ].! !
!InlineMethodMessageSendsSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16884869!
addMessageNodeReference: aMessageNodeReference ifIncluded: anIncludedBlock

	(messageList includes: aMessageNodeReference)
		ifTrue: [anIncludedBlock lines]
		ifFalse: [messageList add: aMessageNodeReference]! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16793441!
repeat
	"Evaluate the receiver repeatedly, ending only if the block explicitly returns."

	[self lines. true] whileTrue! !
!Object methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16921926!
assert: aBlock
	"Throw an assertion error if aBlock does not evaluates to true."

	aBlock lines ifFalse: [AssertionFailure signal: 'Assertion failed']! !
!MethodDictionary methodsFor: 'as yet unclassified' library: #MinimalKernel04HashedCollections stamp: 'BSN 11/7/2025 14:58:19' prior: 50372121!
at: key ifAbsent: aBlock

	| index |
	index := self findElementOrNil: key.
	(self basicAt: index) ifNil: [ ^ aBlock lines ].
	^ array at: index! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16838202!
send: selector super: superFlag numArgs: numArgs
	"Simulate the action of bytecodes that send a message with selector, 
	 selector. The argument, superFlag, tells whether the receiver of the 
	 message was specified with 'super' in the source method. The arguments 
	 of the message are found in the top numArgs locations on the stack and 
	 the receiver just below them."

	| thisReceiver arguments lookupClass |
	arguments := Array new: numArgs.
	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].
	thisReceiver := self pop.
	lookupClass := superFlag
					ifTrue: [self method methodClassAssociation lines superclass]
					ifFalse: [self objectClass: thisReceiver].
	QuickStep == self ifTrue:
		[QuickStep := nil.
		^self quickSend: selector to: thisReceiver with: arguments lookupIn: lookupClass].
	^self send: selector to: thisReceiver with: arguments lookupIn: lookupClass! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50455979!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons

	^ Array with: key lines class! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16902546!
printToDoOn: aStream indent: level

	| limitNode |
	self printReceiver: receiver on: aStream indent: level.

	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])
		ifTrue: [limitNode := arguments first]
		ifFalse: [limitNode := arguments last lines].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printKeywords: selector key
					arguments: (Array with: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16807822!
methodChanges

	| methodChangeDict |
	methodChangeDict := Dictionary new.
	changeRecords associationsDo: [ :assn | | changeTypes |
		changeTypes := assn lines methodChangeTypes.
		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].
	^ methodChangeDict! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16885321!
assertTemporaryIsNotAssignedAfterUsedInBlock
	
	| assignmentToTemporaryPositions |
	
	assignmentToTemporaryPositions := self selectCompleteRangesOfAssignmentsToTemporaryFrom: methodNode 
		thatMatch: [:assignmentRange | rangeOfNodeDeclaringTemporary includesAllOf: assignmentRange.].
	
	methodNode completeSourceRanges associationsDo: [:parseNodeAndRanges | (parseNodeAndRanges key isBlockNode 
		and: [parseNodeAndRanges lines anySatisfy: [:range | (rangeOfNodeDeclaringTemporary includesAllOf: range)
				and: [(methodNode positionsForTemporaryVariable: variableToInline ifAbsent: [#()]) 
					anySatisfy: [:tempReferenceInterval | range includesAllOf: tempReferenceInterval]]
				and: [assignmentToTemporaryPositions anySatisfy: [:tempAssignmentPosition | tempAssignmentPosition first > range last]]]])
					ifTrue: [self class signalTemporaryAssignedAfterUsedInBlock]]
	
! !
!AdditionalMethodStateTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50453299!
m04_two_temps_one_temp_in_remote_vector

	| t1 t2 |

	t1 := 1.
	[ t2 := t1 +  1.0 ] lines.

	^t2! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50453834!
returnFromClosure: aValue

	[ ^aValue ] lines! !
!MethodTypeChecker methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50447505!
typeCheckWhenAnnotatingTypes

	(MethodTypeCheckerVisitor for: method collectingErrorsInto: errors warningsInto: warnings andProblemsInto: problems) lines
	! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16780939!
propertyValueAt: aKey ifAbsent: aBlock
	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
		 and: [propertyOrPragma key == aKey]) ifTrue:
			[^propertyOrPragma lines]].
	^aBlock lines! !
!UnicodeString methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 17002332!
indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	aCharacter isCharacter ifFalse: [ ^ aBlock lines ].
	codePointBytes := Character utf8BytesOf: aCharacter codePoint.
	startByteIndex := self byteIndexAt: start.
	foundByteIndex := String findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer := self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock lines ]
		ifFalse: [ answer ]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461337!
positive

	^self lines positive! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461691!
roundTo: aNumber
	
	^self lines roundTo: aNumber
! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461437!
notInclusiveBetween: min and: max
	"Create local variable #val for best performance"

	| val |

	val := self lines.
	^val > min and: [val <= max]! !
!OneLineEditorMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50555866!
handleInteraction: interactionBlock
	"Perform the changes in interactionBlock, noting any change in selection
	and possibly a change in the size of the composition"

	"Also couple the editor to Morphic keyboard events"

	| oldEditor oldContents |
	oldEditor _ editor.
	oldContents _ contents.
	interactionBlock lines.
	oldContents == contents 
		ifTrue: [ "this will not work if the composition changed"
			editor _ oldEditor	"since it may have been changed while in block"].
	self redrawNeeded! !
!CodeCoverageSourceCodeGenerator methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50502927!
visitAssignmentNode: anAssignmentNode

	"Add tracing to assignment nodes.
	I consider an assignment node covered when its right hand side is evaluated.
	
	Implemenation Details
	===============
	
	Note that I do not visit the variable node as doing so will replace it with a tracing message node, and message nodes cannot be used as the left hand side
	in assignments.
	
	This is totally fine. Visiting a node is useful when I don't know its type, but in this case only VariableNodes are accepted for the left hand side.

	The source code interval for the variable will be considered covered when the assignment is evaluated."

	anAssignmentNode
		variable: anAssignmentNode variable
		value: (anAssignmentNode lines accept: self).	

	^ self
		parseNodeCoveringNodeWithDeclaration: anAssignmentNode variable
		whenExecuting: anAssignmentNode! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16793448!
repeatWithGCIf: testBlock
	| ans |
	"run the receiver, and if testBlock returns true, garbage collect and run the receiver again"
	ans := self lines.
	(testBlock value: ans) ifTrue: [ Smalltalk garbageCollect. ans := self lines ].
	^ans! !
!ExtractMethodReplacementsWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16864107!
closeAfter: aBlock

	model doNotRefreshSelection.
	aBlock lines.
	self whenUIinSafeState: [ self delete ].
	! !
!WebClient methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50589397!
basicAuth: request from: response header: header params: params
	"Provide basic authentication for the request"

	| user pass args |
	authParams at: #authMethod ifPresent:[:method| ^self]. "do not retry repeatedly"
	authParams at: #authMethod put: 'Basic'.

	args := WebUtils parseAuthParams: header.
	args at: 'realm' ifPresent:[:realm| authParams at: #authRealm put: realm].
	
	user := (params at: #username ifAbsent:[nil]) ifNil:[^self].
	pass := (params at: #password ifAbsent:[nil]) ifNil:[^self].
	authParams at: #authResponse put: (user, ':', pass lines) asUtf8Bytes base64Encoded! !
!ExtractMethodParametersDetector class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16863691!
valueFor: aMethodNodeToRefactor at: anIntervalToExtract

	^ (self for: aMethodNodeToRefactor at: anIntervalToExtract) lines! !
!IfNilChecksFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50546924!
assertLookUpOnSource: aMethodSource includesMessageAtIndex: anIndex

	| contextClass result |

	contextClass := self createClassNamed: #ContextClass instanceVariableNames: self instVar.
	contextClass compile: aMethodSource.

	result := (IfNilChecksFinder on: contextClass for: self instVar) lines.

	self assert: 1 equals: result size.
	self assert: anIndex equals: result first messageNodeIndex.
	self assert: #m1 equals: result first methodNode selector.! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16793684!
valueWithPossibleArgs: anArray
	"Generally, prefer #valueWithPossibleArgument: and #valueWithPossibleArgument:and:
	for performance."
	^ numArgs = 0
		ifTrue: [ self lines ]
		ifFalse: [
			self valueWithArguments:
				(numArgs = anArray size
					ifTrue: [ anArray ]
					ifFalse: [
						numArgs > anArray size
							ifTrue: [ anArray , (Array new: numArgs - anArray size) ]
							ifFalse: [
								anArray
									copyFrom: 1
									to: numArgs ]]) ].! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16854244!
encodeVariable: name sourceRange: range ifUnknown: action
	| varNode |
	varNode := scopeTable
					at: name
					ifAbsent: 
						[(self lookupInPools: name 
							ifFound: [:assoc | varNode := self global: assoc name: name])
							ifTrue: [varNode]
							ifFalse: [^action lines]].
	range ifNotNil:
		[name first canBeGlobalVarInitial ifTrue:
			[globalSourceRanges addLast: { name. range. false }]].

	(varNode isTemp and: [varNode scope < 0]) ifTrue:
		[^OutOfScopeNotification signal
			ifTrue: [action lines]
			ifFalse: [self notify: 'out of scope']].
	^varNode! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 50461508!
multiplyCompoundMeasure: aMeasureBag

	^self lines multiplyCompoundMeasure: aMeasureBag! !
!NewClassPrecondition class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:19' prior: 16918671!
valueFor: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	^(self for: aNewClassName in: aSystem undeclared: anUndeclaredDictionary) lines! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50442915!
builderForClassEqualOrIdenticalTo: aMessageNode

	^EqualsTypeCastApplierBuilder
		to: aMessageNode receiver receiver key lines
		on: aMessageNode receiver arguments first receiver
		during: aMessageNode arguments first
		rejectingDuring: aMessageNode arguments second! !
!AutoCompleter methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16784727!
autoCompletionAround: aBlock keyStroke: aKeyboardEvent

	(self handleKeystrokeBefore: aKeyboardEvent)
		ifTrue: [^ self].
	aBlock lines.
	"Narrow the completion with any of the keys"
	self handleKeystrokeAfter: aKeyboardEvent! !
!InnerTextMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16887081!
handleInteraction: interactionBlock
	"Perform the changes in interactionBlock, noting any change in selection
	and possibly a change in the composition"

	self selectionChanged.  "Note old selection"

	interactionBlock lines.

	self selectionChanged.  "Note new selection"
	self updateFromTextComposition! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16984557!
should: aBlock description: aString

	self assert: aBlock lines description: aString
			! !
!IniFile methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16882795!
atSection: sectionName entry: entryName orDefault: aBlock
	"If section or entry is missing, answer the result of evaluating aBlock,
	but don't add the section or entry."

	^(namedSections at: sectionName ifAbsent: [ ^aBlock lines ])
		at: entryName orDefault: aBlock.! !
!CachedEvaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461709!
computeValue

	^evaluation lines! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50427077!
test22FindsTemporaryWhenSelectingDefinitionInInnerClosure

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 | t1 | true and: [ |t2| t1 ]. t1'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (23 to: 29) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (23 to: 29) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!MessageSendingBlocksVariablesToExtractFinder class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50531435!
valueIn: aMessageNode

	^(self new initializeToFindIn: aMessageNode) lines! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50470721!
performWithFormulaWithCompoundMeasure

	self assert: (formulaOfTenPesos perform: messageName with: (self tenDollars + self tenPesos)) lines = 
		(formulaOfTenPesos lines perform: messageName with: (self tenDollars + self tenPesos) lines)! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400409!
testInlineBlockCollectionSD1
	| a1 b1 a2 b2 |
	b1 := OrderedCollection new.
	1 to: 3 do:
		[:i |
		a1 := i.
		b1 add: [a1]].
	b1 := b1 asArray collect: [:b | b lines].
	b2 := OrderedCollection new.
	1 to: 3 do:
		[:i |
		a2 := i.
		b2 add: [a2]] yourself. "defeat optimization"
	b2 := b2 asArray collect: [:b | b lines].
	self assert: b1 = b2! !
!ClassVarAssignationChecker methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50531781!
visitAssignmentNode: anAssignmentNode 
	anAssignmentNode variable name = classVarNamed ifTrue: [returnBlockTrue lines]! !
!Collection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16828485!
associationsDo: elementBlock separatedBy: separatorBlock
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst := true.
	self associationsDo: [ :element |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock lines].
		elementBlock value: element]! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16825000!
packageOfClass: aClass ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock lines ].
	^ InstalledPackages
		detect: [:ea | ea includesClass: aClass]
		ifNone: errorBlock! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461602!
amount
	
	^self lines amount! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16786550!
withOccurrencesDo: aBlock
	contents associationsDo: [:each| aBlock value: each key value: each lines]! !
!True methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16999482!
and: aBlock1 and: aBlock2

	"I sending value to aBlock2 to optimize the generated byte-code - Hernan"
	^aBlock1 lines and: [ aBlock2 lines ]! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50457233!
allActualImplementorsOf: aSelector forAll: types

	^(AllActualImplementors of: aSelector forAll: types) lines! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50445965!
printReducedTypesOf: aVarName ifAbsent: anAbsentBlock

	| typeInfo |

	typeInfo := self typeInfoOf: aVarName ifAbsent: [ ^anAbsentBlock lines ].

	^typeInfo printReducedTypes ! !
!CodeForNodeToMove methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50531951!
visitMethodNode: aMethodNode 
	| assoc |
	"moving to a parameter should change selector"
	(methodNode argumentNames includes: variableToAccesThrough) 
	ifTrue: [
		assoc := parameterNeeded associationToModifySelectorAndArgumentsOn: methodNode withParameter: variableToAccesThrough.
		]
	ifFalse: [
		assoc :=  parameterNeeded associationToModifySelectorAndArgumentsOn: methodNode .
		].
	self registerInterval: assoc key withModification: assoc lines .
	^super visitMethodNode: aMethodNode 


! !
!Socket methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50585566!
waitForDataFor: timeout ifClosed: closedBlock ifTimedOut: timedOutBlock
	"Wait for the given nr of seconds for data to arrive."
	
	| deadline timeLeft |
	socketHandle ifNil: [ ^closedBlock lines ].
	deadline := Time millisecondClockValue + (timeout * 1000) truncated.
	[
		(self primSocketReceiveDataAvailable: socketHandle) ifTrue: [ ^self ].
		self isConnected ifFalse: [ ^closedBlock lines ].
		(timeLeft := deadline - Time millisecondClockValue) <= 0 ifTrue: [ ^timedOutBlock lines ].
		"Providing a maximum for the time for waiting is a workaround for a VM bug which causes sockets waiting for data forever in some rare cases, because the semaphore doesn't get signaled. Remove the ""min: self class maximumReadSemaphoreWaitTimeout"" part when the bug is fixed."
		readSemaphore waitTimeoutMSecs: 
			(timeLeft min: self class maximumReadSemaphoreWaitTimeout) ] repeat! !
!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400530!
methodWithCopiedAndPostClosedOverAssignedTemps
	| blk a b c r1 r2 |
	a := 1.
	b := 2.
	c := 4.
	blk := [a + b + c].
	r1 := blk lines.
	b := nil.
	r2 := blk lines.
	r1 -> r2

	"(Parser new
		encoderClass: EncoderForV3;
		parse: (self class sourceCodeAt: #methodWithCopiedAndPostClosedOverAssignedTemps)
		class: self class) generateUsingClosures: #(0 0 0 0)"! !
!WebClient methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50589917!
retryOnce: aTryBlock
	" Retry the block once if it failes,
	except for direct network errors.
	This can help in cases like temporary failing
	SqueakSSL primitives"
	| again |
	again := true.
	[^ aTryBlock lines.
	] on: Error do: [:e |
		((e isKindOf: NetworkError) or: [again not])
			ifTrue: [e pass]
			ifFalse: [again := false. e retry]].! !
!CodeCoverageAnalyzer methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50500813!
value: aBlock
	
	"Convenience method for collecting code coverage for compiledMethodsToAnalyze
	and cleaning up after myself in one-shot."
	
	[
		self startTrackingCodeCoverage.
		^ aBlock lines
	] ensure: [
		self stopTrackingCodeCoverage
	]
	! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16849212!
keysAndValuesDo: aBlock
	^self associationsDo:[:assoc|
		aBlock value: assoc key value: assoc lines].! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50557867!
asInstanceVariableNameIfHasNoPrefix: aBlock
	
	self hasAnPrefix ifTrue: [ ^self uncapitalizedRemovingFirst: 2 ].
	self hasAPrefix ifTrue: [ ^self uncapitalizedRemovingFirst: 1 ].
	self hasUnPrefix ifTrue: [ ^self uncapitalizedRemovingFirst: 2 ].
	self hasUnaPrefix ifTrue: [ ^self uncapitalizedRemovingFirst: 3 ].
	
	^aBlock lines
	! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16898573!
nextPut: anObject 
	"Ensure that the limit is not exceeded"

	^position >= limit
		ifTrue: [limitBlock lines]
		ifFalse: [super nextPut: anObject]! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 17018638!
runDeferredUIMessages
	"Processing the queue until empty is wrong if a block in it calls #addDeferredUIMessage: itself, because this loop will never end.
	Instead, process no more than entries already in queue befor we start iterating!!"
	| readyToProcess |
	readyToProcess := deferredUIMessages size.
	readyToProcess timesRepeat: [
		UISupervisor isUIProcessRunning ifFalse: [ ^self ].
		deferredUIMessages nextOrNil ifNotNil: [ :block |
			block lines ]].! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50467616!
testValue

	"Example from http://en.wikipedia.org/wiki/Topological_sorting"

	| graph result |

	graph :=
		Graph edges: (
			OrderedCollection new
				add: (Edge from: 7 to: 11);
				add: (Edge from: 7 to: 8);
				add: (Edge from: 11 to: 2);
				add: (Edge from: 11 to: 9);
				add: (Edge from: 11 to: 10);
				add: (Edge from: 5 to: 11);
				add: (Edge from: 3 to: 8);
				add: (Edge from: 3 to: 10);
				add: (Edge from: 8 to: 9);
				yourself).

	result := (TopologicalSort for: graph) lines asOrderedCollection.

	self assert: 8 equals: result size.
	self assert: (result includesAllOf: #(3 5 7 11 8 2 9 10))! !
!DecompilerConstructor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16847967!
decodeLiteralVariableValueDereferenceWithReceiver: receiver selector: selector arguments: arguments
	| varNode |
	(receiver notNil "cascades"
	 and: [receiver isLiteralNode
	 and: [receiver key isVariableBinding]]) ifFalse:
		[^nil].
	varNode := self codeAnyLitInd: receiver key.
	selector = #lines ifTrue:
		[^varNode].
	^selector = #value: ifTrue:
		[self codeAssignTo: varNode value: arguments first]! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16955605!
identityIndexOf: anElement ifAbsent: exceptionBlock
	"Answer the index of anElement within the receiver. If the receiver does 
	not contain anElement, answer the result of evaluating the argument, 
	exceptionBlock."
	1 to: self size do:
		[:i | (self at: i) == anElement ifTrue: [^ i]].
	^ exceptionBlock lines! !
!Association methodsFor: 'as yet unclassified' library: #MinimalKernel01 stamp: 'BSN 11/7/2025 14:58:20' prior: 50369409!
printOn: aStream

	aStream
		print: self key;
		nextPutAll: ' -> ';
		print: self lines! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16799803!
safelyRemoveClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(SafelyRemoveClassApplier on: self of: aBehavior theNonMetaClass) lines ].! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400388!
testInlineBlockCollectionLR2
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollection new.
	1 to: 11 do: [ :each | #(1) do: [:ignored| col add: [ each ]] ].
	self assert: (col collect: [ :each | each lines ]) asArray = (1 to: 11) asArray! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16780821!
properties

	| propertyStream propertyOrPragma "<Association|Pragma>" |
	propertyStream := WriteStream on: (Array new: self basicSize * 2).
	1 to: self basicSize do: [:i |
		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:
			[propertyStream nextPut: propertyOrPragma key; nextPut: propertyOrPragma lines]].
	^IdentityDictionary newFromPairs: propertyStream contents! !
!VectorEngineWithPlugin class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 17013822!
protected: aBlock
	"VectorEnginePlugin is not reentrant.
	- Any proces that is not the main UI process must wait.
	- The main UI process will take the plugin without caring of some other process drawing breaks."
	
	(AccessLock notNil and: [ AccessLock ~= Processor activeProcess ]) ifTrue: [
		"Unless we are running the UI, wait"
		UISupervisor isUIProcessRunning ifFalse: [
			('VectorEnginePlugin is in use by: ', AccessLock printString) print.
			'Wait a bit.' print. 
			UISupervisor whenUIinSafeState: [ Processor activeProcess resume ].
			Processor activeProcess suspend ].
	].
	AccessLock := Processor activeProcess.
	aBlock lines.
	AccessLock := nil.! !
!ChangeSelector class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50458472!
assertReceiverTypesOfAll: aCollectionOfSenders areIncludedInAllTypesOf: aCollectionOfImplementors

	| messageSendsWithInvalidReceiverTypes |

	messageSendsWithInvalidReceiverTypes := (ReceiverTypesOfMessageSendsConform
		from: aCollectionOfSenders to: aCollectionOfImplementors) lines.
	messageSendsWithInvalidReceiverTypes ifNotEmpty: [
		self signalReceiverTypesNotIncludedInImplementorTypes: messageSendsWithInvalidReceiverTypes ].! !
!GregorianDate methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50479524!
immutableValue
	"It is necessary to turn it absolute so that it is immutable."

	^self lines! !
!CodeForNodeToMove methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50532312!
value
	| newCode newCodeForNode |
	self initializeNodeInterval.
	self initializeOffset.
	node accept: self.
	intervalsToModify := intervalsToModify collect: [ :anAssociation | (anAssociation key - nodeOffsetInSourceCode) -> anAssociation lines ].
	newCodeForNode := methodNode sourceText copyFrom: nodeInterval first to: nodeInterval last.
	
	intervalsToModify sort: [ :left :right | left key first < right key first ].
	newCode := newCodeForNode copyReplacing: intervalsToModify.
	 
	hasImplicitSelfReturn 	ifTrue: [ 
			(newCode last = $.) ifFalse: [newCode := newCode append: '.'].
			newCode := newCode append: String newLineString, String tab, '^', parameterNeeded parameterName, '.'
			].
	^CodeForNodeToMoveResult 
				newWith: newCode 
				sourceClass: methodNode methodClass
				targetClass: targetClass
				methodsToCompileOnSourceClass: methodToCompileOnSourceClass! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16965849!
findSourceRangeOfCloserStatementIn: listOfAncestors ifNone: noneBlock

	^ (listOfAncestors
		detect: [ :assoc | assoc key isBlockNode or: [ assoc key isReturn ]]
		ifFound: [ :assoc | listOfAncestors before: assoc ifNone: noneBlock ]
		ifNone: noneBlock) lines! !
!Dictionary methodsFor: 'as yet unclassified' library: #MinimalKernel04HashedCollections stamp: 'BSN 11/7/2025 14:58:20' prior: 50371883!
do: aBlock 
	super do: [:assoc | aBlock value: assoc lines]! !
!ContentPack class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16837633!
encodeContentFrom: aDictionary

	| encodedTree |
	
	encodedTree := Dictionary new.
	
	aDictionary associations
		do: [ :assoc |
			assoc lines class == Dictionary
				ifTrue: [ 
					encodedTree 
						at: assoc key 
						put: (self encodeContentFrom: assoc lines) 
				]
				ifFalse: [ 
					encodedTree 
						at: assoc key
						put: count.
					count := count + 1.
					payload add: assoc lines storeString asByteArray base64Encoded
				]
		].

	^ encodedTree associations collect: [ :assoc | 
		{ assoc key . assoc lines }
	]! !
!Semaphore methodsFor: 'as yet unclassified' library: #MinimalKernel01 stamp: 'BSN 11/7/2025 14:58:20' prior: 50366501!
critical: mutuallyExcludedBlock
	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in
	the process of running the critical: message. If the receiver is, evaluate
	mutuallyExcludedBlock after the other critical: message is finished."
	
	| caught |
	"We need to catch eventual interruptions very carefully. 
	The naive approach of just doing, e.g.,:
		self wait.
		aBlock ensure:[self signal].
	will fail if the active process gets terminated while in the wait.
	However, the equally naive:
		[self wait.
		aBlock value] ensure:[self signal].
	will fail too, since the active process may get interrupted while
	entering the ensured block and leave the semaphore signaled twice.
	To avoid both problems we make use of the fact that interrupts only
	occur on sends (or backward jumps) and use an assignment (bytecode)
	right before we go into the wait primitive (which is not a real send and
	therefore not interruptable either)."

	caught := false.
	^[
		caught := true.
		self wait.
		mutuallyExcludedBlock lines
	] ensure: [ caught ifTrue: [self signal] ]
! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50492582!
assert: aBooleanOrBlock

	aBooleanOrBlock lines ifFalse: [self error: 'Assertion failed']
			! !
!MethodSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16908499!
sortByDate
	"Sort the message-list by date of time-stamp"

	| assocs aCompiledMethod aDate inOrder |
	assocs := messageList collect: [ :aRef |
		aDate := aRef methodSymbol == #Comment
			ifTrue: [
				aRef actualClass organization dateCommentLastSaved]
			ifFalse: [
				aCompiledMethod := aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: nil.
				aCompiledMethod ifNotNil: [aCompiledMethod dateCommentLastSaved]].
		aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"
	inOrder := assocs asArray sort: [ :a :b | a lines < b lines].

	inOrder do: [ :each | each key prefixStringVersionWith: each lines yyyymmdd ].
	messageList := inOrder collect: [ :assoc | assoc key ].
	self changed: #messageList! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16956592!
with: otherCollection do: twoArgBlock separatedBy: separatorBlock

	| beforeFirst |

	beforeFirst := true.
	self with: otherCollection do: [ :selfElement :otherCollectionElement |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock lines].
		twoArgBlock value: selfElement value: otherCollectionElement ].


! !
!LinkedList methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16898666!
at: index ifAbsent: exceptionBlock

	| i |
	index < 1 ifTrue: [ ^exceptionBlock lines ].
	i := 0.
	self do: [ :link |
		(i := i + 1) = index ifTrue: [ ^ link ]].
	^ exceptionBlock lines! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16984628!
shouldnt: aBlock

	self deny: aBlock lines
			! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50427184!
test26FindsInsideParentesis

	| sourceMethodName finder sourceMethod intervalToExtract newMessage methodsToExtractFrom replacement |

	sourceMethodName := classToRefactor compile: 'm1 (self m1)'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (5 to: 11) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
		
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (5 to: 11) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
! !
!EffectiveTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50446991!
addToAfterMessageTypeCasts: aTypeCastBlockBuilder ifReturns: anArgumentBlock

	anArgumentBlock isBlockNode
		ifTrue: [ anArgumentBlock returns
			ifTrue: [ afterMessageTypeCasts add: aTypeCastBlockBuilder lines ]].
! !
!CompiledMethodCoverageReport methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50501274!
messageAt: aSourcePosition

	^ messagesBySourceRanges associations
		detect: [ :association | association key includes: aSourcePosition ]
		ifFound: [ :association | association lines ]
		ifNone: [ ^ '' ]! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50458080!
removeType: aType ifAbsent: anAbsentBlock

	^anAbsentBlock lines ! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16854659!
rangesForLiteralVariableNode: aName ifAbsent: aBlock

	| variableNode |
	
	variableNode := litIndSet values detect: [ :aLiteralVariableNode | aLiteralVariableNode name = aName ] ifNone: [ ^aBlock lines ].
	
	^sourceRanges at: variableNode ifAbsent: aBlock! !
!ByteArray methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16801539!
indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start.
	aByteSetByteArray is a ByteArray of size 256 with a 1 for byte values considered to be included."

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aByteSetByteArray startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock lines ]
		ifFalse: [ answer]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16961604!
renameTemporary: aTemporaryNode at: aMethodNode

	self codeProvider isEditingMethod ifTrue: [ | applier |
		[ applier := RenameTemporaryApplier on: self for: aTemporaryNode at: aMethodNode ]
			on: SyntaxErrorNotification
			do: [:anError | ^self inform: (RenameTemporaryApplier errorMessageForCanNotParseMethod: anError) ].
		applier lines ].
! !
!MethodNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50455847!
withTopParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |

	nodeAndPosition :=self topParseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock lines ].

	^aBlock value: nodeAndPosition key
	! !
!NewGlobalPrecondition class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16918807!
valueFor: aNewName in: aSystem  

	^(self for: aNewName in: aSystem) lines! !
!TranscriptTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50423330!
assertTranscriptContentsAdded2: expectedAddedString after: aBlock
	
	| transcriptContentsBeforeBlockEvaluation |
	"Transcript clear."
	transcriptContentsBeforeBlockEvaluation := Transcript contents.
	aBlock lines.
	{transcriptContentsBeforeBlockEvaluation. expectedAddedString.Transcript contents} inspect.
	self assert: Transcript contents equals: transcriptContentsBeforeBlockEvaluation, expectedAddedString.! !
!Editor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16853556!
lineSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this.
	
	Do not push down this method. It is used in SimpleEditor of package Widgets-Extras
	"

	"if current selection is empty, then first select the entire line in which occurs before proceeding"
	self hasSelection ifFalse: [
		self selectLine ].
	self selectionIsEmptyOrSeparators ifTrue: [
		morph flash.
		^ returnBlock lines ].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461474!
addSimpleMeasure: aMeasure

	^self lines addSimpleMeasure: aMeasure! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50426665!
test09FindsRepetitionsWithCascade

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 self m1; m2. self m1; m2'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 14) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 14) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (17 to: 27) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!Class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16815617!
classVarValueOf: varNameSymbol

	^(self classPool bindingOf: varNameSymbol) ifNotNil: [:binding | binding lines ]! !
!VariablesToExtractFinder class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50531492!
valueIn: aMethodNode

	^(self in: aMethodNode) lines! !
!Morph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16910664!
valueOfProperty: aSymbol ifPresentDo: aBlock ifAbsent: absentBlock
	"If the receiver has a property of the given name, evaluate
	aBlock on behalf of the value of that property, if not evaluate absentBlock"

	| value |
	
	value := self valueOfProperty: aSymbol ifAbsent: [^ absentBlock lines ].
	
	^aBlock value: value! !
!ReceptiveAccountTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50599346!
test04WithdrawValueMustBePositive 

	| account withdrawValue |
	
	account := ReceptiveAccount new.
	withdrawValue := 50.
	
	self assert: withdrawValue equals: (Withdraw register: withdrawValue on: account) lines
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16961426!
contextualPushUpInClassDefinition 

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
				self apply: [ :aSelectedClass | 
					(PushUpInstanceVariableApplier 
						on: self codeProvider 
						for: self wordUnderCursor 
						at: aSelectedClass) lines ] inClassDefinitionOf: classDefinitionNode in: selectedClass ]
			ifErrorsParsing: [ :anError | morph flash ]]! !
!ProcessBrowser class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16938950!
findPigProcess
	"Must run forked on its own process, so the monitored behavior is not affected too much"

	| promise tally process |
	promise := Processor tallyCPUUsageFor: 0.1 every: 10.
	tally := promise lines.
	tally ifEmpty: [ ^nil ]. "We can not do better"
	"Avoid, system processes, the background process, and terminated processes."
	tally sortedCounts do: [ :entry |
		process := entry lines.
		(process == Processor backgroundProcess or: [ (process name beginsWith: '[system]') or: [process isTerminated]])
			ifFalse: [ ^process ]].
	^nil! !
!Trie methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16998863!
at: key ifAbsentPut: aBlock 
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."
	^self at: key ifAbsent:[self at: key put: aBlock lines]! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50447407!
problemsDetect: aCondition ifNone: noneBlock

	| problem |

	typeCheckers do: [ :typeChecker |
		problem := typeChecker problemsDetect: aCondition ifNone: [ nil ].
		problem ifNotNil: [ ^problem ]].

	^noneBlock lines! !
!Morph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16911399!
mouseStillDown
	"Called from the stepping mechanism for morphs wanting continuously repeated 'yes the mouse is still down, yes it is still down, yes it has not changed yet, no the mouse is still not up, yes the button is down' etc messages"
	
	self "Allow instances to use this"
		valueOfProperty: #'mouseStillDown
'		ifPresentDo: [ :handler | handler lines ]! !
!CodeCoverageAnalyzerBuilder class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50502285!
valueFrom: aTestSuite 
	
	^ (self from: aTestSuite) lines! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16976147!
globals
	" 
	Smalltalk  globals
	"
	
	| globals |
	globals := IdentityDictionary new.
	self associationsDo: [ :assoc |
		assoc lines class isMeta not ifTrue: [ globals add: assoc ]].
	^globals! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16799786!
renameGlobal
	
	(RenameGlobalApplier on: self for: '') lines! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50426784!
test13FindsRepetitionsOfLiteral

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10 + 5'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50453811!
blockReturn

	[ 'hello' ] lines.

	^10! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50426584!
test07FindsRepetitionsInSubclassesMethods

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement subclassToRefactor |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	classToRefactor compile: 'm1b 100+10'.
	subclassToRefactor := self createClassNamed: self subclassToRefactorName subclassOf: classToRefactor.
	subclassToRefactor compile: 'm3 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 4 equals: methodsToExtractFrom size.
	replacement := (methodsToExtractFrom select: [ :aReplacement | aReplacement isOf: sourceMethod ]) first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	
	replacement := (methodsToExtractFrom select: [ :aReplacement | aReplacement isOf: sourceMethod ]) second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: (classToRefactor >> #m1b) asMethodReference ].
	self assert: (9 to: 10) equals: replacement intervalToExtract.
	
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: (subclassToRefactor >> #m3) asMethodReference ].
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert:(replacement isOf: (subclassToRefactor >> #m3) asMethodReference)
	! !
!ExternalObjectTable methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50582786!
externalObjectAt: index ifAbsent: errorBlock
	"Answer the externalObject at index, or the result of errorBlock if none."

	^(semaphore critical: [externalObjectsArray at: index ifAbsent: nil]) ifNil:
		[errorBlock lines]! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16885434!
computeEndOfNodeEnclosingAssignment

	endOfNodeEnclosingAssignment := (methodNode parseNodesPathAt: assignmentToInlineRange first
		ifAbsent: [self shouldNotHappen])
			detect: [:nodeAndRange | nodeAndRange key isBlockNode]
			ifFound: [:nodeAndRangeOfAssignment | nodeAndRangeOfAssignment lines last ]
			ifNone: [methodNode sourceText size].




! !
!CodeForNodeToMove methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50532303!
shouldAddParenthesisOnValueOf: anAssignmentNode

	^ ((anAssignmentNode lines isMessageNode and: [anAssignmentNode lines isKeywordMessageSend])) or: [anAssignmentNode lines isAssignmentNode ]! !
!Mutex methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16918291!
critical: aBlock onReentry: reentryBlock
	"Evaluate aBlock protected by the receiver.
	This method allows using the receiver either as a reentrant or non-reentrant Mutex.
	See https://en.wikipedia.org/wiki/Reentrant_mutex

	| m |
	m := Mutex new.
	m critical: [ 1 print. m critical: [ 2 print ] onReentry: ['Reentry attempt!!' print]. 3 print ]. 'Done'.
	"

	| activeProcess |
	activeProcess := Processor activeProcess.
	activeProcess == owner ifTrue: [^reentryBlock lines].
	^semaphore critical: [
		owner := activeProcess.
		aBlock ensure: [owner := nil]].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16799885!
pushDownCategorySelectorsToSubclasses
	
		self messageList do: [ :selectedSelector | selectedSelector ifNotNil: 
			[(PushDownMethodToSubclassesApplier on: self for: self selectedClassOrMetaClass>>selectedSelector) lines] 
		].
	
		self removeMessageCategory.
! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16983532!
isLocalToBlocksInIfNilIfNotNilNodes: ifNilIfNotNilMessages "<Collection of: MessageNode>" in: aMethodNode "<MethodNode>"
	"Answer if the receiver only occurs within the ifNotNil: blocks of the message nodes,
	 or is the target of the assignment that is the receiver of each node.
	 Assumes that all ifNilIfNotNilMessages are in fact subnodes of aMethodNode.

	Strategy:
		First visit all nodes outside of the message nodes. If the variable is referenced there answer false.
		Next visit the expressions of all assignments that are the receivers of the ifNilIfNotNil: messages.
		If the variable is referenced there answer false.
		If not found outside, answer true. This does not require the variable to be referenced within the
		block, but that is not necessary to produce a nicely preened tree."
	| ifNotNilBlocks ifNotNilAssignments finder |
	ifNotNilBlocks := Set new.
	ifNotNilAssignments := Set new.
	ifNilIfNotNilMessages do:
		[:messageNode|
		(messageNode receiver isMessageNode
		 and: [messageNode receiver selector key == #==
		 and: [messageNode receiver receiver isAssignmentNode
		 and: [messageNode receiver receiver variable = self]]]) ifTrue:
			[ifNotNilAssignments add: messageNode receiver receiver].
		ifNotNilBlocks add: (messageNode arguments at: (messageNode selector key keywords indexOf: #ifNotNil:))].
	finder := ParseNodeEnumerator
				ofBlock: [:node| node == self ifTrue: [^false]]
				select: [:node| ((node isBlockNode and: [ifNotNilBlocks includes: node])
								or: [node isAssignmentNode and: [ifNotNilAssignments includes: node]]) not].
	aMethodNode accept: finder.
	ifNotNilAssignments do:
		[:assignmentNode|
		assignmentNode lines accept: finder].
	^true! !
!MethodSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16908994!
runMethodTest
	
	| suite |
	
	suite := TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgressiveTestRunner for: suite) lines! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16999116!
removeKey: aString ifAbsent: aBlock characterIndex: i

	| child answer |
	child := self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock lines ].
	answer := child removeKey: aString ifAbsent: aBlock characterIndex: i + segmentSize.
	child isEmpty ifTrue: [
		self removeChildFor: aString characterIndex: i.
		"If child is not needed anymore, compress the path"	
		children class == TrieNode ifTrue: [
			someKey := children getSomeKey.
			segmentSize := segmentSize + children getSegmentSize.
			childrenFirstChars := children getChildrenFirstChars.
			children := children getChildren ]].
	^answer! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16936889!
defaultFontSize: aPreference
	"
	Preferences at: #defaultFontSize put: '12'
	Preferences at: #defaultFontSize put: 14
	Preferences at: #defaultFontSize put: 21
	"
	| pointSize font titleFont |
	pointSize := aPreference lines.
	font := FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	Preferences name: #standardListFont category: #font value: font.
	Preferences name: #standardMenuFont category: #font value: font.
	Preferences name: #standardCodeFont category: #font value: font.
	Preferences name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont := FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	Preferences name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	Preferences at: #biggerCursors put: (pointSize > 30).
	Cursor defaultCursor activateCursor.
	MenuItemMorph initializeSubMenuMarker.
	^ font! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50426450!
test02FindsRepetitionsAfterSelection

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (8 to: 9) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50426553!
test06FindsRepetitionsInOtherClassMethods

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10'.
	classToRefactor compile: 'm1b 100+10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: sourceMethod ].
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	
	replacement := methodsToExtractFrom detect: [ :aReplacement | aReplacement isOf: (classToRefactor >> #m1b) asMethodReference ].
	self assert: (9 to: 10) equals: replacement intervalToExtract.
	
	! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16844781!
askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector withCaption: aCaptionText ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes := aClass = aSuperclass ifTrue: [ { aClass } ] ifFalse: [ aClass withAllSuperclassesUpTo: aSuperclass ].
	chosenClassIndex := PopUpMenu
		withCaption: aCaptionText
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock lines].

	^ classes at: chosenClassIndex! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16999046!
removeKey: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex answer |
	keys isArray ifTrue: [
		keyIndex := keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock lines ]
			ifFalse: [
				answer := values at: keyIndex.
				keys size = 2
					ifTrue: [
						keys := keys at: 3-keyIndex.
						values := values at: 3-keyIndex ]
					ifFalse: [
						keys := (keys copyFrom: 1 to: keyIndex-1), (keys copyFrom: keyIndex+1 to: keys size).
						values := (values copyFrom: 1 to: keyIndex-1), (values copyFrom: keyIndex+1 to: values size) ].
				answer]].
	keys = aString ifTrue: [
		answer := values.
		keys := nil.
		values := nil.
		^ answer ].
	^ aBlock lines! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50467684!
testWithGraphWithoutEdges

	| graph result |

	graph := Graph edges: #() nodes: (Array with: 'a' with: 'b').

	result := (TopologicalSort for: graph) lines.

	self
		assert: (result includes: 'a');
		assert: (result includes: 'b')! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16904067!
toDoFromWhileWithCounts: blockBodyTempCounts init: incrInit limit: limitInitOrNil
	"If the receiver, a whileTrue: loop, represents a to:[by:]do: loop
	 then answer the replacement to:[by:]do:, otherwise answer nil."
	| variable increment limit toDoBlock body test |
	self assert: (selector key == #whileTrue:
				and: [incrInit isAssignmentNode]).
	(limitInitOrNil notNil "limit should not be referenced within the loop"
	  and: [(blockBodyTempCounts at: limitInitOrNil variable ifAbsent: [0]) ~= 1]) ifTrue:
		[^nil].
	body := arguments last statements.
	(variable := incrInit variable) isTemp ifFalse:
		[^nil].
	(increment := body last toDoIncrement: variable) ifNil:
		[^nil].
	receiver statements size ~= 1 ifTrue:
		[^nil].
	test := receiver statements first.
	"Note: test should really be checked that <= or >= comparison
	jibes with the sign of the (constant) increment"
	(test isMessageNode
	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:
		[^nil].
	"The block must not overwrite the limit"
	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable is: limit]]]) ifTrue:
		[^nil]. 
	toDoBlock := BlockNode statements: body allButLast returns: false.
	toDoBlock arguments: {variable}.
	^MessageNode new
		receiver: incrInit lines
		selector: (SelectorNode new key: #to:by:do: code: #macro)
		arguments: { limit. increment. toDoBlock }
		precedence: precedence! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16936421!
loadFrom: aFileEntry
" Load all preferences from file, update the existing preferences with the data from file "
	(SmartRefStream restoreFromFile: aFileEntry) do: [:aPref | 
		self 
			name: aPref name 
			description: aPref description 
			category: aPref category 
			type: aPref type 
			value: (aPref instVarNamed: #lines)	 " We want the raw value "]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461397!
> aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^aMagnitude < self lines! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16833862!
removeProperty: propName ifAbsent: aBlock
	"Remove the property propName if it exists.
	 Answer the evaluation of aBlock if the property is missing."
	| value |
	value := self propertyValueAt: propName ifAbsent: [^aBlock lines].
	self penultimateLiteral: (self penultimateLiteral copyWithout:
									(Association
										key: propName
										value: value)).
	^value! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16799658!
runMessageCategoryTests
	
	selectedMessageCategory ifNotNil: [ | selectedClass suite |
		selectedClass := Smalltalk classNamed: selectedClassName.
		suite := TestSuite forMessageCategoryNamed: selectedMessageCategory of: selectedClass categorizedWith: classOrganizer.
		(ProgressiveTestRunner for: suite) lines ]
	
	! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400947!
assertValues: anArray
	| values |
	values := collection collect: [ :each | each lines ].
	self 
		assert: anArray asArray = values asArray
		description: 'Expected: ' , anArray asArray printString , 
			', but got ' , values asArray printString! !
!TestRunner methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16985774!
runSuite: suite with: aBlock
	running ifNotNil: [ ^ self inform: 'already running' ].
	suite addDependent: self.
	totalTests := suite tests size.
	completedTests := 0.
	running := [
	[ result := aBlock lines ] ensure: [
		running := nil.
		suite removeDependent: self.
		runSemaphore signal.
		UISupervisor whenUIinSafeState: [
			self updateWindow: result.
			self suiteRan. ]]] newProcess.
	self runWindow.
	self suiteRan.
	running
		name: 'TestRunner';
		priority: Processor userSchedulingPriority;
		resume.! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50504571!
blockWithTemporariesDeclaration
	
	[ | a | ] lines! !
!Array methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50456892!
removeType: aType ifAbsent: anAbsentBlock

	| typeIndex |

	typeIndex := self indexOf: aType ifAbsent: [ ^anAbsentBlock lines ].

	self replaceFrom: typeIndex to: self size - 1 with: self startingAt: typeIndex + 1.
	self at: self size put: nil! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50539307!
rangesIn: aBlockRange toReplacementParametersFrom: replacementParameter with: anExtraMapping

	| rangesInsideBlockRange rangesOffsetToBlock variableToParametrizeRangeToReplacingParameter offset |

	variableToParametrizeRangeToReplacingParameter := replacementParameter rangesOfVariablesToParametrizeToReplacingParameterWith: anExtraMapping.
	rangesInsideBlockRange := variableToParametrizeRangeToReplacingParameter select: [:rangeToReplacement |
		aBlockRange includes: rangeToReplacement key first].
	offset := aBlockRange first - 1.
	rangesOffsetToBlock := rangesInsideBlockRange collect: [:rangeToReplacement |
		Association key: rangeToReplacement key - offset value: rangeToReplacement lines].

	^rangesOffsetToBlock! !
!Mutex methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16918284!
critical: aBlock ifWouldBlock: unprotectedBlock

	self wouldBlock ifTrue: [ ^unprotectedBlock lines ].
	^self critical: aBlock! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50388943!
= aBag
	"Two bags are equal if
	 (a) they are the same 'kind' of thing.
	 (b) they have the same size.
	 (c) each element occurs the same number of times in both of them"

	self == aBag ifTrue: [ ^ true ].		"Any object is equal to itself"
	(aBag is: #Bag) ifFalse: [ ^ false ].
	self size = aBag size ifFalse: [ ^ false ].
	contents associationsDo: [ :assoc |
		(aBag occurrencesOf: assoc key) = assoc lines
			ifFalse: [ ^ false ]].
	^true! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50470732!
performWithFormulaWithFloat

	self assert: (formulaOfTenPesos perform: messageName with: 1.01) lines = 
		(formulaOfTenPesos lines perform: messageName with: 1.01 lines)! !
!DebuggerMethodMap methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16845572!
privateTempAt: index in: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents

	^self 
		privateTempAt: index 
		in: aContext 
		startpcsToBlockExtents: theContextsStartpcsToBlockExtents 
		ifXtraBindings: [ :xtraBinding | xtraBinding lines ] 
		ifNot: [ :ref | self privateDereference: ref in: aContext ]! !
!RxParser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50519727!
ifSpecial: aCharacter then: aBlock
	"If the character is such that it defines a special node when follows a $\,
	then create that node and evaluate aBlock with the node as the parameter.
	Otherwise just return."

	| classAndSelector |
	classAndSelector := BackslashSpecials at: aCharacter ifAbsent: [^self].
	^aBlock value: (classAndSelector key new perform: classAndSelector lines)! !
!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400493!
methodWithCopiedAndAssignedTemps
	| blk "0w" a "0w" b "0w" c "0w" t "0w" r1 "0w" r2 "0w" |
	a := 1. "1w"
	b := 2. "1w"
	c := 4. "1w"
	t := 0. "1w"
	blk "5w" := ["2" t  "3w" := t "3r" + a "3r" + b "3r" + c "3r" ] "4".
	r1 "5w" := blk "5r" lines.
	b "5w" := -100.
	r2 "5w" := blk "5r" lines.
	^r1 "5r" -> r2 "5r" -> t "5r"

	"a: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read
	 b: main(read(),write(0,1,5)), block(read(3),write()) => remote; write follows contained read
	 blk: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5
	 c: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read
	 r1: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5
	 r2: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5
	 t: main(read(5),write(0,1)), block(read(3),write(3)) => remote; read follows contained write"


	"(Parser new
		encoderClass: EncoderForV3;
		parse: (self class sourceCodeAt: #methodWithCopiedAndAssignedTemps)
		class: self class) generateUsingClosures: #(0 0 0 0)"! !
!StepMessage methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16967153!
valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast answer |
	numArgs ifNil: [numArgs := selector numArgs].
	nArgs := arguments ifNil: [0] ifNotNil: [arguments size].
	lastEvaluationTime ifNil: [ lastEvaluationTime := millisecondClock ].
	millisecondsSinceLast := millisecondClock - lastEvaluationTime.
	lastEvaluationTime := millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self lines ].
	[
		arguments
			ifNil: [ answer := receiver perform: selector with: millisecondsSinceLast]
			ifNotNil: [ answer := receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]
	] ifError: [ :err :rcvr |
		receiver
			stopStepping;
			setProperty: #errorOnStep toValue: true.
		{ 'Error while stepping: '. self. rcvr. err } print.
		"Install the old error handler, so we can re-raise the error"
		rcvr error: err.
	].
	^answer! !
!DisplayScreen methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16851158!
restoreAfter: aBlock
	"
	- Evaluate the block
	- Update host OS Display
	- Wait for a mouse click
	- And then restore the Morphic World"

	aBlock lines.
	self forceToScreen.
	Sensor waitButton.
	self runningWorld ifNotNil: [ :w | w fullRepaintNeeded ]! !
!Morph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16913798!
findDeepSubmorphThat: block1 ifAbsent: block2 
	self
		allMorphsDo: [:m | (block1 value: m)
				== true ifTrue: [^ m]].
	^ block2 lines! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50470786!
performWithMeasureWithFormula

	self assert: (self twentyPesos perform: messageName with: formulaOfTenPesos) lines = 
		(self twentyPesos lines perform: messageName with: formulaOfTenPesos lines)! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16799693!
addInstVar

	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		(AddInstanceVariableApplier on: self for: aClass) lines ].! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50497318!
runDenotativeObjectTests

	self selectedClassOrMetaClass ifNotNil: [ :aDenotativeObject | | suite |
		suite := TestSuite named: 'Tests of ', aDenotativeObject soleInstance name asString.
		aDenotativeObject selectors do: [ :aSelector |
			aSelector isTestSelector ifTrue: [ suite addTest: (DenotativeObjectTestCase for: aDenotativeObject>>aSelector)]].
		(DenotativeObjectProgessiveTestRunner for: suite) lines ]

	! !
!ExtractMethodApplier methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16862795!
findReplacementsWith: newMessage

	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: methodToExtractCodeFrom to: newMessage.
	finder lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461460!
equalsSimpleMeasure: aMeasure

	^self lines = aMeasure! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50454678!
test07ErrorsDetectIfNone

	| typeChecker error |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithManyTypeErrors }.
	typeChecker lines.

	error := typeChecker errorsDetect: [ :anError | true ] ifNone: [ self fail ].
	self assert: #date equals: error selector key ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461613!
measures

	^self lines measures! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16936352!
at: symbolName
	^ (self instanceAt: symbolName) lines! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16956685!
withIndexDo: elementAndIndexBlock separatedBy: separatorBlock
	"Evaluate the elementAndIndexBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	1 to: self size do: [:index |
		index = 1 ifFalse: [separatorBlock lines].
		elementAndIndexBlock value: (self at: index) value: index]! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16793457!
whileFalse
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the receiver, as long as its value is false."
 
	^ [self lines] whileFalse: []! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16960218!
classOfLocalBindingNamed: aName in: aClass 
	
	^  (aClass localBindingOf: aName) ifNotNil: [ :aBinding | aBinding lines class ]! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50426529!
test05DoesNotIncludeNotExtractableSourceCode

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. 100'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).! !
!Parser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16928566!
correctSelector: proposedKeyword wordIntervals: aSpots exprInterval: expInt ifAbort: abortAction
	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."

	| correctSelector userSelection delta adjustedSpots |
	"If we can't ask the user, assume that the keyword will be defined later"
	self interactive ifFalse: [^proposedKeyword asSymbol].
	
	"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"
	"
	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])
		ifFalse: [ ^ proposedKeyword asSymbol ].
	"

	userSelection := requestor selectionInterval.

	delta := self sourceDelta.
	adjustedSpots := aSpots collect: [ :interval | interval first + delta to: interval last + delta ].
	requestor selectFrom: adjustedSpots first first to: adjustedSpots last last.

	correctSelector := UnknownSelector name: proposedKeyword.
	correctSelector ifNil: [^abortAction lines].

	requestor selectInvisiblyFrom: userSelection first to: userSelection last.

	self substituteSelector: correctSelector keywords wordIntervals: adjustedSpots.
	^(proposedKeyword last ~~ $:
	   and: [correctSelector last == $:])
		ifTrue: [abortAction lines]
		ifFalse: [correctSelector]! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400825!
testSample11
	| blockClosures materialized |

	blockClosures _ self bc11.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first lines = materialized first lines.
	self assert: blockClosures second lines = materialized second lines.
	self deny: blockClosures first lines = materialized first lines.
	self assert: blockClosures second lines = materialized second lines.
	self deny: blockClosures first lines = materialized first lines.

	blockClosures _ self bc11.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first lines = materialized first lines.
	self assert: blockClosures second lines = materialized second lines.
	self assert: blockClosures first lines = materialized first lines.
	self assert: blockClosures second lines = materialized second lines.
	self assert: blockClosures first lines = materialized first lines.! !
!True methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16999475!
and: alternativeBlock 
	"Nonevaluating conjunction -- answer the value of alternativeBlock since
	the receiver is true."

	^alternativeBlock lines! !
!False methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16864841!
ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer the value of falseAlternativeBlock. Execution does not
	actually reach here because the expression is compiled in-line."

	^falseAlternativeBlock lines! !
!Collection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16828666!
do: elementBlock separatedBy: separatorBlock
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst := true.
	self do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock lines].
		elementBlock value: element]! !
!UpdatingLabelMorph class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 17004725!
initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (Preferences at: #windowTitleFont)
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #lines;
		setBalloonText: [ Date today asString ].

	^ newInst! !
!LayoutMorph class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50353391!
launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random := Random new.
	b1 := PluggableButtonMorph model: [ Date today print ] action: #lines label: 'Date'.
	b2 := PluggableButtonMorph model: [ Time now print ] action: #lines label: 'Time'.
	b3 := PluggableButtonMorph model: [ SystemVersion current print ] action: #lines label: 'Version'.
	b4 := PluggableButtonMorph model: [ random next print ] action: #lines label: 'Random'.
	buttons := {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row := LinearLayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!RenameTemporaryTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50438183!
test08RenameChangesReferencesFromOldVariableToNewVariable

	| methodNode oldVariable newVariable rename newMethodNode assigmentNode |
	
	oldVariable := 'old'.
	newVariable := 'new'.
	
	methodNode := self methodNodeOf: 'm1 | ', oldVariable, ' | ', oldVariable, ' := 1 + ', oldVariable.
	
	rename := RenameTemporary from: oldVariable to: newVariable in: methodNode.
	newMethodNode := rename methodNodeAfterApply.
	
	assigmentNode := newMethodNode block statements first.
	self assert: newVariable equals: assigmentNode variable name.
	self assert: newVariable equals: assigmentNode lines arguments first name.! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400957!
evaluateCopyOf: aBlock
	aBlock copy lines! !
!InlineTemporaryVariable class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16885965!
findTemporaryNamed: temporaryName atUsage: usageInterval inMethodNode: aMethodNode

	| oldVariableNodeAndUsageInterval parseNodesPath |

	parseNodesPath := aMethodNode parseNodesPathAt: usageInterval first ifAbsent: [self signalSelectedIntervalIsNotATemporary].
	oldVariableNodeAndUsageInterval := parseNodesPath
		detect: [:anAssociation |
			| parseNode |
			parseNode := anAssociation key.
			(parseNode isTemp and: [parseNode isNamed: temporaryName])]
		ifNone:[self signalSelectedIntervalIsNotATemporary].

	^{oldVariableNodeAndUsageInterval key. oldVariableNodeAndUsageInterval lines}.
! !
!VariableScopeFinder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 17006916!
visitAssignmentNode: anAssignmentNode
	"Answer the minimum enclosing node for aVariabe or nil if none.
	 If the variable is accessed in more than one subexpression then anAssignmentNode
	 is the enclosing node, otherwise it is which ever single node that includes it, if any."
	^self
		enclosingNodeFor: [:aBlock|
							aBlock
								value: anAssignmentNode lines;
								value: anAssignmentNode variable]
		of: anAssignmentNode! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50457172!
typeCheck

	^(MethodTypeChecker for: self) lines! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50454703!
test09ProblemsCollectsTypeCheckersProblems

	| typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithNoReturnTypes }.
	typeChecker := typeChecker lines.

	self assert: typeChecker problems notEmpty
! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50454691!
test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound

	| typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker lines.

	typeChecker errorsDetect: [ :aTypeCheckProblem | true ] ifNone: [ ^self ].

	self fail

	! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50443074!
builderForNotEqualOrNotIdenticalToClass: aMessageNode

	^EqualsTypeCastApplierBuilder
		to: aMessageNode receiver arguments first key lines
		on: aMessageNode receiver receiver receiver
		during: aMessageNode arguments second
		rejectingDuring: aMessageNode arguments first! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50470702!
performWithCompoundMeasureWithFormula

	self assert: ((self tenDollars + self tenPesos) perform: messageName with: formulaOfTenPesos) lines = 
		((self tenDollars + self tenPesos) lines perform: messageName with:formulaOfTenPesos lines )! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50446532!
m1_temps_not_in_block_read_write_temp

	| n1 n2 t1 |

	t1 := 1.
	[t1 := t1 + 1 ] lines.

	n1 := n2 := 2.
	n1 := n1 + n2.

	^t1! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50457652!
rawTypesOf: aVariableName mappingToIndexWith: variableNameToIndexMapping into: anArrayOfRawTypes ifAbsent: anAbsentBlock

	| variableIndex |

	variableNameToIndexMapping ifNil: [ ^anAbsentBlock lines ].
	variableIndex := variableNameToIndexMapping at: aVariableName ifAbsent: [ ^anAbsentBlock lines ].

	^anArrayOfRawTypes at: variableIndex! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16849003!
keyAtValue: value ifAbsent: exceptionBlock
	"Answer the key that is the external name for the argument, value. If 
	there is none, answer the result of evaluating exceptionBlock.
	: Use =, not ==, so stings like 'this' can be found.  Note that MethodDictionary continues to use == so it will be fast."
 
	self associationsDo: 
		[:association | value = association lines ifTrue: [^association key]].
	^exceptionBlock lines! !
!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400544!
methodWithCopiedTemps
	| a b c r |
	a := 1.
	b := 2.
	c := 4.
	r := [a + b + c] lines.
	b := nil.
	r

	"Parser new
		parse: (self class sourceCodeAt: #methodWithCopiedTemps)
		class: self class"

	"(Parser new
		encoderClass: EncoderForV3;
		parse: (self class sourceCodeAt: #methodWithCopiedTemps)
		class: self class) generateUsingClosures: #(0 0 0 0)"! !
!False methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16864881!
orNot: alternativeBlock

	^alternativeBlock lines not! !
!ChangeSelector class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50458437!
addActualImplementorsOf: anOldSelector forTypes: receiverTypes to: implementors andActualSendersTo: senders inSystem: aSystem

	| actualImplementors actualSendersCollector |

	receiverTypes do: [ :aType |
		actualImplementors := (aSystem actualImplementorsOf: anOldSelector in: aType)
			collect: [ :anImplementor | anImplementor compiledMethodIfAbsent: [ anImplementor ]].
		implementors addAll: actualImplementors ].

	actualSendersCollector := MultiImplementorsActualMessageSendsCollector for: implementors.
	actualSendersCollector lines.

	senders addAll: actualSendersCollector messageList.

	! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16899034!
printWithClosureAnalysisOn: aStream indent: level

	key isVariableBinding
		ifTrue:
			[key key isNil
				ifTrue:
					[aStream nextPutAll: '###'; nextPutAll: key lines soleInstance name]
				ifFalse:
					[aStream nextPutAll: '##'; nextPutAll: key key]]
		ifFalse:
			[key storeOn: aStream]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50497265!
runDenotativeObjectMessageCategoryTests

	selectedMessageCategory ifNotNil: [ | classlessObject suite |
		classlessObject := (Smalltalk classNamed: selectedClassName) class.
		suite := TestSuite named: 'Tests of ', selectedMessageCategory.
		(metaClassOrganizer listAtCategoryNamed: selectedMessageCategory) do: [ :selector |
			selector isTestSelector ifTrue: [ suite addTest: (DenotativeObjectTestCase for: classlessObject>>selector)]].
		(DenotativeObjectProgessiveTestRunner for: suite) lines ]

	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16962959!
withNodeUnderCursorDo: aDoBlock ifAbsent: anAbsentBlock

	self 
		withMethodNodeAndClassDo: [ :currentMethodNode :currentClass |
			currentMethodNode 
				withParseNodeIncluding: self startIndex
				do: aDoBlock
				ifAbsent: anAbsentBlock ] 
		ifErrorsParsing: [ :arg1 | anAbsentBlock lines ].! !
!CompiledMethod class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16836386!
field: aFieldName from: tokens ifAbsentOrNil: aBlock

	| fieldValue fieldIndex |
	
	fieldIndex := tokens indexOf: aFieldName ifAbsent: [ ^aBlock lines ].
	fieldValue := tokens at: fieldIndex + 1 ifAbsent: [ ^aBlock lines ].
	
	^ fieldValue ifNil: aBlock! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50426900!
test17KeepsOriginalSelection

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 1 factorial. 1 factorial. 1 factorial. 1 factorial. 1 factorial'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (17 to: 40) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (17 to: 40) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (43 to: 66) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50427102!
test23WhenExtractingAllLiteralsUsesStringComparison

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 1+2. 2+1.'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 4) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 4) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (11 to: 11) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16780792!
keysAndValuesDo: aBlock
	"Enumerate the receiver with all the keys and values."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		(propertyOrPragma := self basicAt: i) isVariableBinding
			ifTrue: [aBlock value: propertyOrPragma key value: propertyOrPragma lines]
			ifFalse: [aBlock value: propertyOrPragma keyword value: propertyOrPragma]]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16961575!
renameInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor

	(RenameInstanceVariableApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) lines! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16984632!
shouldnt: aBlock description: aString

	self deny: aBlock lines description: aString
			! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16786525!
detect: aBlock ifNone: exceptionBlock 
	"Refer to the comment in Collection|detect:ifNone:."

	contents keysDo: [:each | (aBlock value: each) ifTrue: [^ each]].
	^ exceptionBlock lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461390!
<= aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand"

	^(aMagnitude < self lines) not! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16885532!
inlineAssignment: assignmentToInline upTo: anIndex

	| assignmentNode assignmentNodeValue expression expressionRange |

	assignmentNode := self assignmentNodeToInline: assignmentToInline.
	assignmentNodeValue := assignmentNode lines.
	expressionRange := (methodNode completeSourceRangesOf: assignmentNodeValue ifAbsent: [self shouldNotHappen])
		detect: [:range | assignmentToInline includesAllOf: range].
	expression := methodNode sourceText copyFrom: expressionRange first to: expressionRange last.

	self inlineAssignmentNode: assignmentNode withExpression: expression upTo: anIndex;
		removeAssignment: assignmentToInline.! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16825027!
packageOfSystemCategory: aSystemCategory ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock lines ].
	^ InstalledPackages
		detect: [:ea | ea includesSystemCategory: aSystemCategory]
		ifNone: errorBlock! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50344389!
at: key ifAbsentOrNilPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	| index assoc newObject |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc ifNotNil: [
		assoc lines ifNil: [ assoc value: aBlock lines ].
		^assoc lines ].
	newObject := aBlock lines.
	self atNewIndex: index put: (self associationClass key: key value: newObject).
	^ newObject! !
!ContextPart methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16838899!
send: selector to: rcvr with: arguments super: superFlag 
	"Simulate the action of sending a message with selector arguments
	 to rcvr. The argument, superFlag, tells whether the receiver of the
	 message was specified with 'super' in the source method."

	^self send: selector
		to: rcvr
		with: arguments
		lookupIn: (superFlag
					ifTrue: [self method methodClassAssociation lines superclass]
					ifFalse: [self objectClass: rcvr])! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50426871!
test16FindsRepetitionsOfParameter

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1: p p+1. p+1'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (7 to: 9) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (7 to: 9) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (12 to: 14) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461635!
lessThanSimpleMeasure: aMeasure

	^self lines lessThanSimpleMeasure: aMeasure! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461496!
moduloCompoundMeasure: aMeasureBag

	^self lines moduloCompoundMeasure: aMeasureBag! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50427210!
test27FindsWithMoreThanOneStatementAndFirstWithParentesis

	| sourceMethodName finder sourceMethod intervalToExtract newMessage methodsToExtractFrom replacement |

	sourceMethodName := classToRefactor compile: 'm1 (self m1). self m1'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 21) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
		
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 21) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50461534!
remainderSimpleMeasure: aMeasure

	^self lines remainderSimpleMeasure: aMeasure! !
!DecisionConditionCoverageReportBuilder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50501836!
selectBooleanSourceRanges: aCondition
	
	"Select the boolean source range declarations passing the covered boolean values referenced by them to aCondition.
	Return both the declarations that satisfies aCondition and their usages."
	
	| selectedDeclarations |
	selectedDeclarations := booleanValuesByDeclaration associations
		select: [ :sourceRangeAndCoveredValues | aCondition value: sourceRangeAndCoveredValues lines ]
		thenCollect: [ :sourceRangeAndCoveredValues | sourceRangeAndCoveredValues key ].
	
	^ self collectWithUsages: selectedDeclarations! !
!Editor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16853716!
wordSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current word; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	"if current selection is empty, then first select the entire word in which occurs before proceeding"
	self hasSelection ifFalse: [
		self selectWord ].
	self selectionIsEmptyOrSeparators ifTrue: [
		^ returnBlock lines ].! !
!Socket class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50585864!
tcpCreateIfFail: failBlock
	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."

	| sock |
	self initializeNetwork.
	sock := self newTCP.
	sock isValid ifFalse: [^ failBlock lines].
	^ sock
! !
!DirectoryEntry methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16850162!
at: localFileName ifAbsent: block

	^ [self at: localFileName]
		on: FileDoesNotExistException
		do: [:ex | block lines]! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50447437!
warningsDetect: aCondition ifNone: noneBlock

	| warning |

	typeCheckers do: [ :typeChecker |
		warning := typeChecker warningsDetect: aCondition ifNone: [ nil ].
		warning ifNotNil: [ ^warning ]].

	^noneBlock lines! !
!CompiledMethodCoverageReport methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50501302!
selectSourceRangesByCoverageRatio: aBlock
	
	^ coverageRatioBySourceRange associations
		select: [ :sourceRangeAndCoverageRatio | aBlock value: sourceRangeAndCoverageRatio lines ]
		thenCollect: [ :sourceRangeAndCoverageRatio | sourceRangeAndCoverageRatio key ]! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 17000622!
ifNotNil: ifNotNilBlock ifNil: nilBlock 
	"If I got here, I am nil, so evaluate the block nilBlock"

	^ nilBlock lines! !
!PluggableListMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50334663!
deleteAction
	"Handles deleting action, which happens when the user presses backspace or delete key within me"
	| deleteActionBlock |
	deleteActionBlock := self valueOfProperty: #deleteAction ifAbsent: nil.
	deleteActionBlock isNil
		ifTrue: [ self flash ]
		ifFalse: [ deleteActionBlock lines ].
	^self! !
!ByteArray methodsFor: 'as yet unclassified' library: #MinimalKernel01 stamp: 'BSN 11/7/2025 14:58:20' prior: 50365590!
indexOf: anInteger startingAt: start ifAbsent: aBlock

	| ans |
	(anInteger isInteger and: [
		anInteger >= 0 and: [
		anInteger <= 255 ] ]) ifFalse: [ ^0 ].
	ans := ByteArray indexOfByte: anInteger inBytes: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock lines ]
		ifFalse: [ ans ]! !
!FileIOAccessor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16866236!
deleteFile: fullPathName ifAbsent: failBlock 
	^(self
			try: [self primDeleteFileNamed: fullPathName asUtf8Bytes]
			forFileNamed: fullPathName) 
		ifFalse: [^ failBlock lines]! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400615!
testSample03
	| blockClosure materialized |
	blockClosure _ self bc03.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure lines = materialized lines.
	self assert: blockClosure lines = materialized lines.
	self assert: blockClosure lines = materialized lines.! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50426723!
test11FindsRepetitionsWithMoreThanTwoStatementsSelection

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10 factorial. 15 factorial. 20 factorial. true ifTrue: [ 10 factorial. 15 factorial. 20 factorial]'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 43) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (61 to: 100) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (4 to: 43) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16962919!
runTestSuite: aTestSuite

	(ProgressiveTestRunner for: aTestSuite) lines
	
	! !
!Number methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50475817!
convertTo: aUnit ifSuccessful: aSuccessfulBlock ifFails: aFailureBlock

	| convertedMeasure |
	
	convertedMeasure := [ self convertTo: aUnit ] 
		on: CanNotConvertMeasureException 
		do: [ :anError | ^aFailureBlock lines ].
		
	^aSuccessfulBlock value: convertedMeasure ! !
!MoveMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50540864!
replaceDependenciesOnMethodToMove
	| replacer methodNode |
	
	methodNode := methodNodeToMove.
	replacer := CodeForNodeToMove 
		methodNode: methodNode
		variableToAcessThrough: variableToAccessTarget 
		onNode: methodNode
		parameterNeeded: parameterNeeded
		targetClass: targetClass .
	resultAfterReplaceDependencies := replacer lines.! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400378!
testInlineBlockCollectionLR1
	"Test case from Lukas Renggli"
	| col |
	col := OrderedCollection new.
	1 to: 11 do: [ :each | col add: [ each ] ].
	self assert: (col collect: [ :each | each lines ]) asArray = (1 to: 11) asArray! !
!TrieNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16999095!
at: aString ifAbsent: aBlock characterIndex: i

	| child |
	child := self childFor: aString characterIndex: i orAdd: false.
	child ifNil: [ ^aBlock lines ].
	^child at: aString ifAbsent: aBlock characterIndex: i + segmentSize! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16965881!
intervalCoversCompleteAstNodes 

	^ (self trimmed: (SourceCodeInterval from: initialNode lines first to: finalNode lines last)) = intervalToExtract
		or: [ (initialNode lines first to: (self trimmed: finalNode lines) last) = intervalToExtract ]! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50400689!
testSample07
	| blockClosures materialized |

	blockClosures _ self bc07.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first lines = materialized first lines.
	self assert: blockClosures second lines = materialized second lines.
	self deny: blockClosures third lines = materialized third lines.
	self assert: blockClosures second lines = materialized second lines.
	self deny: blockClosures first lines = materialized first lines.
	self deny: blockClosures third lines = materialized third lines.
	self deny: blockClosures first lines = materialized first lines.

	blockClosures _ self bc07.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first lines = materialized first lines.
	self assert: blockClosures second lines = materialized second lines.
	self assert: blockClosures third lines = materialized third lines.
	self assert: blockClosures second lines = materialized second lines.
	self assert: blockClosures first lines = materialized first lines.
	self assert: blockClosures third lines = materialized third lines.
	self assert: blockClosures first lines = materialized first lines.! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50504585!
blockWithWrittenTemporaryVariable

	[ |a| a :=1 ] lines! !
!DirectoryEntry methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16850209!
removeKey: localFileName ifAbsent: failBlock
	self fileAccessor deleteFile: (self // localFileName) pathName ifAbsent: [^failBlock lines].
	self invalidateChildren.! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16786533!
do: aBlock 
	contents associationsDo: [:assoc | assoc lines timesRepeat: [aBlock value: assoc key]]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16799861!
addCategoryAsSubclassResponsibilitySelectors


	| methodsOfCategory |
			
	methodsOfCategory := self messageList.
	
	methodsOfCategory do: [ :selectedSelector | selectedSelector ifNotNil: 
			[(AddAsSubclassResponsibilityApplier on: self for: self selectedClassOrMetaClass>>selectedSelector) lines ]
		].! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50453856!
valueParameter: aBlock

	aBlock lines.
	! !
!CodeForNodeToMove methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50531812!
visitAssignmentNode: anAssignmentNode 
	| assigmentValue completeRangesOfassigmentNode resultForValue setterSelectorAsString |
	"self halt."
	anAssignmentNode variable isTemp ifTrue: [^super visitAssignmentNode: anAssignmentNode].
	completeRangesOfassigmentNode := self firstUnseenIntervalFor: anAssignmentNode.
	resultForValue := (CodeForNodeToMove 
					methodNode: methodNode
					variableToAcessThrough: variableToAccesThrough 
					onNode: anAssignmentNode lines
					parameterNeeded: parameterNeeded
					targetClass: targetClass) lines.
	(self shouldAddParenthesisOnValueOf: anAssignmentNode)
		ifTrue: [assigmentValue := '(', resultForValue sourceCode , ')'.] 
		ifFalse: [assigmentValue := resultForValue sourceCode .].
	
	anAssignmentNode variable isLiteralVariableNode 
		ifTrue: [setterSelectorAsString := self setterForClassVariable: anAssignmentNode variable name.]
		ifFalse: [setterSelectorAsString := self setterForInstanceVariable: anAssignmentNode variable name.].
	
	methodNode methodClass methodDict 
					at: setterSelectorAsString asSymbol 
					ifPresent: [ :aMethod | ]
					ifAbsent: [
						methodToCompileOnSourceClass add: (setterSelectorAsString, ' anObject', String newLineString, String tab, '^', anAssignmentNode variable name, ' := anObject.').
						].

	
	self registerInterval: completeRangesOfassigmentNode withModification: (parameterNeeded parameterName , ' ', setterSelectorAsString, ' ', assigmentValue).
	methodToCompileOnSourceClass addAll: resultForValue methodToCompileOnSourceClass.
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50507431!
test028_DoesNotCoverSuper

	"TODO: Don't cover the super receiver in message sends for now, as it has to be handled separately. NPM"
	
	self collectCoverageForExampleNamed: #lines.
	
	self assertNumberOfCoveredRangesFor: #lines is: 1 .
	self assert: #lines hasBeenCoveredFrom: 381 to: 385 as: 'value'.! !
!MethodWorksAsGetterVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50532373!
visitBlockNode: aBlockNode 
	(aBlockNode statements size = 1) ifFalse: [returnMethodIsNotGetterClousure lines].
	(aBlockNode statements first expr name = classVariableName) 
		ifFalse: [returnMethodIsNotGetterClousure lines]
		ifTrue: [returnMethodIsGetterClousure lines].! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 16849225!
valuesDo: aBlock 
	"Evaluate aBlock for each of the receiver's keys."

	self associationsDo: [:association | aBlock value: association lines]! !
!WriteStream methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 17019788!
withAttributes: attributes do: streamBlock 
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock lines ].

	pos1 := self position.
	val := streamBlock lines.
	attributes do: [:attribute |
		collection
			addAttribute: attribute
			from: pos1 + 1
			to: self position].
	^ val! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50446545!
m10
   | t1 |

   t1 := 0.   "<-- it will save SmallInteger in (method additionalState contextTypesAt: 1) at: 2."
   [ | t2 | t2 := 'hello' ] lines. "<-- it will save String in (method additionalState contextTypesAt: 2) at: 1"

   [ | t3 | t3 := 3.14 ] lines. "<-- it will save Float in (method additionalState contextTypesAt: 3) at: 1"! !
!TranscriptTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50423317!
assertTranscriptContentsAdded: expectedAddedString after: aBlock
	
	| transcriptContentsBeforeBlockEvaluation |
	"Transcript clear."
	transcriptContentsBeforeBlockEvaluation := Transcript contents.
	aBlock lines.
	self assert: Transcript contents equals: transcriptContentsBeforeBlockEvaluation, expectedAddedString.! !
!NoTypeCastApplier methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50446927!
typesIfCasting: aParseNode using: originalTypes ifNot: aNotBlock

	^aNotBlock lines! !
!WebServer methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:20' prior: 50592388!
authenticate: request realm: realm methods: accepted do: aBlock
	"Authenticates an incoming request using one of the accepted methods.

	Evaluates aBlock upon successful authentication. Responds with a 401
	(Unauthorized) if the authentication fails."

	| method resp |
	request headersAt: 'Authorization' do:[:authHeader|
		method := authHeader copyUpTo: Character space.
		(accepted anySatisfy:[:auth| auth sameAs: method]) ifTrue:[
			(self authAccept: method request: request realm: realm header: authHeader)
				ifTrue:[^aBlock lines].
		].
	].

	"Send a 401 (unauthorized) response"
	resp := request newResponse protocol: 'HTTP/1.1' code: 401.
	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.
	accepted do:[:auth| | hdr |
		hdr := self authHeader: auth request: request realm: realm.
		hdr ifNotNil:[resp addHeader: 'WWW-Authenticate' value: hdr].
	].
	request sendResponse: resp content: '<html><head><title>401 Unauthorized</title></head><body><h1>401 Unauthorized</h1><p>You are not authorized to access the requested URL</p></body></html>'.
! !
!WebUtils class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50594159!
oAuthSign: webRequest url: requestUrl extra: postFields using: params
	"Sign the given webRequest using the set of oauth parameters provided"

	| epoch timestamp nonce normalized baseString query signature key header extraKeys baseUrl |

	"Allow providing an oauth_timestamp; HOWEVER this is only useful for
	tests etc. For actual API calls the timestamp *must* match real-time closely
	or else the request will be rejected"

	timestamp := params at: 'oauth_timestamp' ifAbsent:[
		"Timestamp is relative to Jan. 1st 1970 GMT"
		epoch := DateAndTime year: 1970 day: 1 hour: 0 minute: 0 second: 0 
			offset: (Duration seconds: 0).
		(DateAndTime now asUTC - epoch) totalSeconds.
	].

	"Same for nonces (although nonces can be reused)"
	nonce := params at: 'oauth_nonce' ifAbsent:[UUID new hex].

	"Assemble the required parameters. Start with the (POST) body fields."
	normalized := (postFields as: Dictionary) associations asOrderedCollection.

	"If present, extract any (GET) fields from the URL"
	(requestUrl copyAfter: $?) ifNotEmpty:[:fields|
		self decodeUrlEncodedForm: fields do:[:fkey :fval| normalized add: fkey -> fval]].

	"Keep the extra argument keys so we can exclude them below"
	extraKeys := Set newFrom: (normalized collect:[:assoc| assoc key]).
	normalized add:('oauth_nonce' -> nonce).
	normalized add: ('oauth_timestamp' -> timestamp asString).
	
	normalized add: (params associationAt: 'oauth_consumer_key').
	normalized add: (params associationAt: 'oauth_signature_method').
	normalized add: (params associationAt: 'oauth_version').

	(params includesKey: 'oauth_callback') ifTrue:[
		normalized add: (params associationAt: 'oauth_callback').
	].
	(params includesKey: 'oauth_token') ifTrue:[
		normalized add: (params associationAt: 'oauth_token').
	].
	(params includesKey: 'oauth_verifier') ifTrue:[
		normalized add: (params associationAt: 'oauth_verifier').
	].

	normalized := normalized sort:[:a1 :a2| 
		a1 key = a2 key 
			ifTrue:[a1 lines <= a2 lines]
			ifFalse:[a1 key <= a2 key]].

	query := String streamContents:[:s|
		normalized do:[:assoc|
			s nextPutAll: assoc key.
			s nextPutAll: '='.
			s nextPutAll: assoc lines percentEscapeUrlField.
		] separatedBy:[s nextPutAll: '&'].
	].

	baseUrl := (requestUrl copyUpTo: $?) copyUpTo: $#.
	baseString := webRequest method, 
		'&', baseUrl percentEscapeUrlField, 
		'&',  query percentEscapeUrlField.

	key := (params at: 'oauth_consumer_secret'), 
			'&', (params at: 'oauth_token_secret' ifAbsent:['']).
	(params at: 'oauth_signature_method') caseOf: {
		['HMAC-SHA1'] -> [
			signature := (WebUtils hmacSha1: baseString key: key) base64Encoded
		].
	} otherwise:[self error: 'Unsupported signature method'].

	header := String streamContents:[:s|
		s nextPutAll: 'OAuth '.
		"Even though we need to include the extra args in the computation,
		they do NOT go into the OAuth header field."
		normalized do:[:assoc|
			(extraKeys includes: assoc key) 
				ifFalse:[ s nextPutAll: assoc key, '="', assoc lines percentEscapeUrlField, '",']].
		s nextPutAll: 'oauth_signature="', signature percentEscapeUrlField, '"'.
	].

	webRequest headerAt: 'Authorization' put: header.! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50454638!
test04ProblemsDetectIfNone

	| typeCheckProblem typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithNoReturnTypes }.
	typeChecker := typeChecker lines.

	self assert: 1 equals: typeChecker problemsSize.

	typeCheckProblem := typeChecker problemsDetect: [ :aTypeCheckProblem | true ] ifNone: [ self fail ].
	self assert: typeCheckProblem receiver isMessageNode.
	self assert: #printString equals: typeCheckProblem selector key.
! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16793484!
whileNotNil: aBlock 
	"Unlike #whileTrue/False: this is not compiled inline."
	^ [self lines == nil] whileFalse: [aBlock lines]! !
!LinkedList methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16898725!
remove: aLink ifAbsent: aBlock  
	"Remove aLink from the receiver. If it is not there, answer the result of
	evaluating aBlock."

	| tempLink |
	aLink == firstLink
		ifTrue: [firstLink := aLink nextLink.
				aLink == lastLink
					ifTrue: [lastLink := nil]]
		ifFalse: [tempLink := firstLink.
				[tempLink ifNil: [^aBlock lines].
				 tempLink nextLink == aLink]
					whileFalse: [tempLink := tempLink nextLink].
				tempLink nextLink: aLink nextLink.
				aLink == lastLink
					ifTrue: [lastLink := tempLink]].
	aLink nextLink: nil.
	^aLink! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50554067!
moveInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor
	
	(RefactoringApplier moveInstanceVariableApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) lines! !
!ExtractMethodNewMethod class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16863323!
fromInterval: anIntervalToExtract of: aMethodToExtractCodeFrom to: newMessage categorizedAs: aCategory withArgumentNames: renamedArguments

	| trimmedIntervalToExtract newSourceCode |

	trimmedIntervalToExtract := anIntervalToExtract trimToMatchExpressionOn: aMethodToExtractCodeFrom sourceCode.
	self
		assert: newMessage selector canBeDefinedIn: aMethodToExtractCodeFrom methodClass;
		assertCanApplyRefactoringOn: aMethodToExtractCodeFrom at: trimmedIntervalToExtract;
		assert: newMessage hasValidParametersForExtracting: anIntervalToExtract from: aMethodToExtractCodeFrom notOptimizedMethodNode.

	"With the renamed arguments functionality, I want to signal errors at creation time, not at applying time.
	So I need to cheeck that renaming arguments is valid, and to do that I need to rename them all, that is why
	now the new source code is created at instantiation time and not applying time - Hernan."
	newSourceCode := (ExtractMethodNewMethodSourceCode
		fromInterval: trimmedIntervalToExtract
		of: aMethodToExtractCodeFrom
		to: newMessage
		withArgumentNames: renamedArguments) lines.

	^ self new
		initializeOf: aMethodToExtractCodeFrom
		in: aCategory
		newSourceCode: newSourceCode! !
!False methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16864864!
or: aBlock1 or: aBlock2 or: aBlock3

	"I sending value to aBlock3 to optimize the generated byte-code - Hernan"
	^aBlock1 lines or: [ aBlock2 lines or: [ aBlock3 lines ] ]! !
!SourceCodeIntervalPrecondition class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16965688!
valueFor: anIntervalToExtract of: aMethod

	^ (self for: anIntervalToExtract of: aMethod) lines! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16799744!
pushUpInstanceVariable

	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		(PushUpInstanceVariableApplier on: self at: aClass ) lines].! !
!DenotativeObjectTestResultWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50495704!
runSuite

	| suite |

	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(DenotativeObjectProgessiveTestRunner for: suite) lines.
	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50455665!
withActualMessageSendsOfAll: compiledMethods
	do: aMessageSendNodeBlock
	ifAbsent: absentBlock
	withPossibleMessageSends: shouldAddPossibleMessageSends
	sortingWith: aSortBlock
	using: aMethodNode

	| ranges sortedRanges sendersCollector sender |

	sender := class>>selector.
	ranges := Set new.
	compiledMethods do: [ :aCompiledMethod |
		sendersCollector := sender actualSendersOf: aCompiledMethod using: aMethodNode.
		ranges addAll: (sendersCollector sureMessageSends collect: aMessageSendNodeBlock).
		shouldAddPossibleMessageSends ifTrue: [
			ranges addAll: (sendersCollector possibleMessageSends collect: [ :aPossibleMessageSend | aMessageSendNodeBlock value: aPossibleMessageSend key])]].

	ranges isEmpty ifTrue: [ ^absentBlock lines ].
	sortedRanges := ranges asSortedCollection: aSortBlock.

	^sortedRanges ! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50470740!
performWithFormulaWithFraction

	self assert: (formulaOfTenPesos perform: messageName with: (1/3)) lines = 
		(formulaOfTenPesos lines perform: messageName with: (1/3) lines)! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16906392!
removeKey: key ifAbsent: errorBlock 
	"The interpreter might be using this MethodDict while
	this method is running!!  Therefore we perform the removal
	in a copy, and then atomically become that copy"
	| copy |
	copy := self copy.
	copy removeDangerouslyKey: key ifAbsent: [^ errorBlock lines].
	self become: copy! !
!OrderedDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16925717!
removeKey: key ifAbsent: aBlock 
	"Remove key (and its associated value) from the receiver. If key is not in
	the receiver, answer the result of evaluating aBlock. Otherwise, answer
	the value externally named by key."

	| answer |
	answer := super removeKey: key ifAbsent: [
		^ aBlock lines ].
	orderedKeys remove: key.
	^ answer! !
!MethodCategoriesPrompter methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16905345!
prompt: aPrompt ifNone: aNoneBlock

	| selectedCategoryIndex categoryName |
	
	selectedCategoryIndex := self promptCategory: aPrompt.
	selectedCategoryIndex = 0 ifTrue: [^ aNoneBlock lines].
	
	categoryName := selectedCategoryIndex = 1 ifTrue: [ self requestNewCategory ] ifFalse: [ categories at: selectedCategoryIndex ].
	categoryName isEmpty ifTrue: [ ^aNoneBlock lines ].
	
	^categoryName
	! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50334178!
recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active processor (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #lines 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	newArray at: 25 put: nil. "This is nil in Spur, which has immediate Characters."
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	newArray at: 29 put: nil. "This is nil in Spur, no compact classes."
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization.
	In Squeak these are: DoubleByteArray, WordArray, DoubleWordArray.
	Understand why."
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.
	newArray at: 36 put: nil. "was the prototype MethodContext"
	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: nil).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: nil).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: nil).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: nil).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: nil).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: nil).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: nil).

	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: nil).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray.! !
!OneLineEditorMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50555720!
keyStroke: aKeyboardEvent
	"Handle a keystroke event."

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].

	"Return - check for special action
	Note: Code below assumes that this was some
	input field reacting on Return."
	aKeyboardEvent isReturnKey ifTrue: [
		crAction ifNotNil: [
			"Break the keyboard focus so that the receiver can be safely deleted."
			"Is this needed at all? (jmv)"
			"aKeyboardEvent hand newKeyboardFocus: nil."
			^crAction lines ]].

	self pauseBlinking.
	self handleInteraction: [ self editor processKeystrokeEvent: aKeyboardEvent ].
	self updateFromContents.
	super keyStroke: aKeyboardEvent  "sends to keyStroke event handler, if any"! !
!AssignmentNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16784401!
equivalentTo: aParseNode

	^ aParseNode isAssignmentNode
		and: [ self variable equivalentTo: aParseNode variable ]
		and: [ self lines equivalentTo: aParseNode lines ]! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50454751!
test13HasErrorsReturnsFalseWhenNoErrorFound

	| typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker lines.

	self deny: typeChecker hasErrors ! !
!RelativeGregorianDate methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50479835!
absoluteDate
	"It is necessary to send #value for not assume that the dates of the time line filter are absolute ,
	and also it is necessary to send #value to the timespan in order to obtain a relative timespan"
	
	^(timeLineFilter next: timespan lines) lines! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16984403!
assert: anAction changes: aCondition 

	| after before |
	
	before := aCondition lines.
	anAction lines.
	after := aCondition lines.
	
	self deny: after = before! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16808546!
fileOutMethodAdditionsFor: class on: stream
	"Write out all the method changes for this class."

	| changes |
	changes := Set new.
	(self methodChangesAtClass: class name) associationsDo: [ :mAssoc |
		mAssoc lines == #add
			ifTrue: [ changes add: mAssoc key ]].
	changes isEmpty ifFalse: [
		class fileOutChangedMessages: changes on: stream.
		stream newLine ]! !
!ExtractMethodReplacementsFinder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16864013!
nodesToExtract

	^(NodesInRangeFinder in: sourceMethod for: intervalToExtract) lines! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16862191!
is: aRange equalTo: sourceInterval or: intervalToReplace 
	
	"When selecting literals like 1, the range first is one less than the initial character of the literal - Hernan"
	
	^aRange = sourceInterval 
		or: [ aRange = intervalToReplace
		or: [ aRange first + 1 = sourceInterval first and: [ aRange lines last = sourceInterval last]]]! !
!DenotativeObjectBrowserWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50494823!
addInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(DenotativeObjectAddCollaboratorApplier on: model for: aClass) lines ].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461444!
notInclusiveBetween: min andNotInclusive: max
	"Create local variable #val for best performance"

	| val |

	val := self lines.
	^val > min and: [val < max]! !
!OrderedCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16925238!
at: index ifAbsentPut: block
	"Return value at index, however, if value does not exist (nil or out of bounds) then add block's value at index (growing self if necessary)"

	| v |
	index <= self size ifTrue: [
		^ (v := self at: index)
			ifNotNil: [v]
			ifNil: [self at: index put: block lines]
	].
	[self size < index] whileTrue: [self add: nil].
	^ self at: index put: block lines! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50454622!
test03MethodsWithoutTypeAnnotationsLogsAProblem

	| typeChecker methodToCheck  |

	methodToCheck := TypeCheckerTestMethods >> #methodNotAnnotatingTypes.
	typeChecker := ManyMethodsTypeChecker forAll: { methodToCheck }.
	methodToCheck removeProperties.

	typeChecker lines.

	self assert: 1 equals: typeChecker problemsSize.
	self assert: typeChecker errorsIsEmpty.
	self assert: typeChecker warningsIsEmpty.
! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50446500!
m1: p1
   | t1 |

   t1 := 0.   "<-- it will save SmallInteger in (method additionalState contextTypesAt: 1) at: 2."
   [ | t2 | t2 := 'hello' ] lines. "<-- it will save String in (method additionalState contextTypesAt: 2) at: 1"

   [ | t3 | t3 := 3.14 ] lines. "<-- it will save Float in (method additionalState contextTypesAt: 3) at: 1"! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50426426!
test01FindsSelectionOnSourceMethod

	| sourceMethodName finder methodsToExtractFrom sourceMethod |
	
	sourceMethodName := classToRefactor compile: 'm1 10'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	self assert: finder hasOneReplacement.
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	self assert: (4 to: 5) equals: methodsToExtractFrom first intervalToExtract.
	self assert: sourceMethod equals: methodsToExtractFrom first methodToExtractFrom.! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50454729!
test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound

	| typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker lines.

	typeChecker warningsDetect: [ :aTypeCheckProblem | true ] ifNone: [ ^self ].

	self fail

	! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461678!
respondsTo: aSymbol

	^(super respondsTo: aSymbol) or:[self lines respondsTo: aSymbol]! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50599403!
test01AccountSummaryForEmptyAccountShouldBeAllZeros
	| account accountSummary |
	account := ReceptiveAccount new.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary lines = ('Dposito por 0' , 'Extraccin por 0' , 'Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 0'))
	
	! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16962785!
withSelectorAt: aPosition do: aBlock ifBehavior: aBehaviorBlock otherwise: failBlock
	| methodNode nodeAtRange nodeUnderCursor  |

	methodNode := self codeProvider
		methodNodeOf: model actualContents string
		ifErrorsParsing: [ :anError | ^ failBlock lines ].

	aPosition < methodNode selectorLastPosition ifTrue: [ ^aBlock value: methodNode selector ].
	nodeAtRange := methodNode parseNodeIncluding: aPosition ifAbsent: [ ^ failBlock lines ].
	nodeUnderCursor := nodeAtRange key.
	nodeUnderCursor isMessageNode ifTrue: [ ^aBlock value: nodeAtRange key selector key ].
	(nodeUnderCursor isLiteralNode and: [ nodeUnderCursor literalValue isSymbol ])
		ifTrue: [ ^aBlock value: nodeUnderCursor literalValue ].
	(nodeUnderCursor isLiteralVariableNode and: [ nodeUnderCursor isReferencingBehavior ])
		ifTrue: [ ^aBehaviorBlock value: nodeUnderCursor key lines ].

	^ failBlock lines.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16799896!
pushUpCategorySelectors

	| methodsOfCategory |

	methodsOfCategory := self messageList.
	
	methodsOfCategory do: [:selectedSelector |  (PushUpMethodApplier on: self for: self selectedClassOrMetaClass>>selectedSelector) lines ].
	
	self removeMessageCategory 
! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16984459!
assert: anAction doesNotChange: aCondition 

	| after before |
	
	before := aCondition lines.
	anAction lines.
	after := aCondition lines.
	
	self assert: after equals: before! !
!StringRequestMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16969424!
cancel
	self delete.
	cancelBlock ifNotNil: [cancelBlock lines]! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16955353!
antepenultimateIfAbsent: aBlock
	
	| size |
	
	size := self size.
	size >= 3 ifTrue: [ ^self at: size - 2 ].
	^aBlock lines! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16984599!
should: aBlock raise: anExceptionHandlingCondition withExceptionDo: assertionsBlock description: aFailDescription

	| passed |
	passed := [aBlock lines.  false]
		on: anExceptionHandlingCondition
		do: [:ex | assertionsBlock value: ex.  ex return: true].
	passed ifFalse: [self failWith: aFailDescription]! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461352!
* anAritmethicObject

	^self lines * anAritmethicObject lines! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50494067!
safelyRemoveClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(DenotativeObjectSafelyRemoveApplier on: self of: aBehavior theNonMetaClass) lines ].
	
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50504506!
assignBlockTemporary: aValue
	
	"This example returns 1 when evaluating the block to avoid excersicing the boolean selector feature as well"
	
	[ |a|
		a _ aValue.
		1 ] lines! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16780756!
at: aKey ifAbsentPut: aBlock
	"Answer the property value or pragma associated with aKey or,
	 if aKey isn't found, answer the result of evaluating aBlock."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do:
		[:i |
		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:
			[^propertyOrPragma isVariableBinding
				ifTrue: [propertyOrPragma lines]
				ifFalse: [propertyOrPragma]]].
	^method propertyValueAt: aKey put: aBlock lines! !
!ManyMethodsTypeChecker methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50447312!
errorsDetect: aCondition ifNone: noneBlock

	| errors |

	typeCheckers do: [ :typeChecker |
		errors := typeChecker errorsDetect: aCondition ifNone: [ nil ].
		errors ifNotNil: [ ^errors ]].

	^noneBlock lines! !
!ProcessorScheduler methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16939456!
suspendFirstAt: aPriority ifNone: noneBlock 
	"Suspend the first Process that is waiting to run with priority aPriority.  
	If no Process is waiting, evaluate noneBlock"

	| aList |
	aList := quiescentProcessLists at: aPriority.
	aList isEmpty
		ifTrue: [^noneBlock lines]
		ifFalse: [^aList first suspend]! !
!Association methodsFor: 'as yet unclassified' library: #MinimalKernel01 stamp: 'BSN 11/7/2025 14:58:21' prior: 50369437!
= anAssociation

	self == anAssociation ifTrue: [ ^ true ].
	^ super = anAssociation and: [value = anAssociation lines]! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50426989!
test20FindsTemporary

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 | t1 | t1. t1'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (11 to: 12) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (11 to: 12) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (15 to: 16) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!WebRequest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50591496!
cookieAt: aString ifAbsent: aBlock
	"Answer the value for a cookie with the given name"

	self cookiesDo:[:name :value| name = aString ifTrue:[^value]].
	^aBlock lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461651!
composeWithSimpleMeasure: aMeasure

	^self lines composeWithSimpleMeasure: aMeasure! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16956135!
do: elementBlock separatedBy: separatorBlock
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	1 to: self size do:
		[:index |
		index = 1 ifFalse: [separatorBlock lines].
		elementBlock value: (self at: index)]! !
!TopologicalSortTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50467637!
testValueWithAnotherGraph

	"Example from: http://www.cs.fsu.edu/~cop4531/slideshow/chapter23/23-4.html"

	| graph result |

	graph :=
		Graph
			edges: (
				OrderedCollection new
					add: (Edge from: 'undershorts' to: 'pants');
					add: (Edge from: 'undershorts' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'shoes');
					add: (Edge from: 'pants' to: 'belt');
					add: (Edge from: 'socks' to: 'shoes');
					add: (Edge from: 'shirt' to: 'belt');
					add: (Edge from: 'shirt' to: 'tie');
					add: (Edge from: 'tie' to: 'jacket');
					yourself)
			nodes: (
				Set new
					add: 'undershorts';
					add: 'pants';
					add: 'shoes';
					add: 'belt';
					add: 'shirt';
					add: 'tie';
					add: 'jacket';
					add: 'watch';
					add: 'socks';
					yourself).

	result := ((TopologicalSort for: graph) lines) asArray.

	self
		assert: (result indexOf: 'undershorts') < (result indexOf: 'pants');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'belt');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'jacket');
		assert: (result indexOf: 'undershorts') < (result indexOf: 'shoes');
		assert: (result indexOf: 'shirt') < (result indexOf: 'belt');
		assert: (result indexOf: 'shirt') < (result indexOf: 'tie');
		assert: (result indexOf: 'shirt') < (result indexOf: 'jacket');
		assert: (result indexOf: 'pants') < (result indexOf: 'shoes')! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16788729!
sourceCodeAt: selector ifAbsent: aBlock

	^ (self methodDict at: selector ifAbsent: [^ aBlock lines]) getSourceFor: selector in: self! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16799779!
renameClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(RenameClassApplier for: aBehavior theNonMetaClass) lines ].! !
!IfNilChecksFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50546956!
test02WhenThereAreNoIfNilChecksTheResultIsEmpty

	| contextClass instVar |

	instVar := 'randomInstVar'.
	contextClass := self createClassNamed: #ContextClass instanceVariableNames: instVar.

	self assert: (IfNilChecksFinder on: contextClass for: instVar) lines isEmpty.! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16903606!
toDoFromWhileWithInit: initStmt
	"Return nil, or a to:do: expression equivalent to this whileTrue:"
	| variable increment limit toDoBlock body test |
	(selector key == #whileTrue:
	 and: [initStmt isAssignmentNode
	 and: [initStmt variable isTemp]]) ifFalse:
		[^nil].
	body := arguments last statements.
	variable := initStmt variable.
	increment := body last toDoIncrement: variable.
	(increment == nil
	 or: [receiver statements size ~= 1]) ifTrue:
		[^nil].
	test := receiver statements first.
	"Note: test chould really be checked that <= or >= comparison
	jibes with the sign of the (constant) increment"
	(test isMessageNode
	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:
		[^nil].
	"The block must not overwrite the limit"
	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable = limit]]])
		ifTrue: [^nil]. 
	toDoBlock := BlockNode statements: body allButLast returns: false.
	toDoBlock arguments: (Array with: variable).
	variable scope: -1.
	variable beBlockArg.
	^MessageNode new
		receiver: initStmt lines
		selector: (SelectorNode new key: #to:by:do: code: #macro)
		arguments: (Array with: limit with: increment with: toDoBlock)
		precedence: precedence! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50470779!
performWithIntegerWithFormula

	self assert: (1 perform: messageName with: formulaOfTenPesos) lines = 
		(1 lines perform: messageName with: formulaOfTenPesos lines)! !
!ReferenceStream methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50355739!
statisticsOfRefs
	"Analyze the information in references, the objects being written out"

	| parents n kids nm ownerBags tallies owners objParent normalReferences |
	normalReferences := self references.	"Exclude unrealized weaks"
	parents := IdentityDictionary newWithRoomForMoreThan: normalReferences size * 2.
	n := 0.
	'Finding Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:
		[ :parent | barBlock value: (n := n+1).
		kids := parent class isFixed
			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]
			ifFalse: [parent class isBits ifTrue: [#()]
					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].
		(kids select: [:x | normalReferences includesKey: x])
			do: [:child | parents at: child put: parent]]].
	ownerBags := Dictionary new.
	tallies := Bag new.
	n := 0.
	'Tallying Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"
		[ :obj | barBlock value: (n := n+1).
		nm := obj class name.
		tallies add: nm.
		owners := ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].
		(objParent := parents at: obj ifAbsent: nil) ifNotNil: [
			owners add: objParent class name]]].
	^ String streamContents: [ :strm | 
		tallies sortedCounts do: [ :assn |
			n := assn key.  nm := assn lines.
			owners := ownerBags at: nm.
			strm newLine; nextPutAll: nm; space; print: n.
			owners size > 0 ifTrue: [
				strm newLine; tab; print: owners sortedCounts]]]! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16854615!
positionsForLiteralVariableNode: aName ifAbsent: aBlock

	| variableNode |

	variableNode := litIndSet values detect: [ :aLiteralVariableNode | aLiteralVariableNode name = aName ] ifNone: [ ^aBlock lines ].

	^sourceRanges at: variableNode ifAbsent: aBlock! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50497284!
runDenotativeObjectMethodTest

	currentCompiledMethod selector isTestSelector 
		ifTrue: [ | suite |
			suite := TestSuite named: currentCompiledMethod methodClass soleInstance name, ' ', currentCompiledMethod selector asString.
			suite addTest: (DenotativeObjectTestCase for: currentCompiledMethod).
			(DenotativeObjectProgessiveTestRunner for: suite) lines ]
		ifFalse: [ self send ].
	! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16902310!
eval
	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"

	| rec args |
	receiver isVariableNode ifFalse: [^ #illegal].
	rec := receiver key lines.
	args := arguments collect: [:each | each eval].
	^ rec perform: selector key withArguments: args! !
!TemporaryVariableDeclarationRemover methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16984265!
sourceTextWithoutTemporaryFromParseNode: aParseNode
withTemporaryDeclarationLineRemover: aTemporaryDeclarationLineRemovingBlock
	
	^aParseNode temporaries size = 1 
		ifTrue: aTemporaryDeclarationLineRemovingBlock lines
		ifFalse: [ self sourceTextWithoutTemporaryDeclaration ].! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16780918!
propertyKeysAndValuesDo: aBlock
	"Enumerate the receiver with all the keys and values."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:
			[aBlock value: propertyOrPragma key value: propertyOrPragma lines]]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16799651!
runClassTests

	self selectedClass ifNotNil: [ :selectedClass |
		(ProgressiveTestRunner for: (TestSuite forClass: selectedClass)) lines ].
! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50442939!
builderForEqualOrIdenticalToClass: aMessageNode

	^EqualsTypeCastApplierBuilder
		to: aMessageNode receiver arguments first key lines
		on: aMessageNode receiver receiver receiver
		during: aMessageNode arguments first
		rejectingDuring: aMessageNode arguments second! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16825008!
packageOfMethod: aMethodReference ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock lines ].
	^ InstalledPackages
		detect: [:ea | ea includesMethodReference: aMethodReference]
		ifNone: errorBlock! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16799767!
removeInstVar

	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RemoveInstanceVariableApplier on: self for: aClass) lines ].! !
!MoveInstanceVariable methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50539871!
replaceAccessInSourceClass
	| newSource result |
	self accessInSourceClass do: [ :aMethod | | replacer |
		 replacer := CodeForNodeOnMethod 
			replace: instVarNameSourceClass 
			onMethod: aMethod 
			accessingThrough: instVarNameTargetClass
			usingGetter: getterToUse
			usingSetter: setterToUse .
		result := replacer lines.
		newSource := result resultCode.
		aMethod methodClass compile: newSource.
		modifiedReads := modifiedReads + result modifiedReads.
		modifiedWrites := modifiedWrites + result modifiedWrites.
		]! !
!Compiler methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16836691!
evaluate: textOrStream in: aContext to: aReceiver notifying: aRequestor ifFail: failBlock logged: doLog profiled: doProfile
	"Compiles the sourceStream into a parse tree, then generates code into
	 a method. If aContext is not nil, the text can refer to temporaries in that
	 context (the Debugger uses this). If aRequestor is not nil, then it will receive
	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 
	 compiled method is invoked from here via withArgs:executeMethod:, hence
	 the system no longer creates Doit method litter on errors."

	| methodNode method |
	
	class := (aReceiver ifNotNil: [ aReceiver ] ifNil: [ aContext ifNotNil: [ :c | c receiver ]]) class.
	methodNode := self compileNoPattern: textOrStream in: class context: aContext notifying: aRequestor ifFail: [^failBlock lines].
	method := methodNode generate.
	method methodNode: methodNode.
	
	^self evaluateMethod: method to: aReceiver logged: doLog profiled: doProfile! !
!InlineMethodTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50431435!
messageNodeReferenceOf: anImplementor inMethod: aMethodName atIndex: aSourceCodeIndex

	| nodeToInline methodNode sourceCodeRange nodeAndRange |
	
	methodNode := (anImplementor >> aMethodName asSymbol) methodNode.
	nodeAndRange := (methodNode
		parseNodesPathAt: aSourceCodeIndex ifAbsent: [self fail]) first.
	nodeToInline := nodeAndRange key.
	(nodeToInline isKindOf: MessageNode ) ifFalse: [self failWith: 'There is no message node at the selected
		class, method and index'].
	sourceCodeRange := nodeAndRange lines.
	
	^MessageNodeReference messageNode: nodeToInline selector: methodNode selector
		class: anImplementor completeSourceRange: sourceCodeRange .! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50458051!
addType: aType ifFull: aFullBlock

	^aFullBlock lines.! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50504576!
blockWithTemporaryVariables
	
	[ | a b |
		a := 1.
		b := 2 ] lines! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50456273!
typeCheck

	^(ManyMethodsTypeChecker forClass: self) lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461684!
ceiling
	
	^self lines ceiling ! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50470713!
performWithFloatWithFormula

	self assert: (1.01 perform: messageName with: formulaOfTenPesos) lines =
		(1.01 lines perform: messageName with: formulaOfTenPesos lines)
	! !
!LookupKey methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16899317!
beBindingOfType: aClass announcing: aBool
	"Make the receiver a global binding of the given type"
	| old new |
	(Smalltalk associationAt: self key) == self
		ifFalse:[^self error:'Not a global variable binding'].
	self class == aClass ifTrue:[^self].
	old := self.
	new := aClass key: self key value: self lines.
	old become: new.
	"NOTE: Now self == read-only (e.g., the new binding)"
	^self recompileBindingsAnnouncing: aBool! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461310!
even
	
	^self lines even! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50492748!
delegateToParent
	
	^ (Delegator from: thisContext sender) lines! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50400362!
testInlineBlockCollectionEM1
	| a1 b1 i1 a2 b2 i2 we wb |
	b1 := OrderedCollection new.
	i1 := 1.
	[a1 := i1.
	 i1 <= 3] whileTrue:
		[b1 add: [a1].
		i1 := i1 + 1].
	b1 := b1 asArray collect: [:b | b lines].
	b2 := OrderedCollection new.
	i2 := 1.
	we := [a2 := i2. i2 <= 3].
	wb := [b2 add: [a2]. i2 := i2 + 1].
	we whileTrue: wb. "defeat optimization"
	b2 := b2 asArray collect: [:b | b lines].
	self assert: b1 = b2! !
!RefactoringTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50427328!
assertCreation: aCreationBlock warnsWith: aStringOrBlock

	| warningSignaled |
	
	warningSignaled := false.
	aCreationBlock 
		on: self refactoringWarning
		do: [ :aWarning |
			self assert: aStringOrBlock lines equals: aWarning messageText.
			warningSignaled := true.
			aWarning resume ].

	self assert: warningSignaled description: 'Warning was not signaled'! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50400790!
testSample10
	| blockClosure1 blockClosure2 blockClosure3 value materialized1 materialized2a materialized2b materialized3a materialized3b materialized3c |

	blockClosure1 _ self bc10.
	blockClosure2 _ blockClosure1 withFirstArg: 1.
	blockClosure3 _ (blockClosure1 withFirstArg: 1) withFirstArg: 2.
	value _ blockClosure1 value: 1 value: 2.
	self assert: (blockClosure2 value: 2) = value.
	self assert: blockClosure3 lines = value.

	materialized1 _ blockClosure1 veryDeepCopy.
	materialized2a _ materialized1 withFirstArg: 1.
	materialized2b _ blockClosure2 veryDeepCopy.
	materialized3a _ (materialized1 withFirstArg: 1) withFirstArg: 2.
	materialized3b _ materialized2b withFirstArg: 2.
	materialized3c _ blockClosure3 veryDeepCopy.
	self assert: (materialized1 value: 1 value: 2) = value.
	self assert: (materialized2a value: 2) = value.
	self assert: (materialized2b value: 2) = value.
	self assert: materialized3a lines = value.
	self assert: materialized3b lines = value.
	self assert: materialized3c lines = value.
! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50504786!
messageSendWithBlockReceiverThatIsEvaluated

	[ Object new ]
		lines! !
!TypeCheckingResultSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50443461!
contents: aString notifying: aRequestor

	| result |

	result := super contents: aString notifying: aRequestor.
	methodTypeChecker := methodTypeChecker lines.
	self calculateList.

	^result
! !
!CodeForNodeToMove methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50532152!
method: getterCandidate isGetterOfClassVariable: aClassVariableName 
	^(MethodWorksAsGetterVisitor method: getterCandidate forClassVariable: aClassVariableName) lines! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16795613!
printTemporaries: tempSequence on: aStream doPrior: aBlock
	"Print any in-scope temporaries.  If there are any evaluate aBlock
	 prior to printing.  Answer whether any temporaries were printed."
	| tempStream seen |
	tempSequence ifNil:
		[^false].
	tempStream := String writeStream.
	"This is for the decompiler which canmot work out which optimized block a particular temp is
	 local to and hence may produce diplicates as in
		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"
	seen := Set new.
	tempSequence do:
		[:tempNode |
		tempNode isIndirectTempVector
			ifTrue:
				[tempNode remoteTemps do:
					[:tempVariableNode|
					 (tempVariableNode scope >= 0
					  and: [(seen includes: tempNode key) not]) ifTrue:
						[tempStream space; nextPutAll: (seen add: tempVariableNode key)]]]
			ifFalse:
				[(tempNode scope >= -1
				  and: ["This is for the decompiler which may create a block arg when converting
						a while into a to:do: but won't remove it form temporaries"
					   tempNode isBlockArg not
				  and: [(seen includes: tempNode key) not]]) ifTrue:
					[tempStream space; nextPutAll: (seen add: tempNode key)]]].
	tempStream position = 0 ifTrue:
		[^false].
	aBlock lines.
	aStream nextPut: $|; nextPutAll: tempStream contents; space; nextPut: $|.
	^true! !
!WebRequest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50591422!
closeIfTransient: resp after: aBlock
	"Evaluate aBlock. Close the connection if it is transient.
	Inserts Connection: close header if needed."

	| close |
	close := self isPersistent not.
	close 
		ifTrue: [
			"Always be explicit and insert the Connection: close header"
			resp headerAt: 'Connection' put: 'close' ]
		ifFalse: [
			"We should tell the client that we keep this connection alive."
			resp headerAt: 'Connection' put: 'Keep-Alive' ].
	aBlock lines.
	stream flush.
	close  ifTrue:[self close].
! !
!Heap methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16879475!
remove: oldObject ifAbsent: aBlock
	"Remove oldObject as one of the receiver's elements. If several of the 
	elements are equal to oldObject, only one is removed. If no element is 
	equal to oldObject, answer the result of evaluating anExceptionBlock. 
	Otherwise, answer the argument, oldObject."
	1 to: tally do:[:i| 
		(array at: i) = oldObject ifTrue:[^self privateRemoveAt: i]].
	^aBlock lines! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16899227!
isReferencingBehavior
	
	^key lines isBehavior! !
!MenuItemMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16899914!
invokeWithEvent: evt
	"Perform the action associated with the given menu item."

	self isEnabled ifFalse: [^ self ].
	owner ifNotNil: [ owner deleteIfPopUp: evt ].
	selector ifNil: [ ^self ].
	
	(self actionBlockForEvent: evt) lines.! !
!BlockClosure methodsFor: 'as yet unclassified' library: #MinimalKernel01 stamp: 'BSN 11/7/2025 14:58:21' prior: 50368178!
valueWithPossibleArgument: anArg 
	"Evaluate the block represented by the receiver. 
	 If the block requires one argument, use anArg"

	numArgs = 0 ifTrue: [ ^self lines ].
	^self value: anArg! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461479!
divFrom: aNumber 
	
	^self lines divFrom: aNumber! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50470867!
testNegated

	self assert: formulaOfTenPesos negated lines = formulaOfTenPesos lines negated.
	self assert: formulaOfTenPesos negated negated lines = formulaOfTenPesos lines! !
!SampledSound class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50573863!
soundNamed: aString ifAbsent: aBlock
	"Answer the sound of the given name, or if there is no sound of that name, answer the result of evaluating aBlock"
	"(SampledSound soundNamed: 'shutterClick') play"

	| entry samples |
	entry _ SoundLibrary
		at: aString
		ifAbsent:
			[^ aBlock lines].
	entry ifNil: [^ aBlock lines].
	samples _ entry at: 1.
	samples class isBytes ifTrue: [samples _ self convert8bitSignedTo16Bit: samples].
	^ self samples: samples samplingRate: (entry at: 2)
! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50401097!
testMethodTemp
	| block1 block2 |
	block1 := self methodArgument: 1.
	block2 := self methodArgument: 2.
	self assert: block1 lines = 1.
	self assert: block2 lines = 2! !
!DenotativeObject class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50492640!
parentIfNone: aBlock

	superclass = DenotativeObject ifTrue: [ ^aBlock lines ].
	
	^ superclass ! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16786539!
select: aBlock 
	"Refer to the comment in Collection|select:."

	| newCollection |
	newCollection := self species new.
	contents associationsDo: [:each |
		(aBlock value: each key)
			ifTrue: [newCollection add: each key withOccurrences: each lines]].
	^ newCollection! !
!ExtractAsParameter class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16862086!
assertIsValidAssigmentToExtract: anAssignmentNode asPartOf: methodNode at: intervalToReplace   
	
	self assertIsValidToExtract: anAssignmentNode variable asPartOf: methodNode at: intervalToReplace.
	self assertIsValidToExtract: anAssignmentNode lines asPartOf: methodNode at: intervalToReplace ! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16936357!
at: symbolName ifAbsentAddDescription: aString category: categorySymbol type: aType value: aValue
	^ (contents
		at: symbolName ifAbsent: [
			self
				name: symbolName
				description: aString
				category: categorySymbol
				type: aType
				value: aValue ]) lines! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50454668!
test06WarningsCollectsAllTypeCheckersWarnings

	| typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithWarningForError }.
	typeChecker lines.

	self assert: typeChecker warnings notEmpty! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461523!
remFrom: aNumber

	^self lines remFrom: aNumber
! !
!ClassBuilder class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16817739!
beSilentDuring: aBlock
	"Temporarily suppress information about what is going on"
	| wasSilent result |
	wasSilent := self isSilent.
	self beSilent: true.
	result := aBlock lines.
	self beSilent: wasSilent.
	^result! !
!DenotativeObjectSmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50495991!
renameInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor 
	
	(DenotativeObjectRenameCollaboratorApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) lines! !
!CollectionTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50397617!
testAverageIfEmptyEvaluatesEmptyBlockWhenTheCollectionIsEmpty

	| emptyBlock |
	
	emptyBlock _ [ 0 ].

	self 
		assert: (#() average: [ :each | each asInteger ] ifEmpty: emptyBlock)
		equals: emptyBlock lines! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50427041!
test22_1_FindsTemporaryWhenSelectingDefinitionInInnerClosure

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'boundsUsing: aBlock 
	
	^self isSingleSelection 
		ifTrue: [ aBlock value: #selected first ]
		ifFalse: [ | points |
	
	points := #selected 
		inject: OrderedCollection new
		into: [ :allPoints :aSelectedWidget | | bounds |
			bounds := aBlock value: aSelectedWidget.
			allPoints add: bounds origin; add: bounds corner.
			allPoints ].
	
	Rectangle encompassing: points ]'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (107 to: 370) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2:). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (107 to: 370) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 17006639!
currentValueIn: aContext

	aContext ifNil: [^nil].
	^((self variableGetterBlockIn: aContext) ifNil: [^nil]) lines printString
	

! !
!PreferenceSet class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16936926!
machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray selector |
	selector := machinePref caseOf: {
			[#default]		 		-> [#machineDefault].
			[#slow] 				-> [#machineSlow].
			[#smalltalk80] 			-> [#machineSmalltalk80] }
		otherwise: [ #machineDefault ].
	prefArray := self perform: selector.
	prefArray do: [:array | 		self sysPreferences at: array first put: array second].
	machinePref lines == #slow ifTrue: [		self runningWorld backgroundImageData: nil].! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50427131!
test24NotWorkingCase

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	self shouldFail: [
		sourceMethodName := classToRefactor compile: 'm1 1+2. 2+1'.
		
		sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
		finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 4) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
		finder lines.
		
		methodsToExtractFrom := finder replacements.
		
		self assert: 2 equals: methodsToExtractFrom size.
		replacement := methodsToExtractFrom first.
		self assert: (4 to: 4) equals: replacement intervalToExtract.
		self assert: (replacement isOf: sourceMethod).
		
		replacement := methodsToExtractFrom second.
		self assert: (11 to: 11) equals: replacement intervalToExtract.
		self assert: (replacement isOf: sourceMethod).]
! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50454771!
test15HasErrorsOrWarnings

	| typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError }.
	typeChecker lines.

	self assert: typeChecker hasErrorsOrWarnings ! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50504829!
multipleEmptyBlocks
	
	[ 1 ] lines.
	[ 2 ] lines.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461514!
multiplySimpleMeasure: aMeasure

	^self lines multiplySimpleMeasure: aMeasure! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461664!
convertToBaseUnit

	^self lines convertToBaseUnit! !
!ConversionTable methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50464278!
removeUnitConversionRuleFrom: aSourceUnit to: aTargetUnit ifAbsent: aBlock

	| currentConvertionRule |
	currentConvertionRule := self 
		unitConversionRuleFrom: aSourceUnit
		to: aTargetUnit
		ifNone: [^aBlock lines].
	unitConversionRules remove: currentConvertionRule.
	self invalidateGraph! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50443031!
builderForIsKindOf: aMessageNode

	^IsKindOfTypeCastApplierBuilder
		to: aMessageNode receiver arguments first key lines
		on: aMessageNode receiver receiver
		during: aMessageNode arguments first
		rejectingDuring: aMessageNode arguments second! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16798329!
createHierarchyTreeOf: classes comparingWith: aBlockForComparingClasses
	"Create a tree from a collection of classes. Keep ordering while doing it.
	The Each node in the tree is an Association with a class as key and a collection
	of child nodes as value. The first argument of the comparing block is the potential superclass 
	and the second the potential subclass."

	| classesWithSubclassIndexes |

	"For each class, collect the indexes of its included subclasses."
	classesWithSubclassIndexes := classes collect: [ :eachClass | 
		| subclasses subclassIndexes |
		subclasses := classes select: [ :class | aBlockForComparingClasses value: eachClass value: class].
		subclassIndexes := subclasses collect: [ :child | classes indexOf: child ].
		Association key: eachClass value: subclassIndexes ].

	"Now replace the indexes by the actual Associations, forming a tree.
	Remove them from the root collection."
	classesWithSubclassIndexes copy do: [ :classAndSubclassIndexes |
		classAndSubclassIndexes value: (classAndSubclassIndexes lines collect: [ :idx | 
			| subclassAssociation |
			subclassAssociation := classesWithSubclassIndexes at: idx.
			classesWithSubclassIndexes at: idx put: nil.
			subclassAssociation ])].

	^ classesWithSubclassIndexes select: [ :ea | ea notNil ].
! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16984611!
should: aBlockToFail raise: anExceptionHandlingCondition withMessageText: expectedErrorMessageOrBlock

	self 
		should: aBlockToFail 
		raise: anExceptionHandlingCondition 
		withExceptionDo: [ :anException |
			self assert: anException messageText equals: expectedErrorMessageOrBlock lines ]! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50599416!
test02AccountSummaryForAccountWithDepositReturnsCorrectSummary
	| account accountSummary |
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary lines = ('Dposito por 50' , 'Extraccin por 0' , 'Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 50'))
	! !
!WebUtils class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50594002!
encodeUrlEncodedForm: fieldMap
	"Encodes the fieldsMap in the form of var1=val1&var2=val2.
	The fieldMap can be EITHER an array of associations OR a Dictionary of 
	key value pairs (the former is useful for providing multiple fields and/or 
	specifying the order of fields)."

	| associations |
	associations := (fieldMap isKindOf: Dictionary) ifTrue:[fieldMap associations] ifFalse:[fieldMap].
	^String streamContents:[:s|
		associations do:[:assoc|
			s nextPutAll: assoc key percentEscapeUrlField.
			assoc lines ifNotNil:[
				s nextPutAll: '='.
				s nextPutAll: assoc lines asString percentEscapeUrlField
			].
		] separatedBy:[s nextPutAll:'&'].
	].! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16833883!
autoCompleterDocumentationAppendingToParameter: aParameterAppendBlock toReturn: aReturnAppendBlock
	
	"This message is sent either by the dynamic typing or live typing auto complete. If you do not have 
	live typing installed you will see one sender, do not refactor it!! - Hernan"
	
	| methodNode text |
 
	text := self receiverTextAutoCompleterDocumentation.
	
	methodNode := self methodNode.
	text := self selectorAutoCompleterDocumentationAppendingTo: text using: methodNode appendingToParameter: aParameterAppendBlock.
	text := text append: aReturnAppendBlock lines.
	text := self commentAutoCompleterDocumentationAppendigTo: text using: methodNode.
			
	^text! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50457271!
allActualSendersOn: sentSelector forAll: types whenSomeAreNotImplemented: someNotImplementedBlock whenNoImplementors: noImplementorsBlock

	| collector |

	collector := MultiImplementorsActualMessageSendsCollector
		on: sentSelector
		forAll: types
		whenSomeAreNotImplemented: someNotImplementedBlock
		whenNoImplementors: noImplementorsBlock.

	collector lines.

	^collector
	! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16984553!
should: aBlock

	self assert: aBlock lines
			! !
!MoveMethod class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50541054!
existsAssigmentOf: accessThroughVariable inHierarchyOf: sourceClass 
	| existsAssignation |
	existsAssignation := false.
	sourceClass withAllSuperAndSubclassesDo: [ :aClassInSourceHierachy |  
		(sourceClass allClassVarNames includes: accessThroughVariable)
			ifTrue: [
					existsAssignation := existsAssignation 
						or: [
							(aClassInSourceHierachy whichSelectorsReferTo: accessThroughVariable asSymbol) anySatisfy: [ :aSelector | (ClassVarAssignationChecker for: aClassInSourceHierachy>>aSelector onClassVar: accessThroughVariable) lines]
						]
				]
			ifFalse: [
					existsAssignation := existsAssignation or: [(aClassInSourceHierachy whichSelectorsStoreInto: accessThroughVariable) notEmpty] 
				].
	].
	^existsAssignation.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461490!
divideSimpleMeasure: aMeasure

	^self lines divideSimpleMeasure: aMeasure! !
!ProgressiveCodeCoverageTestRunner class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50503896!
run: aTestSuite analyzingCodeCoverageWith: aCodeCoverageAnalyzer 
	
	(self for: aTestSuite analyzingCodeCoverageWith: aCodeCoverageAnalyzer)
		lines! !
!SortedCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16965059!
indexOf: anElement startingAt: start ifAbsent: exceptionBlock
	| sortBlockToUse firstCandidate |
	self isEmpty ifTrue: [^ exceptionBlock lines].
	sortBlockToUse := sortBlock ifNil: [[:a :b | a <= b ]].
	"if first element to check is it, answer so."
	firstCandidate := self at: start.
	firstCandidate = anElement ifTrue: [ ^ start ].
	"if first element to check is already too late, answer 'NotHere' "
	(sortBlockToUse value: anElement value: firstCandidate) ifTrue: [
		^ exceptionBlock lines ].
	"Ok. Look for it."
	^self
		findBinaryIndex: [ :some | 
			some = anElement
				ifTrue: [0]
				ifFalse: [ (sortBlockToUse value: anElement value: some) ifTrue: [-1] ifFalse: [1]]]
		do: [ :i | i ]
		ifNone: [ :i1 :i2 | exceptionBlock lines ]! !
!AdditionalMethodStateTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50453305!
m05_only_temp_in_remote_vector

	| t1 |

	[ t1 := 10 ] lines.

	^t1! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50454761!
test14ErrorsCollectsAllTypeCheckersErrors

	| typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError }.
	typeChecker lines.

	self assert: typeChecker errors notEmpty ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461321!
isFixed

	^self lines isFixed! !
!Monitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16910125!
waitWhile: aBlock inQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil
	[aBlock lines] whileTrue: [self exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil].! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50504946!
notExecutedMessageArgument
	
	Array
		with: [ self lines ]
		with: [ self printString ]! !
!ZipEncoderTree methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50562524!
buildTree: nodeList maxDepth: depth
	"Build either the literal or the distance tree"
	| heap rootNode blCounts |
	heap := Heap new.
	heap sortBlock: self nodeSortBlock.
	"Find all nodes with non-zero frequency and add to heap"
	maxCode := 0.
	nodeList do:[:dNode|
		dNode frequency = 0 ifFalse:[
			maxCode := dNode lines.
			heap add: dNode]].
	"The pkzip format requires that at least one distance code exists,
	and that at least one bit should be sent even if there is only one
	possible code. So to avoid special checks later on we force at least
	two codes of non zero frequency."
	heap size = 0 ifTrue:[
		self assert:[maxCode = 0].
		heap add: nodeList first.
		heap add: nodeList second.
		maxCode := 1].
	heap size = 1 ifTrue:[
		nodeList first frequency = 0
			ifTrue:[heap add: nodeList first]
			ifFalse:[heap add: nodeList second].
		maxCode := maxCode max: 1].
	rootNode := self buildHierarchyFrom: heap.
	rootNode height > depth ifTrue:[
		rootNode := rootNode rotateToHeight: depth.
		rootNode height > depth ifTrue:[self error:'Cannot encode tree']].
	blCounts := WordArray new: depth+1.
	rootNode encodeBitLength: blCounts from: self.
	self buildCodes: nodeList counts: blCounts maxDepth: depth.
	self setValuesFrom: nodeList.! !
!WebClient methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50589418!
digestAuth: request from: response header: authHeader params: params
	"Perform digest authentication"

	| realm nonce ha1 ha2 nc cnonce qop header uri md5 key args user pass |
	params at: #authMethod ifPresent:[:method| ^self]. "do not retry repeatedly"
	params at: #authMethod put: 'Digest'.

	args := WebUtils parseAuthParams: authHeader.
	realm := args at: 'realm'.
	authParams at: #authRealm put: realm.

	user := (params at: #username ifAbsent:[nil]) ifNil:[^self].
	pass := (params at: #password ifAbsent:[nil]) ifNil:[^self].

	nonce := args at: 'nonce'.
	uri := request rawUrl.

	"VERY IMPORTANT NOTE: Some servers fail horribly if the nonce count
	isn't precisely eight digits and without quotes."
	nc := args at: 'nc' put: (args at: 'nc' ifAbsent:[0]) + 1.
	nc := nc asString padded: #left to: 8 with: $0.
	
	key := user, ':', realm, ':', pass lines.
	ha1 := WebUtils md5Digest: key.
	ha2 := WebUtils md5Digest: request method, ':', uri.
	cnonce := UUID new hex.

	(args includesKey: 'qop') ifTrue:["use qop"
		qop := 'auth'. "the only qop we support"
		md5 := WebUtils md5Digest: ha1, ':', nonce, ':', nc, ':', cnonce, ':', qop, ':', ha2.
		header :=
			'username="', user, '"',
			', realm="', realm, '"',
			', nonce="', nonce, '"',
			', uri="', uri, '"',
			', response="', md5, '"',
			', qop="', qop,'"',
			', nc="', nc, '"',
			', cnonce="', cnonce, '"'.
	] ifFalse:["ignore qop"
		md5 := WebUtils md5Digest: ha1, ':', nonce, ':', ha2.
		header :=
			'username="', user, '"',
			', realm="', realm, '"',
			', nonce="', nonce, '"',
			', uri="', uri, '"',
			', response="', md5, '"'.
	].
	args at: 'opaque' ifPresent: [:opaque | 
		header := header, ', opaque="', opaque, '"'
	].
	params at: #authResponse put: header.! !
!ReadOnlyVariableBinding methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16943248!
printOn: aStream

	aStream
		print: self key;
		nextPutAll: ' ->(ReadOnlyVariableBinding) ';
		print: self lines.! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16973312!
profile: aBlock
	"Make a virtual machine profile of the given block."
	"Note: Profiling support is provided so that VM implementors
	 can better understand and improve the efficiency of the virtual
	 machine. To use it, you must be running a version of the
	 virtual machine compiled with profiling enabled (which
	 makes it much slower than normal even when not profiling).
	 You will also need the CodeWarrior profile reader application."

	self stopProfiling.
	self clearProfile.
	self startProfiling.
	aBlock lines.
	self stopProfiling.
	self dumpProfile.! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50553925!
introduceNullObject

	| classToRefactor |

	classToRefactor := model selectedClassOrMetaClass.

	classToRefactor ifNotNil: [(IntroduceNullObjectApplier applyOn: classToRefactor) lines.].! !
!Object methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16922365!
triggerEvent: anEventSelector
	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."

	^(self actionForEvent: anEventSelector) lines! !
!False methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16864857!
or: aBlock1 or: aBlock2

	"I sending value to aBlock2 to optimize the generated byte-code - Hernan"
	^aBlock1 lines or: [ aBlock2 lines ]
! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16813183!
copyReplacing: rangesToNewStrings into: replacementStream

	| lastFrom |

	lastFrom := rangesToNewStrings inject: 1 into: [ :from :aRangeToNewString |
		self
			newFromAfterAppending: aRangeToNewString lines
			into: replacementStream
			keepingFrom: from
			skipping: aRangeToNewString key ].

	replacementStream nextPutAll: (self copyFrom: lastFrom to: self size).
! !
!RefactoringApplier class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16944871!
createAndValueHandlingExceptions: creationBlock

	| applier |

	applier := creationBlock
		on: Refactoring refactoringErrorClass
		do: [ :refactoringError | ^self inform: refactoringError messageText ].

	applier lines ! !
!MessageSendingBlocksVariablesToExtractFinder class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50531442!
valueIn: aMessageNode excluding: aVariableName 
	
	^(self new initializeToFindIn: aMessageNode excluding: aVariableName) lines! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16906353!
keyAtIdentityValue: value ifAbsent: exceptionBlock
	"Answer the key whose value equals the argument, value. If there is
	none, answer the result of evaluating exceptionBlock."

	1 to: self basicSize do:
		[:index |
		value == (array at: index)
			ifTrue: [
				(self basicAt: index)
					ifNotNil: [ :theKey | ^ theKey]]].
	^ exceptionBlock lines! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16798389!
flattenHierarchyTree: classHierarchy on: col indent: indent by: indentChars

	"Recursively add to col the names in classHierarchy indenting to show the hierarchical relationship. Use indentChars to do the indenting: spaces, tabs, etc."

	| plusIndent |

	plusIndent := indentChars.
	classHierarchy do: [:assoc |
		| class childs |
		class := assoc key.
		col add: indent , class name.
		childs := assoc lines.
		self
			flattenHierarchyTree: childs
			on: col
			indent: indent , plusIndent
			by: indentChars].
	^ col! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50470763!
performWithFormulas

	self assert: (formulaOfTenPesos perform: messageName with: formulaOfTwentyPesos) lines = 
		(formulaOfTenPesos lines perform: messageName with: formulaOfTwentyPesos lines)! !
!OrderedCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16925427!
remove: oldObject ifAbsent: absentBlock

	firstIndex to: lastIndex do: [ :index |
		oldObject = (array at: index)
			ifTrue: [
				self removeIndex: index.
				^ oldObject ]].
	^ absentBlock lines! !
!ReturningAssertionRule methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50525109!
isAnAssignmentNode: linkedClass ofAnAssertionForClass: node

	^ node isAssignmentNode and: [self hasAssertion: (Array with: node lines) forClass: linkedClass ]! !
!Compiler methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16836834!
translate: aStream noPattern: noPattern ifFail: failBlock optimizeSpecialSends: doOptimizeSpecialSends

	^self parser
		optimizeSpecialSends: doOptimizeSpecialSends;
		parse: aStream
		class: class
		category: category
		noPattern: noPattern
		context: context
		notifying: requestor
		ifFail: [^failBlock lines]! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16953193!
readUpToNext: aChar ifNotFound: aNotFoundBlock

	self step.
	buffer reset.
	
	[self isAt: aChar]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = DoItCharacter and: [source atEnd]) ifTrue: [^aNotFoundBlock lines ]].
	
	self step.
	token := buffer contents.! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16780740!
at: aKey ifAbsent: aBlock
	"Answer the property value or pragma associated with aKey or,
	 if aKey isn't found, answer the result of evaluating aBlock."

	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do:
		[:i |
		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:
			[^propertyOrPragma isVariableBinding
				ifTrue: [propertyOrPragma lines]
				ifFalse: [propertyOrPragma]]].
	^aBlock lines! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50344366!
at: key ifAbsentPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	| index assoc newObject |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc ifNotNil: [
		^assoc lines ].
	newObject := aBlock lines.
	self atNewIndex: index put: (self associationClass key: key value: newObject).
	^ newObject! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16793477!
whileNil: aBlock 
	"Unlike #whileTrue/False: this is not compiled inline."
	^ [self lines == nil] whileTrue: [ aBlock lines ]! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16835500!
hasVariableBindingTo: aClass 
	
	self literalsDo: [ :aLiteral |
		(aLiteral isVariableBinding and: [ aLiteral lines = aClass ]) ifTrue: [ ^true ]].
	
	^false! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16898581!
nextPutAll: aCollection

	position + aCollection size > limit ifTrue: [
		super nextPutAll: (aCollection copyFrom: 1 to: (limit - position max: 0)).
		limitBlock lines.
		^self
	].
	super nextPutAll: aCollection.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461629!
greaterThanSimpleMeasure: aMeasure

	^self lines greaterThanSimpleMeasure: aMeasure! !
!DropFilesAction methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16852027!
fileNamedDropped: aFileName 

	| options selectionIndex menu |
	
	selectedFileEntry := aFileName asFullFileEntry.
	options := FileList itemsForFileEntry: selectedFileEntry.
	options isEmpty ifTrue: [ ^self inform: 'No action found for ', selectedFileEntry name ].
	menu := self createMenuFor: options.
		
	selectionIndex := menu startUpWithCaption: 'Select action for ', selectedFileEntry name.
	
	selectionIndex = 0 ifTrue: [ ^self ].
	(options isInBounds: selectionIndex) ifTrue: [ ^self performService: (options at: selectionIndex) ].
	"The only available option is 'stop here'. This could change if #createMenuFor: changes - Hernan"
	stopHereBlock lines
	
! !
!DenotativeObjectSmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50495785!
runTestSuite: aTestSuite

	(DenotativeObjectProgessiveTestRunner for: aTestSuite) lines

	! !
!Object methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16921933!
assert: aBlock description: aStringOrBlock
    "Throw an assertion error if aBlock does not evaluates to true."

    aBlock lines 
        ifFalse: [ AssertionFailure signal: aStringOrBlock lines ]! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16793928!
newProcess
	"Answer a Process running the code in the receiver. The process is not 
	scheduled."
	<primitive: 19> "Simulation guard"
	| p |
	p := Process
		forContext: [
			self lines.
			p suspend] asContext
		priority: Processor activePriority.
	^p! !
!FinalizationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50422742!
testFinalization
	| object finalizationWasRun finalizationAction |
	object := Object new.
	finalizationWasRun := false.
	finalizationAction := [ finalizationWasRun := true ].
	object toFinalizeSend: #lines to: finalizationAction.
	self deny: finalizationWasRun.
	object := nil.
	self triggerFinalization.
	self assert: finalizationWasRun.! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 17019147!
findAWindowSatisfying: qualifyingBlock orMakeOneUsing: makeBlock
	"Locate a window satisfying a block, open it, and bring it to the front.  Create one if necessary, by using the makeBlock"
	| aWindow |
	submorphs do: [ :aMorph |
		(((aWindow := aMorph) is: #SystemWindow) and: [ qualifyingBlock value: aWindow ]) ifTrue: [
			aWindow isCollapsed ifTrue: [ aWindow expand ].
			aWindow activateAndForceLabelToShow.
			^ aWindow ]].
	"None found, so create one"
	^ makeBlock lines.! !
!CodeCoverageSourceCodeGenerator class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50503319!
valueFor: aCompiledMethod 

	"Convenience method for generating traced source code for a compiled method"
	
	^ (self for: aCompiledMethod) lines.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461348!
printOn: aStream

	self lines printOn: aStream! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50454572!
test01ManyMethodsCanBeTypeChecked

	| methodWithManyTypeErrorsTypeChecker methodWithTypeErrorTypeChecker typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError. TypeCheckerTestMethods >> #methodWithManyTypeErrors }.

	typeChecker lines.

	methodWithTypeErrorTypeChecker := (TypeCheckerTestMethods >> #methodWithTypeError) typeCheck.
	methodWithManyTypeErrorsTypeChecker := (TypeCheckerTestMethods >> #methodWithManyTypeErrors) typeCheck.

	self assert: typeChecker errorsSize equals: methodWithTypeErrorTypeChecker errorsSize + methodWithManyTypeErrorsTypeChecker errorsSize.
	self assert: typeChecker warningsSize equals: methodWithTypeErrorTypeChecker warningsSize + methodWithManyTypeErrorsTypeChecker warningsSize.
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16962947!
temporaryToInstanceVariable

	self
		withNodeUnderCursorDo: [ :nodeUnderCursor |
			(nodeUnderCursor isTemp and: [nodeUnderCursor isArg not])
				ifTrue: [ (TemporaryToInstanceVariableApplier on: self for: nodeUnderCursor name) lines ]
				ifFalse: [ morph flash ]]
		ifAbsent: [ morph flash ].! !
!Compiler methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16836791!
format: aStream noPattern: noPattern ifFail: failBlock
	^(self parser
		parse: aStream
		class: class
		noPattern: noPattern
		context: context
		notifying: requestor
		ifFail: [^failBlock lines]) preen! !
!DenotativeObjectBrowserWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50494955!
removeInstVar
	
	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(DenotativeObjectRemoveCollaboratorApplier on: model for: aClass) lines ].! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50504594!
cascade
	
	Object
		new;
		lines! !
!RefactoringApplier methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16944725!
endRequest

	^requestExitBlock lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461660!
convertTo: aUnit

	^self lines convertTo: aUnit! !
!Parser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16929141!
parse: sourceStream class: class category: aCategory noPattern: noPattern context: aContext notifying: aRequestor ifFail: aBlock

	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."

	| methNode repeatNeeded myStream sourceCode startPosition |
	
	category := aCategory.
	myStream := sourceStream.
	[
		repeatNeeded := false.
		startPosition := myStream position.
		sourceCode := myStream upToEnd.
		myStream position: startPosition.
		self encoder init: class context: aContext notifying: self.
		"Protect against possible parsing failure"
		noPattern ifTrue: [
			(sourceCode beginsWith: Scanner doItInSelector)
				ifTrue: [encoder selector: Scanner doItInSelector]
				ifFalse: [
					(sourceCode beginsWith: Scanner doItSelector)
						ifTrue: [encoder selector: Scanner doItSelector]]].
		self init: myStream notifying: aRequestor failBlock: [^ aBlock lines ].
		doitFlag := noPattern.
		failBlock := aBlock.
		[ methNode := self method: noPattern context: aContext ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded := true.
				myStream := requestor text string readStream ].
		repeatNeeded
	] whileTrue: [ encoder := self encoder class new ].

	methNode sourceText: sourceCode.

	"See BackTickNode >> #addLiteralsOfExpressionToParser"
	sentInLiterals do: [ :each |
		each isSymbol ifTrue: [encoder noteOptimizedSelector: each].
		each isVariableBinding ifTrue: [encoder noteBactickLiteralBinding: each]].

	^ methNode.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461372!
\\ anAritmethicObject

	^self lines \\ anAritmethicObject lines! !
!MethodDictionary methodsFor: 'as yet unclassified' library: #MinimalKernel04HashedCollections stamp: 'BSN 11/7/2025 14:58:21' prior: 50372109!
associationAt: key ifAbsent: aBlock 
	"Answer the association with the given key.
	If key is not found, return the result of evaluating aBlock."

	^(array at: (self scanFor: key)) 
		ifNil: [ aBlock lines ]
		ifNotNil: [ :value | key -> value ]! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16902766!
printWithClosureAnalysisToDoOn: aStream indent: level

	| limitNode |
	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.

	limitNode := (arguments last == nil
				or: [arguments last isAssignmentNode not])
					ifTrue: [arguments first]
					ifFalse: [arguments last lines].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printWithClosureAnalysisKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printWithClosureAnalysisKeywords: selector key
					arguments: (Array with: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!Parser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16928615!
correctVariable: proposedVariable interval: aSpot
	"Correct the proposedVariable to a known variable, or declare it as a new
	variable if such action is requested.  We support declaring lowercase
	variables as temps or inst-vars, and uppercase variables as Globals or 
	ClassVars, depending on whether the context is nil (class=UndefinedObject).
	Spot is the interval within the test stream of the variable.
	rr 3/4/2004 10:26 : adds the option to define a new class. "

	"Check if this is an i-var, that has been corrected already (ugly)"

	"Display the pop-up menu"

	| userSelection action delta spot |
	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: [
		^InstanceVariableNode new 
			name: proposedVariable
			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].

	"First check to see if the requestor knows anything about the variable"
	(requestor bindingOf: proposedVariable)
		ifNotNil: [ :binding | ^ encoder global: binding name: proposedVariable].

	"If we can't ask the user for correction, make it undeclared"
	self interactive ifFalse: [^encoder undeclared: proposedVariable].

	userSelection := requestor selectionInterval.
	delta := self sourceDelta.
	spot := aSpot first + delta to: aSpot last + delta.
	requestor selectFrom: spot first to: spot last.

	"Build the menu with alternatives"
	action := UndeclaredVariable 
				signalFor: self
				name: proposedVariable
				inRange: spot.
	action ifNil: [^self fail].

	"Execute the selected action"
	requestor selectInvisiblyFrom: userSelection first to: userSelection last.
	^action lines ifNil: [self fail].
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50504862!
multipleOcurrencesOfTheSameBlockNode
	
	[ 1 ] lines.
	[ 1 ] lines.! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50446572!
m3
"
self new m3
"
	| a1 t1 t2 |

	t1 := 1.

	a1  := [  |t3|
	t3 := 'hola'.
	t1 := 1. t1 + 1.
	t2 := 2 ].

	a1 lines.
! !
!True methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16999489!
and: aBlock1 and: aBlock2 and: aBlock3

	"I sending value to aBlock3 to optimize the generated byte-code - Hernan"
	^aBlock1 lines and: [ aBlock2 lines and: [ aBlock3 lines ]]! !
!Socket methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50585461!
waitForAcceptFor: timeout ifTimedOut: timeoutBlock
	"Wait and accept an incoming connection"
	self waitForConnectionFor: timeout ifTimedOut: [^timeoutBlock lines].
	^self isConnected
		ifTrue:[self accept]
! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16898591!
pastEndPut: anObject
	collection size >= limit ifTrue: [limitBlock lines].  "Exceptional return"
	^ super pastEndPut: anObject! !
!ContentPack methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16837477!
exportInto: aDirectory

	| featureName |
	featureName := 'Graphics-Files-Additional'.
	(FeatureRequirement name: featureName) isAlreadySatisfied
		ifFalse: [
			self error: 'Please load "', featureName, '".'].

	aDirectory assureExistence.

	self associations do: [ :assoc |
		| klass thisDirectory fullPath | 
			klass := assoc lines class.
			thisDirectory := aDirectory / assoc key.
			fullPath :=  aDirectory // assoc key.

		self flag: #note. "Add support for new file export type mappings here. --cbr"
		klass = ContentPack
			ifTrue: [ assoc lines exportInto: thisDirectory ].
		
		klass = ColorForm
			ifTrue: [ assoc lines writePNGfile: fullPath ].
			
		klass = Form
			ifTrue: [ assoc lines writePNGfile: fullPath ]
	]! !
!ToolsCatalog methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50509456!
browse: aToolName

	(tools at: aToolName) lines! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16955501!
before: target ifNone: exceptionBlock
	"Answer the receiver's element immediately before target. Answer
	the result of evaluating the exceptionBlock if there are no elements before it."

	| index |
	index := self indexOf: target.
	^ index = 0
		ifTrue: [self errorNotFound: target]
		ifFalse: [index = 1 
			ifTrue: [exceptionBlock lines]
			ifFalse: [self at: index - 1]]! !
!TestCase methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16984411!
assert: anAction changes: aCondition by: aDifference 
	
	| after before |
	
	before := aCondition lines.
	anAction lines.
	after := aCondition lines.
	
	self assert: after equals: before + aDifference! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16976962!
browseObsoleteReferences   "Smalltalk browseObsoleteReferences"
	| references |
	references := OrderedCollection new.
	(LookupKey allSubInstances select:
		[:x | ((x lines isKindOf: Behavior) and: ['AnOb*' match: x lines name]) or:
		['AnOb*' match: x lines class name]]) 
		do: [:x | references addAll: (self allCallsOn: x)].
	self 
		browseMessageList: references 
		name: 'References to Obsolete Classes'! !
!RenameInstanceVariable methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16947951!
newSourceOf: aMethodAndRangesToChange 
	
	| newSource ranges methodToChange |
	
	methodToChange := aMethodAndRangesToChange key.
	ranges := aMethodAndRangesToChange lines.
	newSource := methodToChange sourceCode copyReplacing: ranges with: newVariable.
	
	^newSource
	! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16788062!
storeLiteral: aCodeLiteral on: aStream
	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName
	 or ###MetaclassSoleInstanceName format if appropriate"
	| key value |
	(aCodeLiteral isVariableBinding)
		ifFalse:
			[aCodeLiteral storeOn: aStream.
			 ^self].
	key := aCodeLiteral key.
	(key isNil and: [(value := aCodeLiteral lines) isMemberOf: Metaclass])
		ifTrue:
			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.
			 ^self].
	(key isSymbol and: [(self bindingOf: key) notNil])
		ifTrue:
			[aStream nextPutAll: '##'; nextPutAll: key.
			 ^self].
	aCodeLiteral storeOn: aStream! !
!MethodDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16906348!
add: anAssociation
	^ self at: anAssociation key put: anAssociation lines! !
!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16817193!
informUserDuring: aBlock
	self class isSilent ifTrue:[^aBlock lines].
	Utilities informUserDuring:[:barBlock|
		progress := barBlock.
		aBlock lines].
	progress := nil.! !
!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50400399!
testInlineBlockCollectionLR3
	| col |
	col := OrderedCollection new.
	1 to: 11 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].
	self assert: (col collect: [ :each | each lines ]) asArray = (2 to: 12) asArray! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50504603!
cascadeNodeWithBlockReceiverThatIsNotEvaluated

	[ self lines ]
		class;
		hash! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461313!
evenInBaseUnit
	
	^self lines evenInBaseUnit ! !
!RxMatcher methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50519349!
restoreState: aBlock

	aBlock lines! !
!TestResultWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16985428!
runSuite

	| suite |
	 
	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(ProgressiveTestRunner for: suite) lines.
	! !
!DenotativeObjectBrowserWindow class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50495333!
browseReferencesTo: anAssociation

	| references label |

	references := self sendersOf: anAssociation.

	label := 'References to ' , anAssociation lines name.
	references isEmpty ifTrue: [^ (PopUpMenu labels: ' OK ') startUpWithCaption: 'There are no ' , label ].

	label := '[', references size printString, '] ', label.

	DenotativeObjectMessageSetWindow
		openMessageList: references asArray sort
		label: label
		autoSelect: anAssociation lines name.! !
!SourceCodeInterval methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16965311!
expandToMatchExpressionOn: aSourceCode
	"takes a source code and if the source range references an expression
	that can be expanded and still is valid, it returns the source range
	'grown'. Examples: (*3 + 4*) to *(3 + 4)*; `*3 + 4*` to *`3 + 4`*"

	| firstCharAndIndex lastCharAndIndex |
	 
	firstCharAndIndex := self skipSeparatorsFrom: start by: -1 in: aSourceCode.
	lastCharAndIndex := self skipSeparatorsFrom: stop by: 1 in: aSourceCode.
	
	^ (self canBeExpandedStartingWith: firstCharAndIndex key endingWith: lastCharAndIndex key)
		ifTrue: [ (self class from: firstCharAndIndex lines to: lastCharAndIndex lines) expandToMatchExpressionOn: aSourceCode ]
		ifFalse: [ self ]! !
!WriteStream methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 17019777!
withAttribute: aTextAttribute do: streamBlock
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock lines ].

	pos1 := self position.
	val := streamBlock lines.
	collection addAttribute: aTextAttribute from: pos1+1 to: self position.
	^ val! !
!RefactoringApplier methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16944704!
createAndSetRefactoringHandlingRefactoringExceptions: aCreatorBlock

	self valueHandlingRefactoringExceptions: [ refactoring := aCreatorBlock lines]
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50504561!
blockWithReadAndWrittenTemporaryVariable

	[ |a| a := 1. a ] lines! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50427160!
test25NotWorkingCase

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	self shouldFail: [
		sourceMethodName := classToRefactor compile: 'm1 1. 1. 1. 1.'.
		
		sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
		finder := ExtractMethodReplacementsFinder ofCodeIn: (7 to: 10) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
		finder lines.
		
		methodsToExtractFrom := finder replacements.
		
		self assert: 1 equals: methodsToExtractFrom size.
		replacement := methodsToExtractFrom first.
		self assert: (7 to: 10) equals: replacement intervalToExtract.
		self assert: (replacement isOf: sourceMethod).
	]
! !
!MethodTypeCheckerVisitor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50443205!
checkMessageSentIn: aMessageNode isImplementedInAll: receiverTypes

	| implementorsFinder |

	implementorsFinder := AllActualLocalImplementors of: aMessageNode selectorSymbol forAll: receiverTypes.
	implementorsFinder lines.

	implementorsFinder notImplementedIsEmpty ifFalse: [
		errors add: (TypeCheckingError on: methodReference node: aMessageNode of: methodNode notImplemented: implementorsFinder notImplemented)].
! !
!TrieLeaf methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 16999013!
at: aString ifAbsent: aBlock characterIndex: i
	"Unused argument i is just for polymorphism with TrieNode"
	| keyIndex |
	keys isArray ifTrue: [
		keyIndex := keys indexOf: aString.
		^ keyIndex = 0
			ifTrue: [ aBlock lines ]
			ifFalse: [ values at: keyIndex ]].
	keys = aString ifTrue: [ ^ values ].
	^ aBlock lines! !
!Array methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50456857!
addType: aType ifFull: aFullBlock

	self withIndexDo: [ :typeAtIndex :rawTypesIndex |
		typeAtIndex = aType ifTrue: [ ^self ].
		typeAtIndex ifNil: [ ^self at: rawTypesIndex put: aType ]].

	^aFullBlock lines.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50461502!
moduloSimpleMeasure: aMeasure

	^self lines moduloSimpleMeasure: aMeasure! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:21' prior: 50426506!
test04DoesNotIncludeComments

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10. "10"'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 5) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 1 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 5) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16793490!
whileTrue
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the receiver, as long as its value is true."
 
	^ [self lines] whileTrue: []! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16898997!
printOn: aStream indent: level
	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream
						nextPutAll: '###';
						nextPutAll: key lines soleInstance name ]
				ifFalse: [
					aStream
						nextPutAll: '##';
						nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ | isComplex |
					isComplex := false.
					key isArray ifTrue: [
						isComplex := key anySatisfy: [ :ea |
							ea isArray ]].
					"Is it complex? (i.e. array of arrays)"
					isComplex
						ifTrue: [
							aStream
								nextPut: $#;
								nextPut: $(.
							key do: [ :ea |
								aStream newLineTab: (1 max: level + 1).
								ea printAsLiteralOn: aStream ].
							aStream newLineTab: (1 max: level).
							aStream nextPut: $) ]
						ifFalse: [ key printAsLiteralOn: aStream ]]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $` ]]! !
!Parser class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16929291!
chainExamplesDoubleColon

	1 bitShift: 3 :: + 5.  "13"

	3 + 4 :: negated + 2 :: negated - 2 bitShift: 2 :: bitShift: -1.  "6"

	1 = 2 and: [3 = 4] :: ifTrue: [5] ifFalse: [6].  "6"

	1 = 1
		:: and: [2 = 2]
		:: and: [3 = 3]
		:: and: [4 = 4]
		:: ifTrue: [#yes] ifFalse: [#bummer].  "#yes"

	1 = 1 :: = true.  "true"

	1 = 1 :: ifTrue: [2] ifFalse: [3] :: + 1 ; + 10.  "12"

	1 bitShift: 3 :: + 2 bitShift: -1.  "5"

	1 to: 10 by: 3 :: size.  "4"

	1 to: 10 by: 3 :: inject: 0 into: [:t :x | t + x].  "22"

	1 to: 10 by: 3 :: inject: 0 into: [:t :x | t + x] :: bitShift: -1 :: - 1.  "10"

	CompiledMethod allInstances
		:: reject: [:x | x getSourceFromFile isNil]
		:: collect: [:x | x getSourceFromFile -> x]
		:: collect: [:x | x key occurrencesOf: $( :: + (x key occurrencesOf: $)) :: -> x key -> x lines]
		:: asSortedCollection: [:x :y | x > y]
		:: inspect.! !
!VariableTypeInfo methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50445660!
commonSupertypeIfNoTypes: aBlock

	| types commonSupertypes commonSupertype |

	types := self types.
	types := types reject: [ :aType | aType = UndefinedObject ].
	types isEmpty ifTrue: [ ^aBlock lines ].
	types size = 1 ifTrue: [ ^types anyOne ].

	"I have to convert types to Array becuase inst var types can be a Set - Hernan"
	commonSupertypes := self allSupertypesOf: types.
	commonSupertype := self commonLowestTypeIn: commonSupertypes.

	^commonSupertype ! !
!AdditionalMethodState methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16780663!
hasLiteralSuchThat: aBlock
	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.
	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [(aBlock value: propertyOrPragma key)
					or: [(aBlock value: propertyOrPragma lines)
					or: [propertyOrPragma lines isArray
						and: [propertyOrPragma lines hasLiteralSuchThat: aBlock]]]]
			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue: [^true]].
	^false! !
!CodeCoverageAnalyzerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50504153!
test012_DoesNotAllowRequestingTheCodeCoverageReportForACompiledMethodThatWasNotAnalyzed

	self setupCodeCoverageAnalyzerForM1Method;
		startTrackingCodeCoverage;
		stopTrackingCodeCoverage.
	
	self assertRaisesCompiledMethodWasNotAnalizedError:  [ codeCoverageAnalyzer report reportForCompiledMethod: Object>>#lines ]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50504979!
raiseErrorFromBlock

	[ self error: self errorMessageForTesting ] lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461344!
sameUnitAs: aMeasure

	^self lines sameUnitAs: aMeasure! !
!MorphicAlarm methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16914845!
valueAtTime: millisecondClock

	|  nArgs |
	numArgs ifNil: [numArgs := selector numArgs].
	nArgs := arguments ifNil: [0] ifNotNil: [arguments size].
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self lines ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondClock]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondClock) ]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16799791!
renameInstVar

	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RenameInstanceVariableApplier on: self at: aClass) lines ].! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50400599!
testSample01
	| blockClosure materialized |
	blockClosure _ self bc01.
	materialized _ blockClosure veryDeepCopy.
	self assert: blockClosure lines = materialized lines.! !
!FinderMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50508924!
toolbarButtonFor: aCatalog

	^ (PluggableButtonMorph
		model: (CatalogButton for: aCatalog model: model)
		stateGetter: #isSelected
		action: #lines
		label: aCatalog name)
		color: Theme current finderSearchBarToolbarButtonColor; 
		yourself! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461417!
max: aMagnitude
	"Send value to self so that it is faster and does not pass through #doesNotUnderstand.
	Self is given back and not self value to continue maintaining the evaluation"

	self lines < aMagnitude ifTrue: [^aMagnitude].
	^self! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50426634!
test08FindsRepetitionsWithMultipleSelection

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10 factorial. 10 factorial. true ifTrue: [ 10 factorial. 10 factorial]'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 29) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (47 to: 72) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (4 to: 29) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!EphemeronIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16859964!
add: anAssociation
	
	"Installs a copy of the association in myself.
	I cannot add the association because they are not shareable between weak key dictionaries, it needs myself as container.
	Moreover, I can only contain Ephemerons, and not other kinds of Association."
	self at: anAssociation key put: anAssociation lines.

	^ anAssociation! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50401090!
testMethodArgument
	| temp block |
	temp := 0.
	block := [ [ temp ] ].
	temp := 1.
	block := block lines.
	temp := 2.
	self assert: block lines = 2! !
!IniFile methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16882854!
atGlobalEntry: entryName orDefault: aBlock
	"If section or entry is missing, answer the result of evaluating aBlock,
	but don't add the section or entry."

	globalSection isNil ifTrue: [ ^aBlock lines ].
	^globalSection at: entryName orDefault: aBlock.! !
!DenotativeObjectBrowser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50494368!
validateObjectCreation: defTokens 

	| denotativeObjectName nameIndex |
	
	nameIndex := defTokens findFirst: [ :token | token beginsWith: '#' ].
	nameIndex = 0 ifTrue: [ self error: self objectNameMustBeSymbolErrorDescription ].
	
	denotativeObjectName := (defTokens at: nameIndex) copyWithoutAll: '#()'.
	(NewDenotativeObjectPrecondition for: denotativeObjectName asSymbol in: Smalltalk undeclared: Undeclared) lines.
! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461656!
convertAmountToBaseUnit

	^self lines convertAmountToBaseUnit! !
!FixedGregorianDate methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50479956!
= anObject

	| valuedObject |

	self == anObject ifTrue: [^true].
	anObject isGregorianDate ifFalse: [^false].
	valuedObject := anObject lines.

	^dayNumber = valuedObject dayNumber and: [ monthOfYear = valuedObject monthOfYear ]! !
!CompiledMethod methodsFor: 'as yet unclassified' library: #MinimalKernel01 stamp: 'BSN 11/7/2025 14:58:22' prior: 50366348!
methodClass
	"answer the class that I am installed in"
	^(self literalAt: self numLiterals) lines.! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16848980!
keyAtIdentityValue: value ifAbsent: exceptionBlock
	"Answer the key that is the external name for the argument, value. If 
	there is none, answer the result of evaluating exceptionBlock.
	Note: There can be multiple keys with the same value. Only one is returned."
 
	self associationsDo: 
		[:association | value == association lines ifTrue: [^association key]].
	^exceptionBlock lines! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50497374!
stringToEvalSending: aSymbol to: aDenotativeObject onCancel: aCancelBlock

	| externalCollaborators |
	
	externalCollaborators := (aDenotativeObject class >> aSymbol) methodNode arguments collect: [ :anArgumentNode |
		StringRequestMorph request: 'Enter collaborator ', anArgumentNode name orCancel: [^aCancelBlock lines] ].
	
	^String streamContents: [ :stream |
		stream 
			nextPutAll: aDenotativeObject name;
			space.
			
		aSymbol numArgs = 0
			ifTrue: [ stream nextPutAll: aSymbol ]
			ifFalse: [ 
				aSymbol keywords withIndexDo: [ :keyword :index |
					stream 
						nextPutAll: keyword;
						nextPutAll: ' (';
						nextPutAll: (externalCollaborators at: index);
						nextPutAll: ') ' ]]]
					
	! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16808560!
fileOutMethodChangesFor: class on: stream
	"Write out all the method changes for this class."

	| changes |
	changes := Set new.
	(self methodChangesAtClass: class name) associationsDo: [ :mAssoc |
		(mAssoc lines == #remove
			or: [ mAssoc lines == #addedThenRemoved
				or: [ mAssoc lines == #add
					or: [ mAssoc lines == #movedToOtherPackage ]]])
			ifFalse: [ changes add: mAssoc key ]].
	changes isEmpty ifFalse: [
		class fileOutChangedMessages: changes on: stream.
		stream newLine ]! !
!Morph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16910628!
valueOfProperty: aSymbol ifAbsent: aBlock
	"if the receiver possesses a property of the given name, answer
	its value. If not then evaluate aBlock and answer the result of
	this block evaluation"
	^ properties
		ifNil: [ aBlock lines ]
		ifNotNil: [ properties at: aSymbol ifAbsent: aBlock ]! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50334818!
withSubclassesThatDefineInstanceVariable: aName do: foundBlock ifNone: noneBlock

	| definingSubclasses |

	definingSubclasses := self allSubclasses select: [ :aSubclass |
		aSubclass definesInstanceVariableNamed: aName ].

	^definingSubclasses isEmpty
		ifTrue: [ noneBlock lines ]
		ifFalse: [ foundBlock value: definingSubclasses ]! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50470755!
performWithFormulaWithMeasure

	self assert: (formulaOfTenPesos perform: messageName with: self twentyPesos) lines = 
		(formulaOfTenPesos lines perform: messageName with: self twentyPesos lines)! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16786428!
sortedCounts
	"Answer with a collection of counts with elements, sorted by decreasing count."
	| counts |
	counts := SortedCollection sortBlock: [:x :y | x >= y].
	contents associationsDo:
		[:assn |
		counts add: (Association key: assn lines value: assn key)].
	^ counts! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16955757!
lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock
	"Answer the index of the last occurence of anElement within the  
	receiver. If the receiver does not contain anElement, answer the
	result of evaluating the argument, exceptionBlock."

	lastIndex to: 1 by: -1 do:
		[:index |
		(self at: index) = anElement ifTrue: [^ index]].
	^ exceptionBlock lines! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16849114!
keysAndValuesRemove: keyValueBlock
	"Removes all entries for which keyValueBlock returns true."
	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."

	| removals |
	removals := OrderedCollection new.
	self associationsDo:
		[:assoc | (keyValueBlock value: assoc key value: assoc lines)
			ifTrue: [removals add: assoc key]].
 	removals do:
		[:aKey | self removeKey: aKey]! !
!FinalizationRegistryTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50422720!
setUp

	super setUp.

	finalizationRegistry := FinalizationRegistry new.

	finalizerFired := false.
	finalizerThatSignals := ObjectFinalizer new receiver: [
		finalizerFired := true ] selector: #lines.

	finalizerThatRaisesError := ObjectFinalizer new receiver: [ 
		Error signal ] selector: #lines.! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461695!
to: stop

	^self lines to: stop! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16807968!
messageListForChangesWhich: aBlock ifNone: ifEmptyBlock

	| answer |

	answer := self changedMessageListAugmented select: [ :each |
		aBlock value: each actualClass value: each methodSymbol
	].
	answer isEmpty ifTrue: [^ifEmptyBlock lines].
	^answer
! !
!CodeCoverageAnalyzer methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50500782!
generateReport
	
	| compiledMethodReports |
	compiledMethodReports := coverageReportBuilders collect: [ :reportBuilder | reportBuilder lines ].
	
	report := CodeCoverageAnalyzerReport withAll: compiledMethodReports.
	! !
!WebUtils class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50594969!
readHeadersFrom: aStream
	"Parse http headers and answer a collection of key -> value pairs."

	| headers nextLine existing |
	headers := OrderedCollection new.
	[nextLine := aStream upToAll: String crlfString.
	nextLine isEmpty] whileFalse:[
		nextLine first isSeparator ifTrue:["Continuation as per HTTP 1.1 spec"
			existing := headers last.
			existing value: (existing lines, String space, nextLine withBlanksTrimmed).
		] ifFalse:["Regular header"
			headers add: 
				(nextLine copyUpTo: $:) asLowercase ->
					(nextLine copyAfter: $:) withBlanksTrimmed.
		].
	].
	^headers! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16834143!
blockExtentsInto: aDictionary from: initialPC to: endPC scanner: scanner numberer: numbererBlock
	"Support routine for startpcsToBlockExtents"
	| extentStart blockSizeOrLocator |
	self flag: 'belongs in DebuggerMethodMap'.
	extentStart := numbererBlock lines.
	[scanner pc <= endPC] whileTrue:
		[blockSizeOrLocator := scanner interpretNextInstructionFor: BlockStartLocator new.
		 blockSizeOrLocator isInteger ifTrue:
			[self
				blockExtentsInto: aDictionary
				from: scanner pc
				to: scanner pc + blockSizeOrLocator - 1
				scanner: scanner
				numberer: numbererBlock]].
	aDictionary at: initialPC put: (extentStart to: numbererBlock lines).
	^aDictionary! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50400980!
testBlockTemp
	| block block1 block2 |
	block := [ :arg | [ arg ] ].
	block1 := block value: 1.
	block2 := block value: 2.
	self assert: block1 lines = 1.
	self assert: block2 lines = 2! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16853983!
tempsAndBlockArgs
	| tempNodes |
	tempNodes := OrderedCollection new.
	scopeTable associationsDo:
		[:assn | | var |
		var := assn lines.
		(var isTemp
		 and: [var isMethodArg not
		 and: [var scope = 0 or: [var scope = -1]]]) ifTrue:
			[tempNodes add: var]].
	^tempNodes! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16849198!
collect: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."
	
	| newCollection |
	newCollection := self species newWithRoomForMoreThan: self size.
	self associationsDo: [ :each |
		newCollection at: each key put: (aBlock value: each lines) ].
	^newCollection! !
!WeakSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 17016586!
remove: oldObject ifAbsent: aBlock

	| hashValue indexInBucketForDirectAccess |
	hashValue := self hashFor: oldObject.
	(buckets at: (self bucketIndexFor: hashValue)) ifNotNil:
		[ :bucket |
			indexInBucketForDirectAccess := self indexInBucketFor: hashValue.
			(self areEqual: (bucket at: indexInBucketForDirectAccess) and: oldObject) ifTrue:
				[
					bucket at: indexInBucketForDirectAccess put: nil.
					estimatedSize := estimatedSize - 1.
					^oldObject ].
			(self basicLook: oldObject inIterablePartOf: bucket)
				ifNotNil: [ :index |
					bucket at: index put: nil.
					estimatedSize := estimatedSize - 1.
					^oldObject ]].
	^ aBlock lines! !
!TempVariableNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16983348!
analyseClosure: rootNode "<MethodNode>"
	"Analyse whether the temporary needs to be made remote
	 or not, and answer whether it was made remote.
	 A temp cannot be local if it is written to remotely,
	 or if it is written to after it is closed-over.  An exception
	 is an inlined block argument that appears to be written
	 remotely but is actually local to a block."
	| latestWrite |
	self isBlockArg ifTrue: [^false].
	remoteNode ifNotNil: [^false]. "If already remote, don't remote a second time"
	latestWrite := 0.
	((writingScopes notNil
	 and: [writingScopes associations anySatisfy: [:assoc|
			[:blockScope :refs|
			refs do: [:write| latestWrite := write max: latestWrite].
			"A temp cannot be local if it is written to remotely."
			blockScope actualScope ~~ definingScope actualScope]
				value: assoc key value: assoc lines]])
	or: [readingScopes notNil
		and: [readingScopes associations anySatisfy: [:assoc|
				[:blockScope :refs|
				 "A temp cannot be local if it is written to after it is closed-over."
				 blockScope actualScope ~~ definingScope actualScope
				 and: [refs anySatisfy: [:read| read < latestWrite]]]
					value: assoc key value: assoc lines]]]) ifTrue:
		[remoteNode := definingScope addRemoteTemp: self rootNode: rootNode.
		 ^true].
	^false! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50504703!
implicitSelfReturnWhenSelfIsReferenced
	
	self lines.! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50446519!
m1_read_write_temp

	| t1 |

	t1 := 1.
	[ t1 := t1 + 1 ] lines.

	^t1! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50454714!
test10WarningsDetectIfNone

	| typeChecker typeWarning |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithWarningForError. }.
	typeChecker lines.

	typeWarning := typeChecker warningsDetect: [ :aTypeWarning | true ] ifNone: [ self fail ].
	self assert: typeWarning receiver isMessageNode.
	self assert: #first equals: typeWarning selector key.
! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16793701!
valueWithPossibleArgument: anArg and: secondArg
	"Evaluate the block represented by the receiver. 
	 If the block requires one argument, use anArg, 
	if it requires two, use anArg and secondArg.
	Squeak uses #cull:, #cull:cull:, etc. I (jmv) find that name quite obscure"

	numArgs = 0 ifTrue: [ ^self lines ].
	numArgs = 1 ifTrue: [ ^self value: anArg ].
	^self value: anArg value: secondArg! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16847286!
convertToDoLoop: blockBodyTempCounts
	"If statements contains the pattern
		var := startExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	or
		var := startExpr.
		limit := limitExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	then replace this by
		startExpr to: limit by: incConst do: [:var | ...statements...]
	 and answer true."
	| whileStmt incrStmt initStmt limitStmt toDoStmt |
	whileStmt := statements last.
	incrStmt := whileStmt arguments first statements last.
	incrStmt isAssignmentNode ifFalse:
		[^false].
	(self startAndLimitFor: incrStmt variable from: stack into:
							[:startExpr :limitExpr| initStmt := startExpr. limitStmt := limitExpr])
		ifTrue:
			[| limitInStatements |
			 limitInStatements := limitStmt isNil
								    and: [statements size > 1
								    and: [self startAndLimitFor: incrStmt variable from: { stack last. (statements last: 2) first } into:
												[:startExpr :limitExpr| limitStmt := limitExpr]]].
			(toDoStmt := statements last toDoFromWhileWithCounts: blockBodyTempCounts init: initStmt limit: limitStmt) ifNil:
				[^false].
			 limitInStatements
				ifTrue:
					[stack
						removeLast;
						addLast: toDoStmt.
					 statements removeLast: 2]
				ifFalse:
					[stack
						removeLast: (limitStmt ifNil: [1] ifNotNil: [2]);
						addLast: toDoStmt.
					 statements removeLast]]
		ifFalse:
			[(self startAndLimitFor: incrStmt variable from: statements allButLast into:
							[:startExpr :limitExpr| initStmt := startExpr. limitStmt := limitExpr]) ifFalse:
				[^false].
			 (toDoStmt := statements last toDoFromWhileWithCounts: blockBodyTempCounts init: initStmt limit: limitStmt) ifNil:
				[^false].
			 statements
				removeLast: (limitStmt ifNil: [2] ifNotNil: [3]);
				addLast: toDoStmt].
	self markTemp: initStmt variable asOutOfScope: -1. "Flag arg as out of scope"
	initStmt variable beBlockArg.
	limitStmt ifNotNil:
		[self markTemp: limitStmt variable asOutOfScope: -2.
		 toDoStmt arguments at: 1 put: limitStmt lines]. "Flag limit as hidden"
	^true! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16955741!
lastIndexOf: anElement startingAt: lastIndex endingAt: firstIndex ifAbsent: exceptionBlock
	"Answer the index of the last occurence of anElement within the  
	receiver. If the receiver does not contain anElement, answer the
	result of evaluating the argument, exceptionBlock."

	self lastIndexOf: anElement startingAt: lastIndex endingAt: firstIndex do: [ :index | ^index ].
	^exceptionBlock lines.! !
!CharacterSequence methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16814902!
correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results maxChoices |
	scoreMin := self size // 2 min: 3.
	maxChoices := 10.
	choices := oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x lines > y lines ] ].
	wordBlock
		ifNil: [
			results := OrderedCollection new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				| score |
				(score := self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) lines] ] ].
			results := choices ].
	^ results! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16799671!
runMethodTest
	
	| suite |
	
	suite := TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgressiveTestRunner for: suite) lines 
	! !
!KeyboardEvent methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50386776!
sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	keyEventType == #keystroke ifTrue: [
		(self shiftPressed and: [ self isReturnKey ]) ifTrue: [ 
			(Preferences at: #classFinder) lines.
			self wasHandled: true.
			^self ].
		aMorph processKeystroke: self.
		^self ].
	keyEventType == #keyDown ifTrue: [
		aMorph processKeyDown: self.
		^self ].
	keyEventType == #keyUp ifTrue: [ 
		aMorph processKeyUp: self.
		^self ].! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16793499!
whileTrue: aBlock 
	"Ordinarily compiled in-line, and therefore not overridable.
	This is in case the message is sent to other than a literal block.
	Evaluate the argument, aBlock, as long as the value of the receiver is true."

	^ [self lines] whileTrue: [aBlock lines]! !
!ClosureTypeExamples methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50446514!
m1_read_temp

	| t1 |

	t1 := 1.
	[t1 + 1 ] lines.

	^t1! !
!SubstringMatcher class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50509801!
valueFiltering: aCollection with: aSubstring 
	
	^ (self forFiltering: aCollection with: aSubstring)
		lines
		! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50454656!
test05ProblemsDetectIfNoneValuesIfNoneWhenNoProblemFound

	| typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithoutTypeErrors }.
	typeChecker lines.

	typeChecker problemsDetect: [ :aTypeCheckProblem | true ] ifNone: [ ^self ].

	self fail! !
!PreferenceSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50440037!
withTemporaryValue: temporaryValue of: aPreferenceName do: aBlock
	"Allows to execute a piece of code with a temporary value of the given preference. Useful for testing purposes."
	
	| currentValue |
	currentValue := self at: aPreferenceName.
	self at: aPreferenceName put: temporaryValue.
	[ aBlock lines ] ensure: [ self at: aPreferenceName put: currentValue ]! !
!FilteredGregorianDate methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50479703!
< aDate

	^date < aDate lines! !
!WorldMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 17018309!
dropFiles: aDropFilesEvent

	(DropFilesAction for: aDropFilesEvent) lines! !
!False methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16864814!
ifFalse: alternativeBlock 
	"Answer the value of alternativeBlock. Execution does not actually
	reach here because the expression is compiled in-line."

	^alternativeBlock lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461383!
truncated
	
	^self lines truncated
! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16961408!
contextualPushDownInClassDefinition 

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
				self apply: [ :aSelectedClass | 
					(PushDownInstanceVariableApplier 
						on: self codeProvider 
						for: self wordUnderCursor 
						at: aSelectedClass ) lines ] inClassDefinitionOf: classDefinitionNode in: selectedClass ]
			ifErrorsParsing: [ :anError | morph flash ]]! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50553901!
extractMethodToMethodObject

	| classToRefactor messageName |

	messageName := model selectedMessageName.
	classToRefactor := model selectedClassOrMetaClass.

	messageName ifNotNil: [ | compiledMethod|
		compiledMethod := classToRefactor compiledMethodAt: messageName.

		(ExtractToMethodObjectApplier extract: compiledMethod) lines.].! !
!Preference methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16936256!
value
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value lines]
		ifFalse: [value]
	! !
!ClosureTests methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50400971!
testBlockArgument
	| block block1 block2 |
	block := [ :arg | | temp | temp := arg. [ temp ] ].
	block1 := block value: 1.
	block2 := block value: 2.
	self assert: block1 lines = 1.
	self assert: block2 lines = 2! !
!DisplayScreen methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16851212!
findAnyDisplayDepthIfNone: aBlock
	"Return any display depth that is supported on this system.
	If there is none, evaluate aBlock."
	#(32 16 8 4 2 1 -32 -16 -8 -4 -2 -1) do:[:bpp|
		(self supportsDisplayDepth: bpp) ifTrue:[^bpp].
	].
	^aBlock lines! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16849155!
removeKey: key ifAbsent: aBlock 
	"Remove key (and its associated value) from the receiver. If key is not in 
	the receiver, answer the result of evaluating aBlock. Otherwise, answer 
	the value externally named by key."

	| index assoc |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc
		ifNil: [^ aBlock lines].
	array at: index put: nil.
	tally := tally - 1.
	self fixCollisionsFrom: index.
	^ assoc lines! !
!Process methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16937822!
environmentAt: key  ifAbsent: aBlock
	
	^(env ifNil: [ ^aBlock lines ]) at: key ifAbsent: aBlock.! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16788771!
ultimateSourceCodeAt: selector ifAbsent: aBlock
	"Return the source code at selector, deferring to superclass if necessary"

	^ self
		sourceCodeAt: selector
		ifAbsent: [
			superclass
				ifNil: [aBlock lines]
				ifNotNil: [superclass ultimateSourceCodeAt: selector ifAbsent: aBlock]]! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50470771!
performWithFractionWithFormula

	self assert: (1/3 perform: messageName with: formulaOfTenPesos) lines = 
		((1/3) lines perform: messageName with: formulaOfTenPesos lines)! !
!InlineMethod class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16884102!
assertSenders: aCollectionOfSenders belongToClassOf: aCompiledMethod ifFalse: ifFalseBlock

	(aCollectionOfSenders allSatisfy: [:aSender | self sender: aSender belongsToClassOf: aCompiledMethod])
		ifFalse: [^ifFalseBlock lines].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461377!
^ aPower

	^self lines ^ aPower! !
!String methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16968029!
indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start.
	aByteSetByteArray is a ByteArray of size 256 with a 1 for byte values considered to be included."

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aByteSetByteArray startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock lines ]
		ifFalse: [ answer]! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50426959!
test19FindsBlockNodesWithTemporaries

	| sourceMethodName finder methodsToExtractFrom sourceMethod |
	
	sourceMethodName := classToRefactor compile: 'm1 true and: [ | t1 | false ]'.
	classToRefactor compile: 'm2 true and: [ | t1 | false ]'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (16 to: 27) asSourceCodeInterval at: sourceMethod to: (Message selector: #m3). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	self assert: ((methodsToExtractFrom collect: [ :aReplacement | aReplacement methodToExtractFrom selector ]) includesAllOf: #(m1 m2)).
	self assert: (16 to: 27) equals: methodsToExtractFrom first intervalToExtract.
	self assert: (16 to: 27) equals: methodsToExtractFrom second intervalToExtract.
	! !
!Utilities class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 17005446!
awaitMouseUpIn: box whileMouseDownDo: doBlock1 whileMouseDownInsideDo: doBlock2 ifSucceed: succBlock
	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock1, and also, if the cursor is within the box, execute doBlock2.  6/10/96 sw
3/31/00 JMM added logic to stop multiple redraws"

	| p inside lightForm darkForm isLight |

	p := Sensor mousePoint.
	inside := box insetBy: 1.
	isLight := true.
	lightForm := Form fromDisplay: inside.
	darkForm := lightForm copy reverse.
	[Sensor isAnyButtonPressed] whileTrue:
		[doBlock1 lines.
		(box containsPoint: (p := Sensor mousePoint))
			ifTrue: [doBlock2 lines.
					isLight ifTrue: 
						[isLight := false.
						darkForm displayAt: inside origin]]
			ifFalse: [isLight ifFalse:
						[isLight := true.
						lightForm displayAt: inside origin]]].
	(box containsPoint: p)
		ifTrue: [lightForm displayAt: inside origin.
				^ succBlock lines]
! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461317!
isCompoundMeasure

	^self lines isCompoundMeasure! !
!MorphicCanvas methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16915708!
clippingByCurrentMorphDo: aBlock
	"Do clipping only if currentMorph says so"

	| prevClipRect prevClippingMorphRect |

	currentMorph clipsSubmorphs ifFalse: [ ^aBlock lines ].

	prevClipRect := clipRect.
	prevClippingMorphRect := clippingMorphDisplayBounds.
	clippingMorphDisplayBounds := self boundingRectOfCurrentMorphAfterDraw insetBy: 1.
	self setClipRect: (prevClipRect
		ifNil: [clippingMorphDisplayBounds]
		ifNotNil: [prevClipRect intersect: clippingMorphDisplayBounds]).
	self clipByCurrentMorphStart.
	aBlock ensure: [
		self clipByCurrentMorphStop.
		self setClipRect: prevClipRect.
		clippingMorphDisplayBounds := prevClippingMorphRect ]! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50539262!
isAssignmentToNil: aNode

	^aNode isAssignmentNode and: [(aNode lines isNilPseudoVariable) and: [aNode variable name =  instVar]].! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16854670!
rangesForVariable: aName checkingType: nodeTypeCheckBlock ifAbsent: anAbsentBlock

	| variableNode |
	
	variableNode := scopeTable at: aName ifAbsent: [ ^anAbsentBlock lines ].
	(nodeTypeCheckBlock value: variableNode) ifFalse: [ ^anAbsentBlock lines ].
	
	^sourceRanges at: variableNode ifAbsent: anAbsentBlock ! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16961569!
renameGlobalOn: aBrowser for: anOldName

	(RenameGlobalApplier on: aBrowser for: anOldName) lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461386!
< aMagnitude

	^self lines < aMagnitude! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50458431!
typeInfoOfInstanceVariableNamed: anInstVarName ifAbsent: aBlock

	^aBlock lines! !
!InlineMethodWithActualScope class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50449513!
addActualImplementorsOf: aSelectorToInline forTypes: receiverTypes to: implementors
	andActualMessageSendsTo: messageSends inSystem: aSystem

	| actualImplementors actualSendersCollector |

	receiverTypes do: [ :aType |
		actualImplementors := (aSystem actualImplementorsOf: aSelectorToInline in: aType)
			collect: [ :anImplementor | anImplementor compiledMethodIfAbsent: [ anImplementor ]].
		implementors addAll: actualImplementors ].

	actualSendersCollector := MultiImplementorsActualMessageSendsCollector for: implementors.
	actualSendersCollector lines.

	actualSendersCollector messageList do: [:aMethodNodeReference |
		"The message list contains a mix of dummy method references (that work as separator titles
		in the message list window), actual real method node references and possible senders"

	aMethodNodeReference isMessageListTitle
			ifTrue: [ | titleMessageNode |
				titleMessageNode := MessageNodeReference messageNode: nil selector: aMethodNodeReference selector
					class: aMethodNodeReference actualClass completeSourceRange: #().
				titleMessageNode stringVersion: aMethodNodeReference stringVersion.
				messageSends add: titleMessageNode
			]
			ifFalse: [ | messageNodeReferences |
				messageNodeReferences _ self findReferencesToSelector: aSelectorToInline in: aMethodNodeReference
					whenSentTo: receiverTypes.
				messageSends addAll: ((aMethodNodeReference isPossibleSender)
					ifTrue: [messageNodeReferences collect: [:messageNodeReference |
							messageNodeReference asPossibleMessageNodeReference ]]
					ifFalse: [messageNodeReferences])
				].
	].

	! !
!TransferMethodApplier class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16998658!
applyFrom: aCodeProvider

	aCodeProvider selectedMessageName ifNotNil: [ :selectedSelector |
		(self 
			on: aCodeProvider 
			for: aCodeProvider selectedClassOrMetaClass>>selectedSelector) lines ].
	! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16955794!
penultimateIfAbsent: aBlock
	
	| size |
	
	size := self size.
	size >= 2 ifTrue: [ ^self at: size-1 ].
	^aBlock lines! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16965960!
startAndEndNodesShareAParentNode  

	| parseNodesInCommon |
	parseNodesInCommon := self parseNodesInCommon.
	
	^ parseNodesInCommon notEmpty and: [
		(self trimmed: parseNodesInCommon first lines) = intervalToExtract]


! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50333863!
associationForClass
	| assoc |
	assoc := Smalltalk associationAt: class name ifAbsent: nil.
	^assoc lines == class
		ifTrue: [ assoc ]
		ifFalse: [ Association new value: class ]! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50504801!
messageWithArgument: anArgument
	
	anArgument lines! !
!Collection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16828597!
detect: aBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.
	Answer the first element for which aBlock evaluates to true."

	self do: [:each | (aBlock value: each) ifTrue: [^each]].
	^exceptionBlock lines! !
!IfNilChecksFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50547056!
test11WhenThereAreMultipleIfNilChecksInTheSameMethodTheResultIncludesAllOfThem

	| contextClass anIfNilCheckStatement methodHeader source result anIfNotNilCheckStatement |

	contextClass := self createClassNamed: #ContextClass instanceVariableNames: self instVar.

	methodHeader := 'm1 '.
	anIfNilCheckStatement := self instVar, ' ifNil: [1 + 1].'.
	anIfNotNilCheckStatement := self instVar, ' ifNotNil: [1 + 1].'.
	source := methodHeader, anIfNilCheckStatement, anIfNotNilCheckStatement.
	contextClass compile: source.

	result := (IfNilChecksFinder on: contextClass for: self instVar) lines.

	self assert: 2 equals: result size.
	self assert: (source findString: 'ifNotNil') equals: result first messageNodeIndex.
	self assert: #m1 equals: result second methodNode selector.
	self assert: (source findString: 'ifNil') equals: result second messageNodeIndex.
	self assert: #m1 equals: result first methodNode selector.! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16793787!
on: exception do: handlerAction
	"Evaluate the receiver in the scope of an exception handler.
	The following primitive is just a marker used to find the error handling context. 
	See MethodContext>>#isHandlerOrSignalingContext. "
	<primitive: 199>  
	^ self lines! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16795174!
ifHasRemoteTempNodeEnsureInitializationStatementExists: rootNode
	"If a remoteTempNode has been added ensure a statement exists to initialize it."
	remoteTempNode ~~ nil ifTrue:
		[(statements notEmpty
		  and: [statements first isAssignmentNode
		  and: [statements first variable isTemp
		  and: [statements first variable isIndirectTempVector]]])
			ifTrue: "If this is a decompiled tree, or if a temporary has been added later in
					the analysis then there already is a temp vector initialization node."
				[(statements first variable ~~ remoteTempNode) ifTrue:
					[statements first variable become: remoteTempNode].
				 statements first lines numElements: remoteTempNode remoteTemps size]
			ifFalse:
				[statements addFirst: (remoteTempNode nodeToInitialize: rootNode encoder)]].! !
!SequenceableCollection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16955364!
at: index ifAbsent: exceptionBlock
	"Answer the element at my position index. If I do not contain an element
	at index, answer the result of evaluating the argument, exceptionBlock."

	(self isInBounds: index) ifTrue: [^self at: index].
	^exceptionBlock lines! !
!ClassChangeRecord methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16818359!
methodChangeTypes
	"Return an old-style dictionary of method change types."

	| dict |
	dict := IdentityDictionary new.
	methodChanges associationsDo:
		[:assn | | selector record |
		selector := assn key.
		record := assn lines.
		dict at: selector put: record changeType].
	^ dict! !
!CPUWatcher methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16802999!
findThePig
	"tally has been updated. Look at it to see if there is a bad process.
	This runs at a very high priority, so make it fast"
	| countAndProcess | 
	countAndProcess := tally sortedCounts first.
	(countAndProcess key / tally size > threshold) ifTrue: [ | proc |
		proc := countAndProcess lines.
		proc == Processor backgroundProcess ifTrue: [ ^self ].	"idle process? OK"
		self catchThePig: proc
	].
! !
!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 17000604!
ifNil: aBlock
	"A convenient test, in conjunction with Object ifNil:"

	^ aBlock lines! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461646!
composeWithNumber: aMeasure

	^self lines composeWithNumber: aMeasure! !
!Socket class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50585880!
udpCreateIfFail: failBlock
	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."

	| sock |
	self initializeNetwork.
	sock := self newUDP.
	sock isValid ifFalse: [^ failBlock lines].
	^ sock
! !
!Integer methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16892225!
timesRepeat: aBlock 
	"Evaluate the argument, aBlock, the number of times represented by
	the receiver."

	| count |
	count := 1.
	[count <= self]
		whileTrue: 
			[aBlock lines.
			count := count + 1]! !
!SequenceableCollection methodsFor: 'as yet unclassified' library: #MinimalKernel01 stamp: 'BSN 11/7/2025 14:58:22' prior: 50365130!
indexOf: anElement startingAt: start ifAbsent: exceptionBlock
	"Answer the index of anElement within the receiver. If the receiver does 
	not contain anElement, answer the result of evaluating the argument, 
	exceptionBlock."
	start to: self size do:
		[:i | (self at: i) = anElement ifTrue: [^ i]].
	^ exceptionBlock lines! !
!Point methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16933863!
barycentricCoordinatesInTriangle: p1 with: p2 with: p3 into: aBlock ifDegenerate: degeneratBlock
	"Return  the barycentric coordinates for the receiver within the triangle defined by the three arguments."
	| p0 b0 b1 b2 b3 |
	p0 := self.
	b0 := ((p2 x - p1 x) * (p3 y - p1 y)) - ((p3 x - p1 x) * (p2 y - p1 y)).
	b0 isZero ifTrue: [ ^ degeneratBlock lines ]. "degenerate"
	b0 := 1.0 / b0.
	b1 := (((p2 x - p0 x) * (p3 y - p0 y)) - ((p3 x - p0 x) * (p2 y - p0 y))) * b0.
	b2 := (((p3 x - p0 x) * (p1 y - p0 y)) - ((p1 x - p0 x) * (p3 y - p0 y))) * b0.
	b3 := (((p1 x - p0 x) * (p2 y - p0 y)) - ((p2 x - p0 x) * (p1 y - p0 y))) * b0.
	^aBlock value: b1 value: b2 value: b3! !
!Integer methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16892284!
ifMultipleOf2And5Do: aBlock otherwise: anotherBlock
	"If our prime factorization consists only of 2's and 5's, evaluate aBlock with the exponents.
	Otherwise evaluate anotherBlock.
	Be fast!!"

	| exponent2 exponent5 without2Factors |
	exponent2 := self lowBit-1.
	without2Factors := self bitShift: exponent2 negated.
	exponent5 := ( 0.430676558073393 "2 ln / 5 ln" * without2Factors highBit) truncated.
	(5 raisedToInteger: exponent5) = without2Factors
		ifTrue: [
			aBlock value: exponent2 value: exponent5 ]
		ifFalse: [
			anotherBlock lines ]! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50470748!
performWithFormulaWithInteger

	self assert: (formulaOfTenPesos perform: messageName with: 1) lines = 
		(formulaOfTenPesos lines perform: messageName with: 1 lines)! !
!ExtractMethodTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50430802!
test51ExtractsManyRepetitionsWithMoreThanTwoStatementsOnSameMethod

	| sourceMethodName finder sourceMethod extractMethod intervalToExtract newMessage |
	
	sourceMethodName := classToRefactor compile: 'm1 10 factorial. 15 factorial. 20 factorial. true ifTrue: [ 10 factorial. 15 factorial. 20 factorial]'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	intervalToExtract := (4 to: 43) asSourceCodeInterval.
	newMessage := Message selector: #m2.
	finder := ExtractMethodReplacementsFinder ofCodeIn: intervalToExtract at: sourceMethod to: newMessage. 
	finder lines.
	
	extractMethod := ExtractMethod 
		newDefinition: (ExtractMethodNewMethod 
			fromInterval: intervalToExtract 
			of: sourceMethod 
			to: newMessage 
			categorizedAs: #something
			withArgumentNames: Dictionary new)
		replacements: finder replacements.
		
	extractMethod apply.
	
	self assert: 
 'm2

	10 factorial. 15 factorial. 20 factorial' equals: (classToRefactor >> #m2) sourceCode.
	self assert: 'm1 self m2. true ifTrue: [ self m2]' equals: (classToRefactor >> #m1) sourceCode.
	! !
!CodeForNodeOnMethod methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50531639!
intervalsToModify

	node accept: self.
	intervalsToModify := intervalsToModify collect: [ :anAssociation | (anAssociation key - nodeOffsetInSourceCode) -> anAssociation lines ]! !
!Dictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16849061!
keyForIdentity: anObject
	"If anObject is one of the values of the receive, return its key, else return nil.  Contrast #keyAtValue: in which there is only an equality check, here there is an identity check"

	self associationsDo: [:assoc | assoc lines == anObject ifTrue: [^ assoc key]].
	^ nil! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16808195!
methodsWithAnyInitialsOtherThan: myInits
	"Return a collection of method refs whose author appears to be different from the given one, even historically"
	| slips |
	slips := Set new.
	self changedClasses do: [:aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc lines) ifFalse: [
				method := aClass compiledMethodAt: mAssoc key ifAbsent: nil.
				method ifNotNil: [
					(aClass changeRecordsAt: mAssoc key) do: [ :chg | | aTimeStamp |
						aTimeStamp := chg stamp.
						(aTimeStamp notNil and: [(aTimeStamp beginsWith: myInits) not])
							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].
	^ slips! !
!CompiledMethodCoverageTracker methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50501658!
coverAll: sourceRanges evaluating: aBlock thatSends: aSelector to: aReceiver   
	
	"Register that the evaluation of aBlock covered sourceRanges.
	Return the result of evaluating aBlock."
	
	^ [
		| result |
		result := aBlock lines.
		
		self
			coverAll: sourceRanges
			fromSending: aSelector
			to: aReceiver
			withResult: result.
		
		result ]
	 ifCurtailed: [
		self
			coverAll: sourceRanges
			fromSending: aSelector
			to: aReceiver
		] ! !
!ArithmeticObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461263!
convertTo: aUnit ifSuccessful: aSuccessfulBlock ifFails: aFailureBlock

	| convertedMeasure |
	
	convertedMeasure := [ self convertTo: aUnit ] 
		on: CanNotConvertMeasureException 
		do: [ :anError | ^aFailureBlock lines ].
		
	^aSuccessfulBlock value: convertedMeasure ! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461668!
convertTo: aTargetUnit using: aMeasureConverter

	^self lines convertTo: aTargetUnit using: aMeasureConverter! !
!ReceptiveAccount methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50598670!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	self transactions do: [:transaction | 
		(transaction isKindOf: Deposit)  ifTrue: [finalAmountDeposits := finalAmountDeposits + transaction lines. 
											 resumen nextPutAll: 'Depsito por ' , finalAmountDeposits asString].
		(transaction isKindOf: Withdraw)  ifTrue: [finalAmountWithdraws := finalAmountWithdraws + transaction lines.
												resumen nextPutAll: 'Extraccin por ' , finalAmountWithdraws asString].
		(transaction isKindOf: Transfer) ifTrue: [ self shouldBeImplemented ] ifFalse: 
		[resumen nextPutAll: ('Depsito por 0 ' , 'Extraccin por 0' , 'Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = ', (self balance) asString)]
		 
	].
	^ resumen nextPutAll: ('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = ', (self balance) asString) ! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50599010!
initializeFor: anAccount on: aTransference
	(anAccount isKindOf: ReceptiveAccount ) ifFalse: 
	[self error: self class errorTransferenceSenderOrReceiverShouldBeAReceptiveAccount ].
	withdraw := Withdraw register: (aTransference lines) on: anAccount.
	transference := aTransference ! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50426841!
test15FindsRepetitionsOfInstanceVariable

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	classToRefactor addInstVarName: 'iv1'.
	sourceMethodName := classToRefactor compile: 'm1 iv1. iv1 + 2'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 6) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 6) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (9 to: 11) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!ClosureSerializationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50400734!
testSample08
	| blockClosures materialized |

	blockClosures _ self bc08.
	"If sibling closures are serialized separately, their relationship is lost in the copies."
	materialized _ blockClosures collect: [ :each | each veryDeepCopy ].
	self assert: blockClosures first lines = materialized first lines.
	self assert: (blockClosures second value: 7) = (materialized second value: 7).
	self assert: blockClosures third lines = materialized third lines.
	self deny: (blockClosures second value: 7) = (materialized second value: 7).
	self deny: (blockClosures fourth value: 2 value: 3) = (materialized fourth value: 2 value: 3).

	blockClosures _ self bc08.
	"If sibling closures are serialized together, their relationship is kept in the copies."
	materialized _ blockClosures veryDeepCopy.
	self assert: blockClosures first lines = materialized first lines.
	self assert: (blockClosures second value: 7) = (materialized second value: 7).
	self assert: blockClosures third lines = materialized third lines.
	self assert: (blockClosures second value: 7) = (materialized second value: 7).
	self assert: (blockClosures fourth value: 2 value: 3) = (materialized fourth value: 2 value: 3).! !
!Time class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16996635!
microsecondsToRun: timedBlock 
	"Answer the number of microseconds timedBlock takes to return its value."

	| initialMicroseconds |
	initialMicroseconds := self localMicrosecondClock.
	timedBlock lines.
	^self localMicrosecondClock - initialMicroseconds! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50457239!
allActualLocalImplementorsOf: sentSelector forAll: types

	^(AllActualLocalImplementors of: sentSelector forAll: types) lines


! !
!CodePackage class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16825017!
packageOfMethodCategory: categoryName ofClass: aClass ifNone: errorBlock

	InstalledPackages ifNil: [ ^errorBlock lines ].
	^ InstalledPackages
		detect: [:ea | ea includesMethodCategory: categoryName ofClass: aClass]
		ifNone: errorBlock! !
!IniFileSection methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16883012!
writeOn: aStream
	name ifNotNil: [ 
		aStream
			nextPut: $[; nextPutAll: name; nextPut: $]; newLine ].
	entries associationsDo: [ :assoc |
		aStream nextPutAll: assoc key; nextPut: $=; nextPutAll: (assoc lines ifNil: ['']); newLine ].
! !
!BrowserWindow methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50553893!
contextualMoveInstanceVariable

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RefactoringApplier moveInstanceVariableApplier on: model at: aClass ) lines].! !
!WeakSet methodsFor: 'as yet unclassified' library: #MinimalKernel02Symbol stamp: 'BSN 11/7/2025 14:58:22' prior: 50372400!
lookup: anObject ifAbsentAddFrom: aBlock
	"Look for an element equal to anObject.
	If found, answer it.
	If not found, evaluate aBlock, add the result and answer it.
	Note: Do NOT add anObject to the Set!!"
	
	| newObject |
	^(self lookup: anObject) ifNil: [
		newObject := aBlock lines.
		self basicAdd: newObject withHash: (self hashFor: newObject).
		newObject ].! !
!Evaluation methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50461340!
sameDomainAs: aMeasure

	^self lines sameDomainAs: aMeasure! !
!InstructionPrinter methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16889763!
pushConstant: obj
	"Print the Push Constant, obj, on Top Of Stack bytecode."

	self print: (String streamContents:
				[:s |
				s nextPutAll: 'pushConstant: '.
				obj isVariableBinding
					ifFalse: [obj printOn: s]
					ifTrue: [obj key
						ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]
						ifNil: [s nextPutAll: '###'; nextPutAll: obj lines soleInstance name]]]).

	(obj is: #CompiledMethod) ifTrue:
		[obj longPrintOn: stream indent: self indent + 2.
		^self].! !
!ManyMethodsTypeCheckerTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50454741!
test12HasErrorsReturnsTrueIfATypeCheckerHasErrors

	| typeChecker |

	typeChecker := ManyMethodsTypeChecker forAll: { TypeCheckerTestMethods >> #methodWithTypeError }.
	typeChecker lines.

	self assert: typeChecker hasErrors ! !
!InlineTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16885555!
inlineAssignmentNode: anAssignmentNode withExpression: anExpression upTo: anIndex

	| assignmentNodeValue |

	assignmentNodeValue := anAssignmentNode lines.
	assignmentNodeValue isMessageNode
		ifTrue: [
			assignmentNodeValue isUnaryMessageSend
				ifTrue: [self inlineTemporaryNodeWithLiteralOrUnaryMessageExpression: anExpression
					upTo: anIndex].
			assignmentNodeValue isInfix
				ifTrue: [self inlineTemporaryNodeWithBinaryMessageExpression: anExpression
					upTo: anIndex].
			assignmentNodeValue isKeywordMessageSend
				ifTrue: [self inlineTemporaryNodeWithKeywordMessageExpression: anExpression
					upTo: anIndex].

		]
		ifFalse: [self inlineTemporaryNodeWithLiteralOrUnaryMessageExpression: anExpression upTo: anIndex].! !
!IntroduceNullObject methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50539333!
replaceAssignments

	| encoder rangesToReplacement nilAssignmentsFinder nullObjectNew methodNode selectorsChecked |

	nullObjectNew := (nullClass name, ' new').
	nilAssignmentsFinder := ParseNodeEnumerator ofBlock: [ :node |
		(self isAssignmentToNil: node) ifTrue: [ | ranges assignmentRange nilRange |
			ranges := encoder rangeForNode: node lines ifAbsent: [self shouldNotHappen].
			assignmentRange := encoder rangeForNode: node ifAbsent: [self shouldNotHappen].
			nilRange := ranges detect: [:range | assignmentRange rangeIncludes: range first].
			rangesToReplacement add: (Association key: nilRange value: nullObjectNew)].
		
		(self isAssignmentToNonNil: node) ifTrue: [ 
			rangesToReplacement add: (self rangeToReplaceToReplacementFrom: methodNode of: node)]].
	selectorsChecked := Set new.
	replacementParameters do: [:replacementParameter | | refactoredSource  |
		(selectorsChecked includes: replacementParameter methodNode selector) ifFalse: [
			selectorsChecked add: replacementParameter methodNode selector.
			rangesToReplacement := SortedCollection sortBlock: [:intA :intB | intA key first < intB key first].
			methodNode := replacementParameter methodNode.
			encoder := methodNode encoder.
			methodNode accept: nilAssignmentsFinder.
			refactoredSource := replacementParameter methodSourceCode copyReplacing: rangesToReplacement.
			methodNode methodClass compile: refactoredSource]]! !
!ExtractMethodFinderTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50426755!
test12FindsRepetitionsOfOneMessageSend

	| sourceMethodName finder methodsToExtractFrom sourceMethod replacement |
	
	sourceMethodName := classToRefactor compile: 'm1 10 factorial. 10   factorial'.
	
	sourceMethod := (classToRefactor >> sourceMethodName) asMethodReference.
	finder := ExtractMethodReplacementsFinder ofCodeIn: (4 to: 15) asSourceCodeInterval at: sourceMethod to: (Message selector: #m2). 
	finder lines.
	
	methodsToExtractFrom := finder replacements.
	
	self assert: 2 equals: methodsToExtractFrom size.
	replacement := methodsToExtractFrom first.
	self assert: (4 to: 15) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	
	replacement := methodsToExtractFrom second.
	self assert: (18 to: 31) equals: replacement intervalToExtract.
	self assert: (replacement isOf: sourceMethod).
	! !
!ReportTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50599466!
test05AccountSummaryForAccountWithDepositWithdrawAndDoubleTransferReturnsCorrectSummary
	| account1 account2 accountSummary transfer1 transfer2 |
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account1.
	Withdraw register: 50 on: account1.
	transfer1 := Transfer register: 50 from: account2 to: account1.
	transfer2 := Transfer register: 50 from: account1 to: account2.
	accountSummary := AccountSummary on: account1.
	
	self assert: (accountSummary lines = ('Dposito por 50' , 'Extraccin por 50' , 'Salida por transferencia por 50' , 'Entrada por transferencia por 50' , 'Balance = 0'))! !
!Morph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16910640!
valueOfProperty: aSymbol ifAbsentPut: aBlock
	"if the receiver possesses a property of the given name, answer
	its value. If not then evaluate aBlock to obtain the value to be
	stored and answered."

	^ self valueOfProperty: aSymbol ifAbsent: [
		self setProperty: aSymbol toValue: aBlock lines ]! !
!VariablesTypes methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50446038!
typesOf: aVarName ifAbsent: aBlock

	| varTypeInfo |

	varTypeInfo := self typeInfoOf: aVarName ifAbsent: [ ^aBlock lines ].

	^varTypeInfo types! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16941390!
compiledMethodAt: selector ifAbsent: aBlock
	^aBlock lines! !
!MethodVariablesTypes methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50446375!
typeInfoOf: aVarName ifAbsent: anAbsentBlock

	| rawTypes |

	rawTypes := methodProperties rawTypesOf: aVarName ifAbsent: [ ^anAbsentBlock lines ].

	^method methodClass createMethodVariableTypeInfoOf: aVarName in: method are: rawTypes ! !
!LiveTypingCodeSimulationTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50453803!
assignmentToRemoteTemporary

	| localTemp remoteTemp |

	localTemp := 1.

	[ remoteTemp := localTemp printString ] lines.

	^remoteTemp ! !
!WebSocket methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50593356!
handle: selector arguments: argList ifAbsent: aBlock

	^(handlers at: selector ifAbsent:[^aBlock lines])
		valueWithPossibleArgs: argList.! !
!Browser methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16799727!
pushDownInstanceVariable

	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		(PushDownInstanceVariableApplier on: self at: aClass ) lines].! !
!WebClient methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50589681!
writeCookiesFor: request on: aStream
	"Write the cookies for a particular request"

	(cookies select:[:ck| (request acceptsCookie: ck from: self )]) ifNotEmpty:[:ckset|
		aStream nextPutAll: 'Cookie: '.
		ckset 
			do:[:ck| aStream nextPutAll: ck name,'=', ck lines]
			separatedBy:[aStream  nextPutAll:'; '].
		aStream crlf.
	].
! !
!True methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16999525!
ifTrue: alternativeBlock 
	"Answer the value of alternativeBlock. Execution does not actually 
	reach here because the expression is compiled in-line."

	^alternativeBlock lines! !
!Semaphore methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16954837!
critical: mutuallyExcludedBlock ifLocked: alternativeBlock
	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 
	the process of running the critical: message. If the receiver is, then evaluate 
	alternativeBlock and return."
	"See the comment of #critical: for the explanation how this pattern works
	before changing the code."

	| caught |
	caught := false.
	^[
		"Note: The following is tricky and depends on the fact that the VM will not switch between processes while executing byte codes (process switches happen only in real sends). The following test is written carefully so that it will result in bytecodes only.
	Do not change the following #== for #=, as #== is not a real message send, just a bytecode."
		excessSignals == 0
			ifTrue: [
				"If we come here, then the semaphore was locked when the test executed. 
				Evaluate the alternative block and answer its result."
				alternativeBlock lines ]
			ifFalse: [
				excessSignals := excessSignals - 1.
				caught := true.
				mutuallyExcludedBlock lines ] ]
		ensure: [ caught ifTrue: [ self signal ] ]! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16846978!
popIntoTemporaryVariable: offset
	| maybeTVTag tempVector start |
	maybeTVTag := stack last.
	((maybeTVTag isMemberOf: Association)
	 and: [maybeTVTag key == #pushNewArray]) ifTrue:
		[blockStartsToTempVars "implies we were intialized with temp names."
			ifNotNil: "Use the provided temps"
				[self assert: ((tempVector := tempVars at: offset + 1 ifAbsent: [ParseNode basicNew]) isTemp
							 and: [tempVector isIndirectTempVector
							 and: [tempVector remoteTemps size = maybeTVTag lines size]])]
			ifNil: "Synthesize some remote temps"
				[tempVector := maybeTVTag lines.
				 offset + 1 <= tempVars size
					ifTrue:
						[start := 2.
						 tempVector at: 1 put: (tempVars at: offset + 1)]
					ifFalse:
						[tempVars := (Array new: offset + 1)
										replaceFrom: 1
										to: tempVars size
										with: tempVars.
						start := 1].
				 start to: tempVector size do:
					[:i|
					tempVector
						at: i
						put: (constructor
								codeTemp: numLocalTemps + offset + i - 1
								named: 'temp', (tempVarCount + i) printString)].
				tempVars at: offset + 1 put: (constructor codeRemoteTemp: offset + 1 remoteTemps: tempVector)].
		 tempVarCount := tempVarCount + maybeTVTag lines size.
		 stack removeLast.
		 ^self].
	stack addLast: (offset >= tempVars size
						ifTrue: "Handle the case of chained LiteralVariableBinding assigments"
							[stack at: (offset + 1 - tempVars size)]
						ifFalse: "A regular argument or temporary"
							[tempVars at: offset + 1]).
	self doStore: statements! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16935624!
untilEnd: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			[ self atEnd ] whileFalse: [
				barBlock value: self position.
				aBlock lines ]]! !
!Bag methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16786562!
remove: oldObject ifAbsent: exceptionBlock 
	"Refer to the comment in Collection|remove:ifAbsent:."

	| count |
	count := contents at: oldObject ifAbsent: [^ exceptionBlock lines].
	count = 1
		ifTrue: [contents removeKey: oldObject]
		ifFalse: [contents at: oldObject put: count - 1].
	^ oldObject! !
!PushUpMethod class methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16942339!
assertIsValidToRemove: subclassesToRemoveMethodFrom

	subclassesToRemoveMethodFrom associationsDo: [:assoc | 
		self assert: assoc key isValidToRemoveFrom: assoc lines].

! !
!EntryFieldMorph methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50380629!
keyStroke: aKeyboardEvent
	"Handle a keystroke event."
	
	super keyStroke: aKeyboardEvent.
	aKeyboardEvent wasHandled ifTrue: [
		contents := self editor string.
		self morphExtent: (self morphExtent max: self minimumExtent). "big enough to fit"
		self redrawNeeded.
		^self ].
	
	self pauseBlinking.

	"All the cases below consume the event."
	aKeyboardEvent wasHandled: true.

	"Return - check for special action"
	aKeyboardEvent isReturnKey ifTrue: [
		self crAction ifNotNil: [ :action |
			action lines.
			^self ]].

	"Esc - check for special action"
	aKeyboardEvent isEsc ifTrue: [
		self escAction ifNotNil: [ :action |
			action lines.
			^self  ]].

	self editor processKeystrokeEvent: aKeyboardEvent.
	contents := self editor string.
	self morphExtent: (self morphExtent max: self minimumExtent). "big enough to fit"
	self redrawNeeded.! !
!Object methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16922423!
retryWithGC: execBlock until: testBlock
	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."
	| blockValue |
	blockValue := execBlock lines.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollectMost.
	blockValue := execBlock lines.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollect.
	^execBlock lines.! !
!IdentityDictionary methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 16881677!
keyAtValue: value ifAbsent: exceptionBlock
	"Answer the key that is the external name for the argument, value. If 
	there is none, answer the result of evaluating exceptionBlock."
 
	self associationsDo: 
		[:association | value == association lines ifTrue: [^ association key]].
	^ exceptionBlock lines! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 17006646!
variableGetterBlockIn: aContext

	| temps tempIndex ivars |
	(self varNodeType = 4 and: [self key isVariableBinding]) ifTrue: [
		^[self key lines]
	].
	aContext ifNil: [^nil].
	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].
	self varNodeType = 1 ifTrue: [
		ivars := aContext receiver class allInstVarNames.
		tempIndex := ivars indexOf: self name ifAbsent: [^nil].
		^[aContext receiver instVarAt: tempIndex]
	].
	self varNodeType = 2 ifTrue: [
		temps := aContext tempNames.
		tempIndex := temps indexOf: self name ifAbsent: [^nil].
		^[aContext tempAt: tempIndex]
	].
	^nil
! !
!GregorianTimespan methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50599616!
lines

	^self class from: from lines duration: duration! !
!CodeForNodeToMove methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50599688!
lines
	| newCode newCodeForNode |
	self initializeNodeInterval.
	self initializeOffset.
	node accept: self.
	intervalsToModify := intervalsToModify collect: [ :anAssociation | (anAssociation key - nodeOffsetInSourceCode) -> anAssociation lines ].
	newCodeForNode := methodNode sourceText copyFrom: nodeInterval first to: nodeInterval last.
	
	intervalsToModify sort: [ :left :right | left key first < right key first ].
	newCode := newCodeForNode copyReplacing: intervalsToModify.
	 
	hasImplicitSelfReturn 	ifTrue: [ 
			(newCode last = $.) ifFalse: [newCode := newCode append: '.'].
			newCode := newCode append: String newLineString, String tab, '^', parameterNeeded parameterName, '.'
			].
	^CodeForNodeToMoveResult 
				newWith: newCode 
				sourceClass: methodNode methodClass
				targetClass: targetClass
				methodsToCompileOnSourceClass: methodToCompileOnSourceClass! !
!Preference methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50599960!
lines
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value lines]
		ifFalse: [value]
	! !
!CodeCoverageTest methodsFor: 'as yet unclassified' stamp: 'BSN 11/7/2025 14:58:22' prior: 50600244!
lines

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super lines! !

!methodRemoval: Object #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^self!

!methodRemoval: Evaluation #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	self subclassResponsibility!

!methodRemoval: CachedEvaluation #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	cachedValue isNil ifTrue: [self initializeCachedValue].
	^cachedValue!

!methodRemoval: DummyEvaluation #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^measure!

!methodRemoval: TopologicalSort #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	| tempGraph result |

	tempGraph := graph copy.
	result := OrderedCollection new.

	[tempGraph notEmpty] whileTrue: [| startingNodes |
		startingNodes := tempGraph nodesWithoutConvergingEdges.
		result addAll: startingNodes.
		tempGraph := tempGraph removeNodes: startingNodes].

	^result!

!methodRemoval: GregorianTimespan #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^self class from: from lines duration: duration!

!methodRemoval: DecisionConditionCoverageReportBuilder #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^ CodeCoverageReport
		for: compiledMethod
		executed: compiledMethodWasExecuted
		with: self consolidateCoverageResults
		messages: self messages.!

!methodRemoval: CodeCoverageAnalyzerBuilder #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^ CodeCoverageAnalyzer toAnalyzeAll: self compiledMethodsToAnalyze!

!methodRemoval: AssignmentNode #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	^ value!

!methodRemoval: CodeCoverageSourceCodeGenerator #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	"Add tracing to methodNode to generate its traced source code.
	
	I traverse the method node's AST adding tracing to each parse node.
	For more information about how each type of parse node is traced, see methods in my 'visiting' protocol."
	
	methodNode accept: self.
	
	"Force source text generation"
	methodNode sourceText: nil.
	
	tracedSourceCode := methodNode sourceText.!

!methodRemoval: MessageSendingBlocksVariablesToExtractFinder #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	messageNode arguments do: [:argument |
		currentScopeTemporaries := Bag new.
		argument accept: self].

	variablesToExtract remove: 'true' ifAbsent: [nil].
	variablesToExtract remove: 'false' ifAbsent: [nil].
	variablesToExtract remove: 'nil' ifAbsent: [nil].
	variablesToExtract remove: variableToExclude ifAbsent: [nil].

	^OrderedCollection newFrom: variablesToExtract!

!methodRemoval: VariablesToExtractFinder #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	variablesToExtract addAll: methodNode argumentNames.
	methodNode accept: self.

	^variablesToExtract!

!methodRemoval: CodeForNodeOnMethod #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	
	self initializeNodeInterval.
	self initializeOffset.
	self intervalsToModify.
	^self newModifiedCode.
	
!

!methodRemoval: ClassVarAssignationChecker #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	returnBlockTrue := [^true].
	compiledMethod methodNode accept: self.
	^false!

!methodRemoval: CodeForNodeToMove #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	| newCode newCodeForNode |
	self initializeNodeInterval.
	self initializeOffset.
	node accept: self.
	intervalsToModify := intervalsToModify collect: [ :anAssociation | (anAssociation key - nodeOffsetInSourceCode) -> anAssociation lines ].
	newCodeForNode := methodNode sourceText copyFrom: nodeInterval first to: nodeInterval last.
	
	intervalsToModify sort: [ :left :right | left key first < right key first ].
	newCode := newCodeForNode copyReplacing: intervalsToModify.
	 
	hasImplicitSelfReturn 	ifTrue: [ 
			(newCode last = $.) ifFalse: [newCode := newCode append: '.'].
			newCode := newCode append: String newLineString, String tab, '^', parameterNeeded parameterName, '.'
			].
	^CodeForNodeToMoveResult 
				newWith: newCode 
				sourceClass: methodNode methodClass
				targetClass: targetClass
				methodsToCompileOnSourceClass: methodToCompileOnSourceClass!

!methodRemoval: MethodWorksAsGetterVisitor #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	returnMethodIsNotGetterClousure := [^false].
	returnMethodIsGetterClousure := [^true].
	getterCandidate methodNode accept: self.
	^false!

!methodRemoval: NeedParameterName #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	  
	methodNode := compiledMethod methodNode.
	methodNode accept: self.
	^self needParameterName !

!methodRemoval: MultiImplementorsActualMessageSendsCollector #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	self
		calculateSendersInfo;
		groupSendersByType;
		createMessageList !

!methodRemoval: ReceiverTypesOfMessageSendsConform #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	notIncludedReceiverTypesInMessageSends := OrderedCollection new.

	implementors ifNotEmpty: [
		sentSelector := implementors anyOne selector.
		types := implementors collect: [ :anImplementor | anImplementor methodClass ].

		senders do: [ :aSender |
			currentSender := aSender.
			currentSenderMethodClass := aSender methodClass.
			currentSender notOptimizedMethodNode accept: self ]].

	^notIncludedReceiverTypesInMessageSends!

!methodRemoval: MethodTypeCheckerVisitor #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	self
		prepareToValue;
		visitMethodNode: methodNode.
!

!methodRemoval: ZipEncoderNode #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	^value!

!methodRemoval: Collaborator #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^owner instVarNamed: name!

!methodRemoval: Delegator #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	
	| implementor |
	
	implementor := currentMethodClass superclass.
	[ implementor ~= DenotativeObject class ] whileTrue: [
		(implementor includesSelector: selector) ifTrue: [ | methodToDelegate |
			methodToDelegate := implementor compiledMethodAt: selector.
			^ methodToDelegate
				valueWithReceiver: receiver
				arguments: arguments ].
		implementor := implementor superclass ].
	
	self error: 'No parent implements ' , selector.
!

!methodRemoval: ArgumentsAndReturnsFinder #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	| paramsAndReturnsFinder |
	
	ranges := OrderedCollection new.
	
	paramsAndReturnsFinder := ParseNodeEnumerator ofBlock: [ :node | 	
		(self isReturnIvar: node) ifTrue: [self addReturnRangesFrom: node].
		(self isMessageWithIvarAsArg: node) ifTrue: [ self addParametersRangesFrom: node]].

	methodNode accept: paramsAndReturnsFinder.
!

!methodRemoval: ReturnStatementAdder #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	self nonImplicitNumberOfStatements = 1 ifTrue: [ self valueOneStatement ].
	self nonImplicitNumberOfStatements > 1 ifTrue: [ self valueMultipleStatements ].	!

!methodRemoval: IfNilChecksFinder #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	| selectors |

	selectors := contextClass whichSelectorsAccess: instanceVariable.

	^selectors inject: OrderedCollection new into: [:ifNilChecks :selector |
		ifNilChecks addAll: (self ifNilChecksIn: selector). ifNilChecks.].!

!methodRemoval: TTKernPair #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	^value!

!methodRemoval: WeakActionSequence #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	"Do the same as my parent, but make sure that all actions that do not  
	give errors are evaluated before resignaling the ones that gave errors  
	(giving the chance to clients to handle them)."

	^self valueStartingFrom: 1!

!methodRemoval: BlockClosure #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the copied values to the activation as its copied
	 temps. Primitive. Essential."
	<primitive: 201>

	numArgs ~= 0 ifTrue:
		[self numArgsError: 0].
	self primitiveFailed.!

!methodRemoval: FilteredGregorianDate #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^date
!

!methodRemoval: RelativeGregorianDate #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^self absoluteDate!

!methodRemoval: Association #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	"Answer the value of the receiver."
	^value!

!methodRemoval: ReadOnlyVariableBinding #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	^value!

!methodRemoval: MessageSend #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	"Send the message and answer the return value"

	arguments ifNil: [^ receiver perform: selector].

	^ receiver 
		perform: selector 
		withArguments: (self collectArguments: arguments)!

!methodRemoval: WeakMessageSend #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	^ arguments
		ifNil: [
			self withEnsuredReceiverDo: [ :r | r perform: selector ]]
		ifNotNil: [
			self withEnsuredReceiverAndArgumentsDo: [ :r :a |
				r
					perform: selector
					withArguments: a ]]!

!methodRemoval: ActualImplementorsFinder #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	self subclassResponsibility !

!methodRemoval: AllActualImplementors #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	| typeImplementors |

	notImplemented := OrderedCollection new.
	implementors := Set new.
	types do: [ :aType |
		typeImplementors := Smalltalk actualImplementorsOf: selector in: aType.
		typeImplementors isEmpty
			ifTrue: [ notImplemented add: (NotImplementedMethod class: aType selector: selector) ]
			ifFalse: [ implementors addAll: typeImplementors ]].

	^self!

!methodRemoval: AllActualLocalImplementors #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	notImplemented := OrderedCollection new.
	implementors := types
		inject: IdentitySet new
		into: [ :methods :aClass |
			(aClass lookupSelector: selector )
				ifNil: [ notImplemented add: (NotImplementedMethod class: aClass selector: selector ) ]
				ifNotNil: [ :method | methods add: method ].
			methods ].

	implementors := implementors collect: [ :method | method asMethodReference ].

	^self
!

!methodRemoval: TypeChecker #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	self subclassResponsibility!

!methodRemoval: ManyMethodsTypeChecker #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	typeCheckers := methodsToCheck collect: [:aMethod | aMethod typeCheck ].

	^self!

!methodRemoval: MethodTypeChecker #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	self
		initializeErrorsWarningsAndProblems;
		typeCheck.

	^self!

!methodRemoval: DropFilesAction #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	stopHereBlock := [ ^self ].
	dropFilesEvent fileNamesDo: [ :fileName | self fileNamedDropped: fileName ]
		
!

!methodRemoval: AccountTransaction #value stamp: 'BSN 11/7/2025 14:58:22'!
value 

	self subclassResponsibility !

!methodRemoval: Deposit #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^ value!

!methodRemoval: Withdraw #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^ value!

!methodRemoval: AccountSummary #value stamp: 'BSN 11/7/2025 14:58:22'!
value 
	^ summary !

!methodRemoval: TransferNet #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	^ net!

!methodRemoval: Transfer #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	^ value!

!methodRemoval: ControlChangeEvent #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^ value
!

!methodRemoval: Preference #value stamp: 'BSN 11/7/2025 14:58:22'!
value
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value lines]
		ifFalse: [value]
	!

!methodRemoval: SubstringMatcher #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	^ resultsSorter value: (self filterCollection asOrderedCollection)!

!methodRemoval: CatalogButton #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	
	model changeSelectedCatalog: catalog!

!methodRemoval: ClassReferencesCollector #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	| withAllSubclasses |
	
	withAllSubclasses := classToLookForReferences withAllSubclasses.
	self initializeCollectionFor: withAllSubclasses.
		
	withAllSubclasses do: [ :aClass | self collectReferencesOf: aClass ].
		
	!

!methodRemoval: ExtractMethodNewMethodSourceCode #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	self 
		initializeSourceCodeToExtract;
		initiliazeNewSourceCode;
		renameArguments. 
	
	^newSourceCode !

!methodRemoval: ExtractMethodParametersDetector #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	
	"Return the parse nodes of the parameters to use in the extracted method.
	
	Implementation details
	--------------
	The enumeration order of the parse nodes is non-deterministic.
	
	To fix this, I keep track of the position for each parameter node to sort
	results in the order they appear in the source code."
	
	| parameterNodePositions |
	
	parameterNodePositions := Dictionary new.
	
	methodNodeToRefactor completeSourceRangesDo: [ :parseNode :sourceRanges |
		(self shouldBeParameterized: parseNode appearingIn: sourceRanges)
			ifTrue: [ 
				parameterNodePositions
					at: parseNode
					put: (self firstPositionInIntervalToExtractIn: sourceRanges) ]].
		
	^ parameterNodePositions keys sort: [ :parameterNode :anotherParameterNode |
		(parameterNodePositions at: parameterNode) <= (parameterNodePositions at: anotherParameterNode) ]!

!methodRemoval: ExtractMethodReplacementsFinder #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	nodesToExtract := self nodesToExtract.
	replacements := OrderedCollection new.
	findingStrategy := self defineFindingStrategy.
	
	self findReplacementInHierarchy.!

!methodRemoval: NodesInRangeFinder #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	
	| nodeAtLastPositionFound |

	"Because some nodes have many ranges, like the literal nodes, we count the time we pass by a node that is equivalent
	to the index in the source ranges collection. sourceRangeIndexByNode is used to count per node - Hernan"
	sourceMethodNode := sourceMethod methodNode.
	sourceCode := sourceMethod sourceCode.
	statements := OrderedCollection new.
	sourceRangeIndexByNode := IdentityBag new.
	firstNodeFound := false.

	sourceMethodNode nodesDo: [ :aNode | | nodeRange |
		sourceRangeIndexByNode add: aNode.
		nodeRange := self completeSourceRangeOf: aNode.
		nodeAtLastPositionFound := self ifInsideRangeAddToStatements: aNode locatedAt: nodeRange.
		nodeAtLastPositionFound ifTrue: [ ^statements ]].
			
	self error: 'nodes not found'
	!

!methodRemoval: RefactoringApplier #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	requestExitBlock := [ ^self ].
	
	self 
		requestRefactoringParametersHandlingRefactoringExceptions;
		createRefactoringHandlingRefactoringExceptions;
		applyRefactoring;
		showChanges
	
	!

!methodRemoval: ExtractClassApplier #value stamp: 'BSN 11/7/2025 14:58:22'!
value
	self requestRefactoringParametersHandlingRefactoringExceptions.!

!methodRemoval: ExtractToMethodObjectApplier #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	self requestRefactoringParametersHandlingRefactoringExceptions.!

!methodRemoval: IntroduceNullObjectApplier #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	self requestRefactoringParametersHandlingRefactoringExceptions.!

!methodRemoval: ExtractMethodApplier #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	requestExitBlock := [ ^self ].
	
	self requestRefactoringParametersHandlingRefactoringExceptions
!

!methodRemoval: ChangeSelectorApplier #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	requestExitBlock := [ ^self ].
		
	self requestRefactoringParametersHandlingRefactoringExceptions.
	
	self 
		ifHasNoSendersAndOneImplementor: [ :anImplementor | 
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor ]
		ifNot: [ self askForImplementosAndSenders ]!

!methodRemoval: ExtractParameterObjectApplier #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	requestExitBlock := [ ^self ].
	methodToRefactor := selectedClass compiledMethodAt: oldSelector.
		
	self requestRefactoringParametersHandlingRefactoringExceptions.!

!methodRemoval: InlineMethodApplier #value stamp: 'BSN 11/7/2025 14:58:22'!
value

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollection new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]!

!methodRemoval: RefactoringPrecondition #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	self subclassResponsibility!

!methodRemoval: NewClassPrecondition #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	self assertNewClassNameIsNotEmpty.
	self assertNewClassNameSymbol.
	self assertNewClassNameStartsWithRightLetter.
	self assertNewClassNameHasNoSeparators.
	self assertNewClassNameDoesNotExistInSystem.
	self assertNewClassNameIsNotDeclaredInUndeclared.

!

!methodRemoval: NewGlobalPrecondition #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	self 
		assertNewNameIsNotEmpty;
		assertNewNameIsSymbol;
		assertNewNameHasNoSeparators;
		assertNewNameDoesNotExistInSystem.

!

!methodRemoval: NewInstanceVariablePrecondition #value stamp: 'BSN 11/7/2025 14:58:23'!
value
	
	self assertIsNotEmpty.
	self assertIsNotAReservedName.
	self assertIsValidInstanceVariableName.
	self assertIsNotAlreadyDefined.

	self assertIsNotDefinedInMethods.!

!methodRemoval: NewSelectorPrecondition #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	self
		assertNewSelectorIsNotEmpty;
		assertNewSelectorDoesNotContainSeparators;
		assertNewSelectorBeginsWithAValidCharacter;
		assertNewSelectorContainsOnlyValidCharacters;
		assertNewSelectorIsNotAlreadyDefinedWithinTheClassHierarchy!

!methodRemoval: NewTemporaryPrecondition #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	self
		assertIsNotEmpty;
		assertIsValidVariableName;
		assertIsNotAReservedName;
		assertIsNotDefinedAsInstanceVariableInHierarchyOfMethodClass;
		assertIsNotDeclaredInParentsOrChildrenScopes!

!methodRemoval: SourceCodeIntervalPrecondition #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	self subclassResponsibility!

!methodRemoval: SourceCodeOfMethodToBeExtractedPrecondition #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	self
		initializeParseNodesMatchingSelectionInterval;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotLeftSideOfAssignment;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeDoesNotIncludeTemporaryAssignmentsWithoutDeclaration;
		assertSourceCodeDoesNotHaveTemporaryVariablesUsedOutsideOfSelectionInterval;
		assertSourceCodeContainsAValidExpression!

!methodRemoval: SourceCodeOfTemporaryToBeExtractedPrecondition #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	self
		initializeParseNodeToExtract;
		assertSourceCodeDoesNotIncludeReturnExpressions;
		assertSourceCodeIsNotPartOfTemporariesDeclaration;
		assertSourceCodeIsNotPartOfMethodSignature;
		assertSourceCodeHasOneStatement;
		assertSourceCodeIsACompleteExpression;
		assertSourceCodeContainValidNodes!

!methodRemoval: ProgressiveTestRunner #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	Utilities authorInitials.
	testsStream := ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]!

!methodRemoval: CodeCoverageTest #value stamp: 'BSN 11/7/2025 14:58:23'!
value

	"This example overrides uses super to send the same message that was received.
	
	It is used to verify that a bug was not introduced by the code coverage machinery, because
	wrapping super in a message to track code coverage will return self and the #value message
	will end up being dispatched to self instead of super (as intended) leading to an infinite loop."

	super lines!

!methodRemoval: WebCookie #value stamp: 'BSN 11/7/2025 14:58:23'!
value
	"The value of the cookie"

	^value!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 14:58:49' prior: 50608136!
test01AccountSummaryForEmptyAccountShouldBeAllZeros
	| account accountSummary |
	account := ReceptiveAccount new.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary lines = ('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 0'))
	
	! !

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 14:58:50'!
ERROR!
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 14:59:38' prior: 50612185!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	^ resumen nextPutAll: ('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = ', (self balance) asString) ! !

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 14:59:52'!
ERROR!

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 15:00:03'!
ERROR!

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 15:00:08'!
ERROR!

account := ReceptiveAccount new.!

accountSummary := AccountSummary on: account.!

accountSummary lines!

('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 0') class!

('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 0') class!

accountSummary lines asString !

accountSummary lines asString!

(accountSummary lines) asString!

(accountSummary lines) contents!

(accountSummary lines) contents!
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:03:26' prior: 50613528!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	resumen nextPutAll: ('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = ', (self balance) asString).
	
	^ resumen contents! !

(accountSummary lines)!

(accountSummary lines)!

account := ReceptiveAccount new.!

accountSummary := AccountSummary on: account.!

(accountSummary lines)!
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:03:53' prior: 50613557!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	resumen nextPutAll: ('Salida por transferencia por 0.' , 'Entrada por transferencia por 0.' , 'Balance = ', (self balance) asString).
	
	^ resumen contents! !

(accountSummary lines)!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:04:19' prior: 50613515!
test01AccountSummaryForEmptyAccountShouldBeAllZeros
	| account accountSummary |
	account := ReceptiveAccount new.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary lines = ('Salida por transferencia por 0.' , 'Entrada por transferencia por 0.' , 'Balance = 0.'))
	
	! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:04:34' prior: 50613577!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	resumen nextPutAll: ('Salida por transferencia por 0.' , 'Entrada por transferencia por 0.' , 'Balance = ', (self balance) asString, '.').
	
	^ resumen contents! !

account := ReceptiveAccount new.!

accountSummary := AccountSummary on: account.!

(accountSummary lines)!

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 15:04:48'!
PASSED!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:05:51' prior: 50609315!
test02AccountSummaryForAccountWithDepositReturnsCorrectSummary
	| account accountSummary |
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary lines = ('Dposito por 50.' , 'Salida por transferencia por 0.' , 'Entrada por transferencia por 0.' , 'Balance = 50.'))
	! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:08:09' prior: 50613606!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	
	transactions do: [:tarnsaction |  ].
	
	
	resumen nextPutAll: ('Salida por transferencia por 0.' , 'Entrada por transferencia por 0.' , 'Balance = ', (self balance) asString, '.').
	
	^ resumen contents! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:09:02' prior: 50613640!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	
	transactions do: [:tarnsaction |  
		tarnsaction class = #Deposit ifTrue: []
		].
	
	
	resumen nextPutAll: ('Salida por transferencia por 0.' , 'Entrada por transferencia por 0.' , 'Balance = ', (self balance) asString, '.').
	
	^ resumen contents! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:09:10' prior: 50613657!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	
	transactions do: [:transaction |  
		transaction class = #Deposit ifTrue: []
		].
	
	
	resumen nextPutAll: ('Salida por transferencia por 0.' , 'Entrada por transferencia por 0.' , 'Balance = ', (self balance) asString, '.').
	
	^ resumen contents! !

(accountSummary class) asString !
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:09:58' prior: 50613675!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	
	transactions do: [:transaction |  
		transaction class = #Deposit ifTrue: [ resumen nextPutAll: ('Deposit') ]
		].
	
	
	resumen nextPutAll: ('Salida por transferencia por 0.' , 'Entrada por transferencia por 0.' , 'Balance = ', (self balance) asString, '.').
	
	^ resumen contents! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:10:45' prior: 50613695!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	
	transactions do: [:transaction |  
		transaction class = #Deposit ifTrue: [ resumen nextPutAll: ('Dposito por ', transaction value asString) ]
		].
	
	
	resumen nextPutAll: ('Salida por transferencia por 0.' , 'Entrada por transferencia por 0.' , 'Balance = ', (self balance) asString, '.').
	
	^ resumen contents! !

----STARTUP---- (7 November 2025 15:11:33) as /home/buty/Documents/UBA-CS/25-2C/ISW/Cuis/linux64/linux64/CuisUniversity-7641.image!


----End fileIn of /home/buty/Documents/UBA-CS/25-2C/ISW/ejercicio-3-p3-portfolio-2-este-grupo-es-un-objeto/Portfolio2.st----!
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:13:50' prior: 50598670!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	self transactions do: [:transaction | 
		(transaction isKindOf: Deposit)  ifTrue: [finalAmountDeposits := finalAmountDeposits + transaction value. 
											 resumen nextPutAll: 'Depsito por ' , finalAmountDeposits asString].
		(transaction isKindOf: Withdraw)  ifTrue: [finalAmountWithdraws := finalAmountWithdraws + transaction value.
												resumen nextPutAll: 'Extraccin por ' , finalAmountWithdraws asString].
		(transaction isKindOf: Transfer) ifTrue: [ self shouldBeImplemented ]
	].
	resumen nextPutAll: ('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = ', (self balance) asString) 
	
	^ resumen contents! !

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 15:13:57'!
ERROR!

account := ReceptiveAccount new.!

accountSummary := AccountSummary on: account.!

accountSummary := AccountSummary on: account.!

accountSummary := AccountSummary on: account.!
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:15:17' prior: 50599590!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	self transactions do: [:transaction | 
		(transaction isKindOf: Deposit)  ifTrue: [finalAmountDeposits := finalAmountDeposits + transaction value. 
											 resumen nextPutAll: 'Depsito por ' , finalAmountDeposits asString].
		(transaction isKindOf: Withdraw)  ifTrue: [finalAmountWithdraws := finalAmountWithdraws + transaction value.
												resumen nextPutAll: 'Extraccin por ' , finalAmountWithdraws asString].
		(transaction isKindOf: Transfer) ifTrue: [ self shouldBeImplemented ]
	].
	resumen nextPutAll: ('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = ', (self balance) asString).
	
	^ resumen contents! !

account := ReceptiveAccount new.!

accountSummary := AccountSummary on: account.!

accountSummary value!

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 15:15:33'!
FAILURE!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:15:44' prior: 50599403!
test01AccountSummaryForEmptyAccountShouldBeAllZeros
	| account accountSummary |
	account := ReceptiveAccount new.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary value = ('Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 0'))
	
	! !

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 15:15:48'!
PASSED!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:15:53' prior: 50599416!
test02AccountSummaryForAccountWithDepositReturnsCorrectSummary
	| account accountSummary |
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary value = ('Dposito por 50', 'Salida por transferencia por 0' , 'Entrada por transferencia por 0' , 'Balance = 50'))
	! !

!testRun: #ReportTest #test02AccountSummaryForAccountWithDepositReturnsCorrectSummary stamp: 'BSN 11/7/2025 15:15:53'!
FAILURE!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:16:28' prior: 50599661!
test01AccountSummaryForEmptyAccountShouldBeAllZeros
	| account accountSummary |
	account := ReceptiveAccount new.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary value = ('Balance = 0'))
	
	! !
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:16:41' prior: 50599687!
test01AccountSummaryForEmptyAccountShouldBeAllZeros
	| account accountSummary |
	account := ReceptiveAccount new.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary value = 'Balance = 0')! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:16:53' prior: 50599627!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	self transactions do: [:transaction | 
		(transaction isKindOf: Deposit)  ifTrue: [finalAmountDeposits := finalAmountDeposits + transaction value. 
											 resumen nextPutAll: 'Depsito por ' , finalAmountDeposits asString].
		(transaction isKindOf: Withdraw)  ifTrue: [finalAmountWithdraws := finalAmountWithdraws + transaction value.
												resumen nextPutAll: 'Extraccin por ' , finalAmountWithdraws asString].
		(transaction isKindOf: Transfer) ifTrue: [ self shouldBeImplemented ]
	].
	resumen nextPutAll: 'Balance = ', (self balance) asString.
	
	^ resumen contents! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'BSN 11/7/2025 15:17:12' prior: 50599707!
generateAccountSummary
	| finalAmountDeposits finalAmountWithdraws resumen finalAmountTransferInput |
	resumen := WriteStream on: String new.
	finalAmountDeposits := 0.
	finalAmountWithdraws := 0.
	finalAmountTransferInput := 0.
	
	self transactions do: [:transaction | 
		(transaction isKindOf: Deposit)  ifTrue: [finalAmountDeposits := finalAmountDeposits + transaction value. 
											 resumen nextPutAll: 'Depsito por ' , finalAmountDeposits asString].
		(transaction isKindOf: Withdraw)  ifTrue: [finalAmountWithdraws := finalAmountWithdraws + transaction value.
												resumen nextPutAll: 'Extraccin por ' , finalAmountWithdraws asString].
		(transaction isKindOf: Transfer) ifTrue: [ self shouldBeImplemented ]
	].
	resumen nextPutAll: ('Balance = ', (self balance) asString).
	
	^ resumen contents! !

!testRun: #ReportTest #test01AccountSummaryForEmptyAccountShouldBeAllZeros stamp: 'BSN 11/7/2025 15:17:17'!
PASSED!

!testRun: #ReportTest #test02AccountSummaryForAccountWithDepositReturnsCorrectSummary stamp: 'BSN 11/7/2025 15:17:19'!
FAILURE!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:17:25' prior: 50599673!
test02AccountSummaryForAccountWithDepositReturnsCorrectSummary
	| account accountSummary |
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary value = ('Dposito por 50', 'Balance = 50'))
	! !

account := ReceptiveAccount new.
Deposit register: 50 on: account.
accountSummary := AccountSummary on: account.!

accountSummary value!

accountSummary value = ('Dposito por 50', 'Balance = 50')!

('Dposito por 50', 'Balance = 50')!

accountSummary value!

('Dposito por 50', 'Balance = 50')!

accountSummary value =  'Dposito por 50Balance = 50' .!

accountSummary value!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:19:44' prior: 50599765!
test02AccountSummaryForAccountWithDepositReturnsCorrectSummary
	| account accountSummary |
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary value = ('Deposito por 50', 'Balance = 50'))
	! !

!testRun: #ReportTest #test02AccountSummaryForAccountWithDepositReturnsCorrectSummary stamp: 'BSN 11/7/2025 15:19:45'!
PASSED!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:20:00' prior: 50599430!
test03AccountSummaryForAccountWithDepositAndWithdrawReturnsCorrectSummary
	| account accountSummary |
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	Withdraw register: 50 on: account.
	accountSummary := AccountSummary on: account.
	
	self assert: (accountSummary value = ('Deposito por 50' , 'Extraccin por 50' ,  'Balance = 0'))
	! !

!testRun: #ReportTest #test03AccountSummaryForAccountWithDepositAndWithdrawReturnsCorrectSummary stamp: 'BSN 11/7/2025 15:20:02'!
PASSED!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:20:20' prior: 50599446!
test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary
	| account1 account2 accountSummary transfer |
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account1.
	Withdraw register: 50 on: account1.
	transfer := Transfer register: 50 from: account2 to: account1.
	accountSummary := AccountSummary on: account1.
	
	self assert: (accountSummary value = ('Dposito por 50' , 'Extraccin por 50' , 'Balance = 50'))! !

!testRun: #ReportTest #test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary stamp: 'BSN 11/7/2025 15:20:24'!
FAILURE!

account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account1.
	Withdraw register: 50 on: account1.
	transfer := Transfer register: 50 from: account2 to: account1.
	accountSummary := AccountSummary on: account1.!

accountSummary value!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:21:17' prior: 50599815!
test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary
	| account1 account2 accountSummary transfer |
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account1.
	Withdraw register: 50 on: account1.
	transfer := Transfer register: 50 from: account2 to: account1.
	accountSummary := AccountSummary on: account1.
	
	self assert: (accountSummary value = ('Dposito por 50' , 'Extraccin por 50' , 'Dposito por 50', 'Balance = 50'))! !

!testRun: #ReportTest #test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary stamp: 'BSN 11/7/2025 15:21:19'!
FAILURE!

!testRun: #ReportTest #test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary stamp: 'BSN 11/7/2025 15:21:22'!
FAILURE!
!ReportTest methodsFor: 'test' stamp: 'BSN 11/7/2025 15:21:36' prior: 50599842!
test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary
	| account1 account2 accountSummary transfer |
	account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account1.
	Withdraw register: 50 on: account1.
	transfer := Transfer register: 50 from: account2 to: account1.
	accountSummary := AccountSummary on: account1.
	
	self assert: (accountSummary value = ('Deposito por 50' , 'Extraccin por 50' , 'Deposito por 50', 'Balance = 50'))! !

!testRun: #ReportTest #test04AccountSummaryForAccountWithDepositWithdrawAndTransferReturnsCorrectSummary stamp: 'BSN 11/7/2025 15:21:37'!
FAILURE!

account1 := ReceptiveAccount new.
	account2 := ReceptiveAccount new.
	Deposit register: 50 on: account1.
	Withdraw register: 50 on: account1.
	transfer := Transfer register: 50 from: account2 to: account1.
	accountSummary := AccountSummary on: account1.!

accountSummary value!